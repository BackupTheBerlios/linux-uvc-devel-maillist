From galahad at gmail.com  Wed Jul  1 09:36:59 2009
From: galahad at gmail.com (Alexy)
Date: Wed, 1 Jul 2009 13:06:59 +0530
Subject: [Linux-uvc-devel] Possible to use 2 streaming interface withUVC
	driver?
Message-ID: <1c4e6b4d0907010036h5e98637fu9275116bc417889d@mail.gmail.com>

>The graphedit will just provide any number of pins for the number of
>streaming interface you have.
>You can test each of the pin individually or test them altogether.
>By the way for the UVC device developing side I found the Null renderer in
>DirectShow filter is very helpful for verifying the device.
>I am wondering if there is anything similar on Linux side?

>Brian

GStreamer has something similar to graphedit called gst-editor
(http://gstreamer.freedesktop.org/modules/gst-editor.html) but i
believe what is required is the hardware by itself to provide multiple
streaming interfaces and not to split one stream into multiple ones.

-Alexy


From barsnick at gmx.net  Wed Jul  1 23:06:00 2009
From: barsnick at gmx.net (Moritz Barsnick)
Date: Wed, 1 Jul 2009 23:06:00 +0200
Subject: [Linux-uvc-devel] CLI software to record video
In-Reply-To: <FE9E9F08-F22F-472E-A553-52359DF157E3@luckyluke.org>
References: <FE9E9F08-F22F-472E-A553-52359DF157E3@luckyluke.org>
Message-ID: <20090701210600.GA17768@sunshine.barsnick.net>

On Mon, Jun 29, 2009 at 23:18:05 +0200, Luca Lesinigo wrote:

> I spent some time googling around and looking at the list archives,  
> but I cannot find a (non-X11) software that would let me do a 'simple'  
> video recording without any fancy stuff or reencoding.

First, MJPG-streamer comes to mind. http://mjpg-streamer.sourceforge.net/
Though the MJPEG (HTTP) stream is not yet a valid video file. But the
output_file.so seems to support dropping to JPEG files, and the
mjpegtools should support converting that to a video file without
recompression loss.

Next, I would think of motion.
http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome
I'm not sure though that it has the option _not_ to convert the MJPEG
UVC stream when creating a video file. But it too can drop JPEG files
to disk.

> The _real_ problem is that video is never recorded at constant speed.

That I have no experience with. My (pwc) Logitech QuickCam Pro 4000
exposes no such behavior. Has there ever been any solution to this, to
creating constant speed video files from non-constant FPS /dev/video?

Hope this helps,
Moritz


From pj.assis at gmail.com  Wed Jul  1 23:20:56 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Wed, 1 Jul 2009 22:20:56 +0100
Subject: [Linux-uvc-devel] CLI software to record video
In-Reply-To: <20090701210600.GA17768@sunshine.barsnick.net>
References: <FE9E9F08-F22F-472E-A553-52359DF157E3@luckyluke.org>
	<20090701210600.GA17768@sunshine.barsnick.net>
Message-ID: <59cf47a80907011420s8ef6b49nba0f7bad904a0fbc@mail.gmail.com>

Hi,


> > The _real_ problem is that video is never recorded at constant speed.
>
> That I have no experience with. My (pwc) Logitech QuickCam Pro 4000
> exposes no such behavior. Has there ever been any solution to this, to
> creating constant speed video files from non-constant FPS /dev/video?
>
>
This should only be a problem when using old containers like AVI.
The matroska format uses timecodes for each frame, so video should be in
sync whatever the fps of the device.

Best regards,
Paulo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090701/6b9a336c/attachment.html>

From laurent.pinchart at skynet.be  Thu Jul  2 01:30:09 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 01:30:09 +0200
Subject: [Linux-uvc-devel] [PATCH 0/2] Multiple streaming interfaces support
Message-ID: <200907020130.10001.laurent.pinchart@skynet.be>

Hi everybody,

here's a first try at multiple streaming interfaces support. The two patches 
should be applied in sequence.

The driver will now create a video device per streaming terminal. The 
descriptors parsing code has been roughly tested, but streaming from multiple 
endpoints simultaneously hasn't as I don't own any multiple-streams device. 
MPEG2-TS isn't supported yet.

Please review the code and report results on the mailing list.

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Thu Jul  2 01:31:34 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 01:31:34 +0200
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
	interfaces support
In-Reply-To: <200907020130.10001.laurent.pinchart@skynet.be>
References: <200907020130.10001.laurent.pinchart@skynet.be>
Message-ID: <200907020131.34726.laurent.pinchart@skynet.be>

Restructure the UVC descriptors parsing code to handle multiple streaming
interfaces. The driver now creates a uvc_video_chain instance for each chain
detected in the UVC control interface descriptors, and tries to register one
video device per streaming endpoint.

Priority: normal

Signed-off-by: Laurent Pinchart <laurent.pinchart at skynet.be>

diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_ctrl.c
--- a/linux/drivers/media/video/uvc/uvc_ctrl.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_ctrl.c	Thu Jul 02 01:24:47 2009 +0200
@@ -731,7 +731,7 @@
 	}
 }
 
-struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 	__u32 v4l2_id, struct uvc_control_mapping **mapping)
 {
 	struct uvc_control *ctrl = NULL;
@@ -744,17 +744,17 @@
 	v4l2_id &= V4L2_CTRL_ID_MASK;
 
 	/* Find the control. */
-	__uvc_find_control(video->processing, v4l2_id, mapping, &ctrl, next);
+	__uvc_find_control(chain->processing, v4l2_id, mapping, &ctrl, next);
 	if (ctrl && !next)
 		return ctrl;
 
-	list_for_each_entry(entity, &video->iterms, chain) {
+	list_for_each_entry(entity, &chain->iterms, chain) {
 		__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
 		if (ctrl && !next)
 			return ctrl;
 	}
 
-	list_for_each_entry(entity, &video->extensions, chain) {
+	list_for_each_entry(entity, &chain->extensions, chain) {
 		__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
 		if (ctrl && !next)
 			return ctrl;
@@ -767,7 +767,7 @@
 	return ctrl;
 }
 
-int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 	struct v4l2_queryctrl *v4l2_ctrl)
 {
 	struct uvc_control *ctrl;
@@ -777,7 +777,7 @@
 	__u8 *data;
 	int ret;
 
-	ctrl = uvc_find_control(video, v4l2_ctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, v4l2_ctrl->id, &mapping);
 	if (ctrl == NULL)
 		return -EINVAL;
 
@@ -795,9 +795,10 @@
 		v4l2_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
 	if (ctrl->info->flags & UVC_CONTROL_GET_DEF) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_DEF, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
+		ret = uvc_query_ctrl(chain->dev, GET_DEF, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
+		if (ret < 0)
 			goto out;
 		v4l2_ctrl->default_value = mapping->get(mapping, GET_DEF, data);
 	}
@@ -831,23 +832,26 @@
 	}
 
 	if (ctrl->info->flags & UVC_CONTROL_GET_MIN) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_MIN, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
+		ret = uvc_query_ctrl(chain->dev, GET_MIN, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
+		if (ret < 0)
 			goto out;
 		v4l2_ctrl->minimum = mapping->get(mapping, GET_MIN, data);
 	}
 	if (ctrl->info->flags & UVC_CONTROL_GET_MAX) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_MAX, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
+		ret = uvc_query_ctrl(chain->dev, GET_MAX, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
+		if (ret < 0)
 			goto out;
 		v4l2_ctrl->maximum = mapping->get(mapping, GET_MAX, data);
 	}
 	if (ctrl->info->flags & UVC_CONTROL_GET_RES) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_RES, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
+		ret = uvc_query_ctrl(chain->dev, GET_RES, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
+		if (ret < 0)
 			goto out;
 		v4l2_ctrl->step = mapping->get(mapping, GET_RES, data);
 	}
@@ -883,9 +887,9 @@
  * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release the
  * control lock.
  */
-int uvc_ctrl_begin(struct uvc_video_device *video)
+int uvc_ctrl_begin(struct uvc_video_chain *chain)
 {
-	return mutex_lock_interruptible(&video->ctrl_mutex) ? -ERESTARTSYS : 0;
+	return mutex_lock_interruptible(&chain->ctrl_mutex) ? -ERESTARTSYS : 0;
 }
 
 static int uvc_ctrl_commit_entity(struct uvc_device *dev,
@@ -935,34 +939,34 @@
 	return 0;
 }
 
-int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
+int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
 {
 	struct uvc_entity *entity;
 	int ret = 0;
 
 	/* Find the control. */
-	ret = uvc_ctrl_commit_entity(video->dev, video->processing, rollback);
+	ret = uvc_ctrl_commit_entity(chain->dev, chain->processing, rollback);
 	if (ret < 0)
 		goto done;
 
-	list_for_each_entry(entity, &video->iterms, chain) {
-		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
+	list_for_each_entry(entity, &chain->iterms, chain) {
+		ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
 		if (ret < 0)
 			goto done;
 	}
 
-	list_for_each_entry(entity, &video->extensions, chain) {
-		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
+	list_for_each_entry(entity, &chain->extensions, chain) {
+		ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
 		if (ret < 0)
 			goto done;
 	}
 
 done:
-	mutex_unlock(&video->ctrl_mutex);
+	mutex_unlock(&chain->ctrl_mutex);
 	return ret;
 }
 
-int uvc_ctrl_get(struct uvc_video_device *video,
+int uvc_ctrl_get(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
@@ -971,13 +975,13 @@
 	unsigned int i;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
 	if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_GET_CUR) == 0)
 		return -EINVAL;
 
 	if (!ctrl->loaded) {
-		ret = uvc_query_ctrl(video->dev, GET_CUR, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
+		ret = uvc_query_ctrl(chain->dev, GET_CUR, ctrl->entity->id,
+				chain->dev->intfnum, ctrl->info->selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl->info->size);
 		if (ret < 0)
@@ -1002,7 +1006,7 @@
 	return 0;
 }
 
-int uvc_ctrl_set(struct uvc_video_device *video,
+int uvc_ctrl_set(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
@@ -1010,7 +1014,7 @@
 	s32 value = xctrl->value;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
 	if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_SET_CUR) == 0)
 		return -EINVAL;
 
@@ -1025,8 +1029,8 @@
 			memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				0, ctrl->info->size);
 		} else {
-			ret = uvc_query_ctrl(video->dev, GET_CUR,
-				ctrl->entity->id, video->dev->intfnum,
+			ret = uvc_query_ctrl(chain->dev, GET_CUR,
+				ctrl->entity->id, chain->dev->intfnum,
 				ctrl->info->selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl->info->size);
@@ -1055,7 +1059,7 @@
  * Dynamic controls
  */
 
-int uvc_xu_ctrl_query(struct uvc_video_device *video,
+int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 	struct uvc_xu_control *xctrl, int set)
 {
 	struct uvc_entity *entity;
@@ -1065,7 +1069,7 @@
 	int ret;
 
 	/* Find the extension unit. */
-	list_for_each_entry(entity, &video->extensions, chain) {
+	list_for_each_entry(entity, &chain->extensions, chain) {
 		if (entity->id == xctrl->unit)
 			break;
 	}
@@ -1104,7 +1108,7 @@
 	    (!set && !(ctrl->info->flags & UVC_CONTROL_GET_CUR)))
 		return -EINVAL;
 
-	if (mutex_lock_interruptible(&video->ctrl_mutex))
+	if (mutex_lock_interruptible(&chain->ctrl_mutex))
 		return -ERESTARTSYS;
 
 	memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
@@ -1117,8 +1121,8 @@
 		goto out;
 	}
 
-	ret = uvc_query_ctrl(video->dev, set ? SET_CUR : GET_CUR, xctrl->unit,
-			     video->dev->intfnum, xctrl->selector, data,
+	ret = uvc_query_ctrl(chain->dev, set ? SET_CUR : GET_CUR, xctrl->unit,
+			     chain->dev->intfnum, xctrl->selector, data,
 			     xctrl->size);
 	if (ret < 0)
 		goto out;
@@ -1134,7 +1138,7 @@
 		       uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
 		       xctrl->size);
 
-	mutex_unlock(&video->ctrl_mutex);
+	mutex_unlock(&chain->ctrl_mutex);
 	return ret;
 }
 
diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_driver.c
--- a/linux/drivers/media/video/uvc/uvc_driver.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_driver.c	Thu Jul 02 01:24:47 2009 +0200
@@ -276,8 +276,20 @@
 	return NULL;
 }
 
+static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev, int id)
+{
+	struct uvc_streaming *stream;
+
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->header.bTerminalLink == id)
+			return stream;
+	}
+
+	return NULL;
+}
+
 /* ------------------------------------------------------------------------
- * Descriptors handling
+ * Descriptors parsing
  */
 
 static int uvc_parse_format(struct uvc_device *dev,
@@ -1159,101 +1171,36 @@
 }
 
 /* ------------------------------------------------------------------------
- * USB probe and disconnect
+ * UVC device scan
  */
 
 /*
- * Unregister the video devices.
- */
-static void uvc_unregister_video(struct uvc_device *dev)
-{
-	struct uvc_streaming *streaming;
-
-	list_for_each_entry(streaming, &dev->streams, list) {
-		if (streaming->vdev == NULL)
-			continue;
-
-		if (streaming->vdev->minor == -1)
-			video_device_release(streaming->vdev);
-		else
-			video_unregister_device(streaming->vdev);
-		streaming->vdev = NULL;
-	}
-}
-
-static int uvc_register_video(struct uvc_device *dev,
-		struct uvc_streaming *stream)
-{
-	struct video_device *vdev;
-	struct uvc_entity *term;
-	int ret;
-
-	if (uvc_trace_param & UVC_TRACE_PROBE) {
-		uvc_printk(KERN_INFO, "Found a valid video chain (");
-		list_for_each_entry(term, &dev->video.iterms, chain) {
-			printk("%d", term->id);
-			if (term->chain.next != &dev->video.iterms)
-				printk(",");
-		}
-		printk(" -> %d).\n", dev->video.oterm->id);
-	}
-
-	/* Initialize the streaming interface with default streaming
-	 * parameters.
-	 */
-	ret = uvc_video_init(stream);
-	if (ret < 0) {
-		uvc_printk(KERN_ERR, "Failed to initialize the device "
-			"(%d).\n", ret);
-		return ret;
-	}
-
-	/* Register the device with V4L. */
-	vdev = video_device_alloc();
-	if (vdev == NULL)
-		return -1;
-
-	/* We already hold a reference to dev->udev. The video device will be
-	 * unregistered before the reference is released, so we don't need to
-	 * get another one.
-	 */
-	vdev->parent = &dev->intf->dev;
-	vdev->minor = -1;
-	vdev->fops = &uvc_fops;
-	vdev->release = video_device_release;
-	strlcpy(vdev->name, dev->name, sizeof vdev->name);
-
-	/* Set the driver data before calling video_register_device, otherwise
-	 * uvc_v4l2_open might race us.
-	 */
-	stream->vdev = vdev;
-	video_set_drvdata(vdev, stream);
-
-	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
-		stream->vdev = NULL;
-		video_device_release(vdev);
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
  * Scan the UVC descriptors to locate a chain starting at an Output Terminal
  * and containing the following units:
  *
- * - one Output Terminal (USB Streaming or Display)
+ * - one or more Output Terminals (USB Streaming or Display)
  * - zero or one Processing Unit
- * - zero, one or mode single-input Selector Units
+ * - zero, one or more single-input Selector Units
  * - zero or one multiple-input Selector Units, provided all inputs are
  *   connected to input terminals
  * - zero, one or mode single-input Extension Units
  * - one or more Input Terminals (Camera, External or USB Streaming)
  *
- * A side forward scan is made on each detected entity to check for additional
- * extension units.
+ * The terminal and units must match on of the following structures:
+ *
+ * ITT_*(0) -> +---------+    +---------+    +---------+ -> TT_STREAMING(0)
+ * ...         | SU{0,1} | -> | PU{0,1} | -> | XU{0,n} |    ...
+ * ITT_*(n) -> +---------+    +---------+    +---------+ -> TT_STREAMING(n)
+ *
+ *                 +---------+    +---------+ -> OTT_*(0)
+ * TT_STREAMING -> | PU{0,1} | -> | XU{0,n} |    ...
+ *                 +---------+    +---------+ -> OTT_*(n)
+ *
+ * The Processing Unit and Extension Units can be in any order. Additional
+ * Extension Units connected to the main chain as single-unit branches are
+ * also supported. Single-input Selector Units are ignored.
  */
-static int uvc_scan_chain_entity(struct uvc_video_device *video,
+static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
 {
 	switch (UVC_ENTITY_TYPE(entity)) {
@@ -1267,20 +1214,20 @@
 			return -1;
 		}
 
-		list_add_tail(&entity->chain, &video->extensions);
+		list_add_tail(&entity->chain, &chain->extensions);
 		break;
 
 	case VC_PROCESSING_UNIT:
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- PU %d", entity->id);
 
-		if (video->processing != NULL) {
+		if (chain->processing != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found multiple "
 				"Processing Units in chain.\n");
 			return -1;
 		}
 
-		video->processing = entity;
+		chain->processing = entity;
 		break;
 
 	case VC_SELECTOR_UNIT:
@@ -1291,13 +1238,13 @@
 		if (entity->selector.bNrInPins == 1)
 			break;
 
-		if (video->selector != NULL) {
+		if (chain->selector != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found multiple Selector "
 				"Units in chain.\n");
 			return -1;
 		}
 
-		video->selector = entity;
+		chain->selector = entity;
 		break;
 
 	case ITT_VENDOR_SPECIFIC:
@@ -1306,7 +1253,7 @@
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- IT %d\n", entity->id);
 
-		list_add_tail(&entity->chain, &video->iterms);
+		list_add_tail(&entity->chain, &chain->iterms);
 		break;
 
 	case TT_STREAMING:
@@ -1319,14 +1266,7 @@
 			return -1;
 		}
 
-		if (video->sterm != NULL) {
-			uvc_trace(UVC_TRACE_DESCR, "Found multiple streaming "
-				"entities in chain.\n");
-			return -1;
-		}
-
-		list_add_tail(&entity->chain, &video->iterms);
-		video->sterm = entity;
+		list_add_tail(&entity->chain, &chain->iterms);
 		break;
 
 	default:
@@ -1338,7 +1278,7 @@
 	return 0;
 }
 
-static int uvc_scan_chain_forward(struct uvc_video_device *video,
+static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
 	struct uvc_entity *entity, struct uvc_entity *prev)
 {
 	struct uvc_entity *forward;
@@ -1349,28 +1289,51 @@
 	found = 0;
 
 	while (1) {
-		forward = uvc_entity_by_reference(video->dev, entity->id,
+		forward = uvc_entity_by_reference(chain->dev, entity->id,
 			forward);
 		if (forward == NULL)
 			break;
-
-		if (UVC_ENTITY_TYPE(forward) != VC_EXTENSION_UNIT ||
-		    forward == prev)
+		if (forward == prev)
 			continue;
 
-		if (forward->extension.bNrInPins != 1) {
-			uvc_trace(UVC_TRACE_DESCR, "Extension unit %d has "
-				"more than 1 input pin.\n", entity->id);
-			return -1;
-		}
+		switch (UVC_ENTITY_TYPE(forward)) {
+		case VC_EXTENSION_UNIT:
+			if (forward->extension.bNrInPins != 1) {
+				uvc_trace(UVC_TRACE_DESCR, "Extension unit %d "
+					  "has more than 1 input pin.\n",
+					  entity->id);
+				return -EINVAL;
+			}
 
-		list_add_tail(&forward->chain, &video->extensions);
-		if (uvc_trace_param & UVC_TRACE_PROBE) {
-			if (!found)
-				printk(" (-> XU");
+			list_add_tail(&forward->chain, &chain->extensions);
+			if (uvc_trace_param & UVC_TRACE_PROBE) {
+				if (!found)
+					printk(" (->");
 
-			printk(" %d", forward->id);
-			found = 1;
+				printk(" XU %d", forward->id);
+				found = 1;
+			}
+			break;
+
+		case OTT_VENDOR_SPECIFIC:
+		case OTT_DISPLAY:
+		case OTT_MEDIA_TRANSPORT_OUTPUT:
+		case TT_STREAMING:
+			if (UVC_ENTITY_IS_ITERM(forward)) {
+				uvc_trace(UVC_TRACE_DESCR, "Unsupported input "
+					"terminal %u.\n", forward->id);
+				return -EINVAL;
+			}
+
+			list_add_tail(&forward->chain, &chain->oterms);
+			if (uvc_trace_param & UVC_TRACE_PROBE) {
+				if (!found)
+					printk(" (->");
+
+				printk(" OT %d", forward->id);
+				found = 1;
+			}
+			break;
 		}
 	}
 	if (found)
@@ -1379,7 +1342,7 @@
 	return 0;
 }
 
-static int uvc_scan_chain_backward(struct uvc_video_device *video,
+static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
 {
 	struct uvc_entity *term;
@@ -1404,10 +1367,10 @@
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- IT");
 
-		video->selector = entity;
+		chain->selector = entity;
 		for (i = 0; i < entity->selector.bNrInPins; ++i) {
 			id = entity->selector.baSourceID[i];
-			term = uvc_entity_by_id(video->dev, id);
+			term = uvc_entity_by_id(chain->dev, id);
 			if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
 				uvc_trace(UVC_TRACE_DESCR, "Selector unit %d "
 					"input %d isn't connected to an "
@@ -1418,8 +1381,8 @@
 			if (uvc_trace_param & UVC_TRACE_PROBE)
 				printk(" %d", term->id);
 
-			list_add_tail(&term->chain, &video->iterms);
-			uvc_scan_chain_forward(video, term, entity);
+			list_add_tail(&term->chain, &chain->iterms);
+			uvc_scan_chain_forward(chain, term, entity);
 		}
 
 		if (uvc_trace_param & UVC_TRACE_PROBE)
@@ -1432,108 +1395,264 @@
 	return id;
 }
 
-static int uvc_scan_chain(struct uvc_video_device *video)
+static int uvc_scan_chain(struct uvc_video_chain *chain,
+			  struct uvc_entity *oterm)
 {
 	struct uvc_entity *entity, *prev;
 	int id;
 
-	entity = video->oterm;
+	entity = oterm;
+	list_add_tail(&entity->chain, &chain->oterms);
 	uvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain: OT %d", entity->id);
 
-	if (UVC_ENTITY_TYPE(entity) == TT_STREAMING)
-		video->sterm = entity;
-
 	id = entity->output.bSourceID;
 	while (id != 0) {
 		prev = entity;
-		entity = uvc_entity_by_id(video->dev, id);
+		entity = uvc_entity_by_id(chain->dev, id);
 		if (entity == NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
 				"unknown entity %d.\n", id);
-			return -1;
+			return -EINVAL;
+		}
+
+		if (entity->chain.next || entity->chain.prev) {
+			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
+				"entity %d already in chain.\n", id);
+			return -EINVAL;
 		}
 
 		/* Process entity */
-		if (uvc_scan_chain_entity(video, entity) < 0)
-			return -1;
+		if (uvc_scan_chain_entity(chain, entity) < 0)
+			return -EINVAL;
 
 		/* Forward scan */
-		if (uvc_scan_chain_forward(video, entity, prev) < 0)
-			return -1;
+		if (uvc_scan_chain_forward(chain, entity, prev) < 0)
+			return -EINVAL;
 
 		/* Stop when a terminal is found. */
-		if (!UVC_ENTITY_IS_UNIT(entity))
+		if (UVC_ENTITY_IS_TERM(entity))
 			break;
 
 		/* Backward scan */
-		id = uvc_scan_chain_backward(video, entity);
+		id = uvc_scan_chain_backward(chain, entity);
 		if (id < 0)
 			return id;
 	}
 
-	if (video->sterm == NULL) {
-		uvc_trace(UVC_TRACE_DESCR, "No streaming entity found in "
-			"chain.\n");
+	return 0;
+}
+
+static unsigned int uvc_print_terms(struct list_head *terms, char *buffer)
+{
+	struct uvc_entity *term;
+	unsigned int nterms = 0;
+	char *p = buffer;
+
+	list_for_each_entry(term, terms, chain) {
+		p += sprintf(p, "%u", term->id);
+		if (term->chain.next != terms) {
+			p += sprintf(p, ",");
+			if (++nterms >= 4) {
+				p += sprintf(p, "...");
+				break;
+			}
+		}
+	}
+
+	return p - buffer;
+}
+
+static const char *uvc_print_chain(struct uvc_video_chain *chain)
+{
+	static char buffer[43];
+	char *p = buffer;
+
+	p += uvc_print_terms(&chain->iterms, p);
+	p += sprintf(p, " -> ");
+	uvc_print_terms(&chain->oterms, p);
+
+	return buffer;
+}
+
+/*
+ * Scan the device for video chains and register video devices.
+ *
+ * Chains are scanned starting at their output terminals and walked backwards.
+ */
+static int uvc_scan_device(struct uvc_device *dev)
+{
+	struct uvc_video_chain *chain;
+	struct uvc_entity *term;
+
+	list_for_each_entry(term, &dev->entities, list) {
+		if (!UVC_ENTITY_IS_OTERM(term))
+			continue;
+
+		/* If the terminal is already included in a chain, skip it.
+		 * This can happen for chains that have multiple output
+		 * terminals, where all output terminals beside the first one
+		 * will be inserted in the chain in forward scans.
+		 */
+		if (term->chain.next || term->chain.prev)
+			continue;
+
+		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
+		if (chain == NULL)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&chain->iterms);
+		INIT_LIST_HEAD(&chain->oterms);
+		INIT_LIST_HEAD(&chain->extensions);
+		mutex_init(&chain->ctrl_mutex);
+		chain->dev = dev;
+
+		if (uvc_scan_chain(chain, term) < 0) {
+			kfree(chain);
+			continue;
+		}
+
+		uvc_trace(UVC_TRACE_PROBE, "Found a valid video chain (%s).\n",
+			  uvc_print_chain(chain));
+
+		list_add_tail(&chain->list, &dev->chains);
+	}
+
+	if (list_empty(&dev->chains)) {
+		uvc_printk(KERN_INFO, "No valid video chain found.\n");
 		return -1;
 	}
 
 	return 0;
 }
 
+/* ------------------------------------------------------------------------
+ * Video device registration and unregistration
+ */
+
 /*
- * Scan the device for video chains and register video devices.
- *
- * The driver currently supports a single video device per control interface
- * only. The terminal and units must match the following structure:
- *
- * ITT_* -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> TT_STREAMING
- * TT_STREAMING -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> OTT_*
- *
- * The Extension Units, if present, must have a single input pin. The
- * Processing Unit and Extension Units can be in any order. Additional
- * Extension Units connected to the main chain as single-unit branches are
- * also supported.
+ * Unregister the video devices.
  */
-static int uvc_scan_device(struct uvc_device *dev)
+static void uvc_unregister_video(struct uvc_device *dev)
 {
-	struct uvc_entity *term;
-	int found = 0;
+	struct uvc_streaming *stream;
 
-	/* Check if the control interface matches the structure we expect. */
-	list_for_each_entry(term, &dev->entities, list) {
-		struct uvc_streaming *stream;
-
-		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->vdev == NULL)
 			continue;
 
-		memset(&dev->video, 0, sizeof dev->video);
-		mutex_init(&dev->video.ctrl_mutex);
-		INIT_LIST_HEAD(&dev->video.iterms);
-		INIT_LIST_HEAD(&dev->video.extensions);
-		dev->video.oterm = term;
-		dev->video.dev = dev;
-		if (uvc_scan_chain(&dev->video) < 0)
-			continue;
+		if (stream->vdev->minor == -1)
+			video_device_release(stream->vdev);
+		else
+			video_unregister_device(stream->vdev);
+		stream->vdev = NULL;
+	}
+}
 
-		list_for_each_entry(stream, &dev->streams, list) {
-			if (stream->header.bTerminalLink ==
-			    dev->video.sterm->id) {
-				uvc_register_video(dev, stream);
-				found = 1;
-				break;
-			}
-		}
+static int uvc_register_video(struct uvc_device *dev,
+		struct uvc_streaming *stream)
+{
+	struct video_device *vdev;
+	int ret;
+
+	/* Initialize the streaming interface with default streaming
+	 * parameters.
+	 */
+	ret = uvc_video_init(stream);
+	if (ret < 0) {
+		uvc_printk(KERN_ERR, "Failed to initialize the device "
+			"(%d).\n", ret);
+		return ret;
 	}
 
-	if (!found) {
-		uvc_printk(KERN_INFO, "No valid video chain found.\n");
-		return -1;
+	/* Register the device with V4L. */
+	vdev = video_device_alloc();
+	if (vdev == NULL) {
+		uvc_printk(KERN_ERR, "Failed to allocate video device (%d).\n",
+			   ret);
+		return -ENOMEM;
+	}
+
+	/* We already hold a reference to dev->udev. The video device will be
+	 * unregistered before the reference is released, so we don't need to
+	 * get another one.
+	 */
+	vdev->parent = &dev->intf->dev;
+	vdev->minor = -1;
+	vdev->fops = &uvc_fops;
+	vdev->release = video_device_release;
+	strlcpy(vdev->name, dev->name, sizeof vdev->name);
+
+	/* Set the driver data before calling video_register_device, otherwise
+	 * uvc_v4l2_open might race us.
+	 */
+	stream->vdev = vdev;
+	video_set_drvdata(vdev, stream);
+
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret < 0) {
+		uvc_printk(KERN_ERR, "Failed to register video device (%d).\n",
+			   ret);
+		stream->vdev = NULL;
+		video_device_release(vdev);
+		return ret;
 	}
 
 	return 0;
 }
 
 /*
+ * Register all video devices in all chains.
+ */
+static int uvc_register_terms(struct uvc_device *dev,
+	struct uvc_video_chain *chain, struct list_head *terms)
+{
+	struct uvc_streaming *stream;
+	struct uvc_entity *term;
+	int ret;
+
+	list_for_each_entry(term, terms, chain) {
+		if (UVC_ENTITY_TYPE(term) != TT_STREAMING)
+			continue;
+
+		stream = uvc_stream_by_id(dev, term->id);
+		if (stream == NULL) {
+			uvc_printk(KERN_INFO, "No streaming interface found "
+				   "for terminal %u.", term->id);
+			continue;
+		}
+
+		stream->chain = chain;
+		ret = uvc_register_video(dev, stream);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int uvc_register_chains(struct uvc_device *dev)
+{
+	struct uvc_video_chain *chain;
+	int ret;
+
+	list_for_each_entry(chain, &dev->chains, list) {
+		ret = uvc_register_terms(dev, chain, &chain->iterms);
+		if (ret < 0)
+			return ret;
+
+		ret = uvc_register_terms(dev, chain, &chain->oterms);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------
+ * USB probe, disconnect, suspend and resume
+ */
+
+/*
  * Delete the UVC device.
  *
  * Called by the kernel when the last reference to the uvc_device structure
@@ -1554,7 +1673,7 @@
 	struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
 	struct list_head *p, *n;
 
-	/* Unregister the video device. */
+	/* Unregister the video devices. */
 	uvc_unregister_video(dev);
 	usb_put_intf(dev->intf);
 	usb_put_dev(dev->udev);
@@ -1562,6 +1681,12 @@
 	uvc_status_cleanup(dev);
 	uvc_ctrl_cleanup_device(dev);
 
+	list_for_each_safe(p, n, &dev->chains) {
+		struct uvc_video_chain *chain;
+		chain = list_entry(p, struct uvc_video_chain, list);
+		kfree(chain);
+	}
+
 	list_for_each_safe(p, n, &dev->entities) {
 		struct uvc_entity *entity;
 		entity = list_entry(p, struct uvc_entity, list);
@@ -1602,6 +1727,7 @@
 		return -ENOMEM;
 
 	INIT_LIST_HEAD(&dev->entities);
+	INIT_LIST_HEAD(&dev->chains);
 	INIT_LIST_HEAD(&dev->streams);
 	kref_init(&dev->kref);
 	atomic_set(&dev->users, 0);
@@ -1643,10 +1769,14 @@
 	if (uvc_ctrl_init_device(dev) < 0)
 		goto error;
 
-	/* Scan the device for video chains and register video devices. */
+	/* Scan the device for video chains. */
 	if (uvc_scan_device(dev) < 0)
 		goto error;
 
+	/* Register video devices. */
+	if (uvc_register_chains(dev) < 0)
+		goto error;
+
 	/* Save our data pointer in the interface data. */
 	usb_set_intfdata(intf, dev);
 
diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_v4l2.c
--- a/linux/drivers/media/video/uvc/uvc_v4l2.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_v4l2.c	Thu Jul 02 01:24:47 2009 +0200
@@ -40,7 +40,7 @@
  * table for the controls that can be mapped directly, and handle the others
  * manually.
  */
-static int uvc_v4l2_query_menu(struct uvc_video_device *video,
+static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
 	struct v4l2_querymenu *query_menu)
 {
 	struct uvc_menu_info *menu_info;
@@ -49,7 +49,7 @@
 	u32 index = query_menu->index;
 	u32 id = query_menu->id;
 
-	ctrl = uvc_find_control(video, query_menu->id, &mapping);
+	ctrl = uvc_find_control(chain, query_menu->id, &mapping);
 	if (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU)
 		return -EINVAL;
 
@@ -493,7 +493,7 @@
 		}
 	}
 
-	handle->video = &stream->dev->video;
+	handle->chain = stream->chain;
 	handle->stream = stream;
 	handle->state = UVC_HANDLE_PASSIVE;
 	file->private_data = handle;
@@ -542,7 +542,7 @@
 {
 	struct video_device *vdev = video_devdata(file);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
-	struct uvc_video_device *video = handle->video;
+	struct uvc_video_chain *chain = handle->chain;
 	struct uvc_streaming *stream = handle->stream;
 	long ret = 0;
 
@@ -569,7 +569,7 @@
 
 	/* Get, Set & Query control */
 	case VIDIOC_QUERYCTRL:
-		return uvc_query_v4l2_ctrl(video, arg);
+		return uvc_query_v4l2_ctrl(chain, arg);
 
 	case VIDIOC_G_CTRL:
 	{
@@ -579,9 +579,9 @@
 		memset(&xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl->id;
 
-		uvc_ctrl_begin(video);
-		ret = uvc_ctrl_get(video, &xctrl);
-		uvc_ctrl_rollback(video);
+		uvc_ctrl_begin(chain);
+		ret = uvc_ctrl_get(chain, &xctrl);
+		uvc_ctrl_rollback(chain);
 		if (ret >= 0)
 			ctrl->value = xctrl.value;
 		break;
@@ -596,18 +596,18 @@
 		xctrl.id = ctrl->id;
 		xctrl.value = ctrl->value;
 
-		uvc_ctrl_begin(video);
-		ret = uvc_ctrl_set(video, &xctrl);
+		uvc_ctrl_begin(chain);
+		ret = uvc_ctrl_set(chain, &xctrl);
 		if (ret < 0) {
-			uvc_ctrl_rollback(video);
+			uvc_ctrl_rollback(chain);
 			return ret;
 		}
-		ret = uvc_ctrl_commit(video);
+		ret = uvc_ctrl_commit(chain);
 		break;
 	}
 
 	case VIDIOC_QUERYMENU:
-		return uvc_v4l2_query_menu(video, arg);
+		return uvc_v4l2_query_menu(chain, arg);
 
 	case VIDIOC_G_EXT_CTRLS:
 	{
@@ -615,17 +615,17 @@
 		struct v4l2_ext_control *ctrl = ctrls->controls;
 		unsigned int i;
 
-		uvc_ctrl_begin(video);
+		uvc_ctrl_begin(chain);
 		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
-			ret = uvc_ctrl_get(video, ctrl);
+			ret = uvc_ctrl_get(chain, ctrl);
 			if (ret < 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls->error_idx = i;
 				return ret;
 			}
 		}
 		ctrls->error_idx = 0;
-		ret = uvc_ctrl_rollback(video);
+		ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
@@ -636,14 +636,14 @@
 		struct v4l2_ext_control *ctrl = ctrls->controls;
 		unsigned int i;
 
-		ret = uvc_ctrl_begin(video);
+		ret = uvc_ctrl_begin(chain);
 		if (ret < 0)
 			return ret;
 
 		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
-			ret = uvc_ctrl_set(video, ctrl);
+			ret = uvc_ctrl_set(chain, ctrl);
 			if (ret < 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls->error_idx = i;
 				return ret;
 			}
@@ -652,31 +652,31 @@
 		ctrls->error_idx = 0;
 
 		if (cmd == VIDIOC_S_EXT_CTRLS)
-			ret = uvc_ctrl_commit(video);
+			ret = uvc_ctrl_commit(chain);
 		else
-			ret = uvc_ctrl_rollback(video);
+			ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
 	/* Get, Set & Enum input */
 	case VIDIOC_ENUMINPUT:
 	{
-		const struct uvc_entity *selector = video->selector;
+		const struct uvc_entity *selector = chain->selector;
 		struct v4l2_input *input = arg;
 		struct uvc_entity *iterm = NULL;
 		u32 index = input->index;
 		int pin = 0;
 
 		if (selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (index != 0)
 				return -EINVAL;
-			iterm = list_first_entry(&video->iterms,
+			iterm = list_first_entry(&chain->iterms,
 					struct uvc_entity, chain);
 			pin = iterm->id;
 		} else if (pin < selector->selector.bNrInPins) {
 			pin = selector->selector.baSourceID[index];
-			list_for_each_entry(iterm, video->iterms.next, chain) {
+			list_for_each_entry(iterm, chain->iterms.next, chain) {
 				if (iterm->id == pin)
 					break;
 			}
@@ -697,14 +697,14 @@
 	{
 		u8 input;
 
-		if (video->selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain->selector == NULL ||
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			*(int *)arg = 0;
 			break;
 		}
 
-		ret = uvc_query_ctrl(video->dev, GET_CUR, video->selector->id,
-			video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
+		ret = uvc_query_ctrl(chain->dev, GET_CUR, chain->selector->id,
+			chain->dev->intfnum, SU_INPUT_SELECT_CONTROL,
 			&input, 1);
 		if (ret < 0)
 			return ret;
@@ -720,18 +720,18 @@
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		if (video->selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain->selector == NULL ||
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (input != 1)
 				return -EINVAL;
 			break;
 		}
 
-		if (input == 0 || input > video->selector->selector.bNrInPins)
+		if (input == 0 || input > chain->selector->selector.bNrInPins)
 			return -EINVAL;
 
-		return uvc_query_ctrl(video->dev, SET_CUR, video->selector->id,
-			video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
+		return uvc_query_ctrl(chain->dev, SET_CUR, chain->selector->id,
+			chain->dev->intfnum, SU_INPUT_SELECT_CONTROL,
 			&input, 1);
 	}
 
@@ -1064,10 +1064,10 @@
 	}
 
 	case UVCIOC_CTRL_GET:
-		return uvc_xu_ctrl_query(video, arg, 0);
+		return uvc_xu_ctrl_query(chain, arg, 0);
 
 	case UVCIOC_CTRL_SET:
-		return uvc_xu_ctrl_query(video, arg, 1);
+		return uvc_xu_ctrl_query(chain, arg, 1);
 
 	default:
 		if ((ret = v4l_compat_translate_ioctl(file, cmd, arg,
diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvcvideo.h
--- a/linux/drivers/media/video/uvc/uvcvideo.h	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvcvideo.h	Thu Jul 02 01:24:47 2009 +0200
@@ -224,9 +224,11 @@
 #define UVC_ENTITY_IS_UNIT(entity)	(((entity)->type & 0xff00) == 0)
 #define UVC_ENTITY_IS_TERM(entity)	(((entity)->type & 0xff00) != 0)
 #define UVC_ENTITY_IS_ITERM(entity) \
-	(((entity)->type & 0x8000) == UVC_TERM_INPUT)
+	(UVC_ENTITY_IS_TERM(entity) && \
+	((entity)->type & 0x8000) == UVC_TERM_INPUT)
 #define UVC_ENTITY_IS_OTERM(entity) \
-	(((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
+	(UVC_ENTITY_IS_TERM(entity) && \
+	((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
 
 #define UVC_STATUS_TYPE_CONTROL		1
 #define UVC_STATUS_TYPE_STREAMING	2
@@ -560,10 +562,24 @@
 	struct list_head irqqueue;
 };
 
+struct uvc_video_chain {
+	struct uvc_device *dev;
+	struct list_head list;
+
+	struct list_head iterms;		/* Input terminals */
+	struct list_head oterms;		/* Output terminals */
+	struct uvc_entity *processing;		/* Processing unit */
+	struct uvc_entity *selector;		/* Selector unit */
+	struct list_head extensions;		/* Extension units */
+
+	struct mutex ctrl_mutex;
+};
+
 struct uvc_streaming {
 	struct list_head list;
 	struct uvc_device *dev;
 	struct video_device *vdev;
+	struct uvc_video_chain *chain;
 	atomic_t active;
 
 	struct usb_interface *intf;
@@ -604,18 +620,6 @@
 	__u8 last_fid;
 };
 
-struct uvc_video_device {
-	struct uvc_device *dev;
-
-	struct list_head iterms;		/* Input terminals */
-	struct uvc_entity *oterm;		/* Output terminal */
-	struct uvc_entity *sterm;		/* USB streaming terminal */
-	struct uvc_entity *processing;
-	struct uvc_entity *selector;
-	struct list_head extensions;
-	struct mutex ctrl_mutex;
-};
-
 enum uvc_device_state {
 	UVC_DEV_DISCONNECTED = 1,
 };
@@ -638,8 +642,7 @@
 	__u32 clock_frequency;
 
 	struct list_head entities;
-
-	struct uvc_video_device video;
+	struct list_head chains;
 
 	/* Video Streaming interfaces */
 	struct list_head streams;
@@ -658,7 +661,7 @@
 };
 
 struct uvc_fh {
-	struct uvc_video_device *video;
+	struct uvc_video_chain *chain;
 	struct uvc_streaming *stream;
 	enum uvc_handle_state state;
 };
@@ -776,9 +779,9 @@
 extern int uvc_status_resume(struct uvc_device *dev);
 
 /* Controls */
-extern struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+extern struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 		__u32 v4l2_id, struct uvc_control_mapping **mapping);
-extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 		struct v4l2_queryctrl *v4l2_ctrl);
 
 extern int uvc_ctrl_add_info(struct uvc_control_info *info);
@@ -788,23 +791,23 @@
 extern int uvc_ctrl_resume_device(struct uvc_device *dev);
 extern void uvc_ctrl_init(void);
 
-extern int uvc_ctrl_begin(struct uvc_video_device *video);
-extern int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback);
-static inline int uvc_ctrl_commit(struct uvc_video_device *video)
+extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
+extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback);
+static inline int uvc_ctrl_commit(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 0);
+	return __uvc_ctrl_commit(chain, 0);
 }
-static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
+static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 1);
+	return __uvc_ctrl_commit(chain, 1);
 }
 
-extern int uvc_ctrl_get(struct uvc_video_device *video,
+extern int uvc_ctrl_get(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
-extern int uvc_ctrl_set(struct uvc_video_device *video,
+extern int uvc_ctrl_set(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
 
-extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
+extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 		struct uvc_xu_control *ctrl, int set);
 
 /* Utility functions */



From laurent.pinchart at skynet.be  Thu Jul  2 01:33:50 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 01:33:50 +0200
Subject: [Linux-uvc-devel] Multiple streaming interface and MPEG2-TS
	support?
In-Reply-To: <779226550906260126x644f6e28lb222e5e1fc169196@mail.gmail.com>
References: <E54E921FAAA9494485999DFF27C90C95@vivek>
	<200906252156.31126.laurent.pinchart@skynet.be>
	<779226550906260126x644f6e28lb222e5e1fc169196@mail.gmail.com>
Message-ID: <200907020133.50926.laurent.pinchart@skynet.be>

Hi Vivek,

On Friday 26 June 2009 10:26:07 Vivek Bardia wrote:
> On Fri, Jun 26, 2009 at 1:26 AM, Laurent Pinchart wrote
> > On Monday 22 June 2009 14:23:21 Vivek Bardia wrote:
> > > Hello Laurent,
> > >
> > > With respect to the mail chain below,
> > > Would you be able to help me with regards to Multiple streaming
> > > interfaces.
> > >
> > > Firstly how much effort could be required to bring up the UVC driver to
> > > support multiple streaming interfaces and MPEG2-TS support ? In case it
> > > is simple and already available, will you be able to provide that patch
> > > so that I am able to test it with the hardware and get back about the
> > > same ?
> >
> > Multiple streaming interfaces and MPEG2-TS are different requirements.
> > Supporting multiple interfaces will require restructuring a good deal of
> > the driver. I started working on that a week or two ago but had to stop
> > for a moment (if you can send me a few hours of free time by e-mail I'll
> > appreciate that). I should have some time this weekend or early next week
> > to prepare a patch.
>
> Although I cannot send you free time by email, but can help you in
> this regard in case you need help. I do not want to add more overhead
> and confusion in case you are already working on it.
>
> > I haven't really looked into what needs to be changed for MPEG2-TS
> > support. I don't expect it to be very difficult. I'll probably work on
> > that over the weekend.
>
> Just one more thing, With regards to MPEG2-TS its just adding the
> parsing support, if I am not wrong?

Some changes might be required on the video streaming code as well. Streaming 
parameters negotiation will have to be modified too to support MPEG2-specific. 
parameters.

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Thu Jul  2 01:31:01 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 01:31:01 +0200
Subject: [Linux-uvc-devel] [PATCH 1/2] uvcvideo: Restructure the driver to
	support multiple simultaneous streams.
In-Reply-To: <200907020130.10001.laurent.pinchart@skynet.be>
References: <200907020130.10001.laurent.pinchart@skynet.be>
Message-ID: <200907020131.01946.laurent.pinchart@skynet.be>

As a first step towards multiple streaming interfaces support, reorganize the
driver's data structures to cleanly separate video control and video streaming
data.

Priority: normal

Signed-off-by: Laurent Pinchart <laurent.pinchart at skynet.be>

diff -r 50059a68c503 -r 88ef3b9f5071 linux/drivers/media/video/uvc/uvc_driver.c
--- a/linux/drivers/media/video/uvc/uvc_driver.c	Thu Jun 04 14:37:43 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_driver.c	Sun Jun 28 13:37:50 2009 +0200
@@ -551,6 +551,7 @@
 	}
 
 	mutex_init(&streaming->mutex);
+	streaming->dev = dev;
 	streaming->intf = usb_get_intf(intf);
 	streaming->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;
 
@@ -751,7 +752,7 @@
 			streaming->maxpsize = psize;
 	}
 
-	list_add_tail(&streaming->list, &dev->streaming);
+	list_add_tail(&streaming->list, &dev->streams);
 	return 0;
 
 error:
@@ -1166,15 +1167,77 @@
  */
 static void uvc_unregister_video(struct uvc_device *dev)
 {
-	if (dev->video.vdev) {
-		if (dev->video.vdev->minor == -1)
-			video_device_release(dev->video.vdev);
+	struct uvc_streaming *streaming;
+
+	list_for_each_entry(streaming, &dev->streams, list) {
+		if (streaming->vdev == NULL)
+			continue;
+
+		if (streaming->vdev->minor == -1)
+			video_device_release(streaming->vdev);
 		else
-			video_unregister_device(dev->video.vdev);
-		dev->video.vdev = NULL;
+			video_unregister_device(streaming->vdev);
+		streaming->vdev = NULL;
 	}
 }
 
+static int uvc_register_video(struct uvc_device *dev,
+		struct uvc_streaming *stream)
+{
+	struct video_device *vdev;
+	struct uvc_entity *term;
+	int ret;
+
+	if (uvc_trace_param & UVC_TRACE_PROBE) {
+		uvc_printk(KERN_INFO, "Found a valid video chain (");
+		list_for_each_entry(term, &dev->video.iterms, chain) {
+			printk("%d", term->id);
+			if (term->chain.next != &dev->video.iterms)
+				printk(",");
+		}
+		printk(" -> %d).\n", dev->video.oterm->id);
+	}
+
+	/* Initialize the streaming interface with default streaming
+	 * parameters.
+	 */
+	ret = uvc_video_init(stream);
+	if (ret < 0) {
+		uvc_printk(KERN_ERR, "Failed to initialize the device "
+			"(%d).\n", ret);
+		return ret;
+	}
+
+	/* Register the device with V4L. */
+	vdev = video_device_alloc();
+	if (vdev == NULL)
+		return -1;
+
+	/* We already hold a reference to dev->udev. The video device will be
+	 * unregistered before the reference is released, so we don't need to
+	 * get another one.
+	 */
+	vdev->parent = &dev->intf->dev;
+	vdev->minor = -1;
+	vdev->fops = &uvc_fops;
+	vdev->release = video_device_release;
+	strlcpy(vdev->name, dev->name, sizeof vdev->name);
+
+	/* Set the driver data before calling video_register_device, otherwise
+	 * uvc_v4l2_open might race us.
+	 */
+	stream->vdev = vdev;
+	video_set_drvdata(vdev, stream);
+
+	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
+		stream->vdev = NULL;
+		video_device_release(vdev);
+		return -1;
+	}
+
+	return 0;
+}
+
 /*
  * Scan the UVC descriptors to locate a chain starting at an Output Terminal
  * and containing the following units:
@@ -1418,7 +1481,7 @@
 }
 
 /*
- * Register the video devices.
+ * Scan the device for video chains and register video devices.
  *
  * The driver currently supports a single video device per control interface
  * only. The terminal and units must match the following structure:
@@ -1431,15 +1494,14 @@
  * Extension Units connected to the main chain as single-unit branches are
  * also supported.
  */
-static int uvc_register_video(struct uvc_device *dev)
+static int uvc_scan_device(struct uvc_device *dev)
 {
-	struct video_device *vdev;
 	struct uvc_entity *term;
-	int found = 0, ret;
+	int found = 0;
 
 	/* Check if the control interface matches the structure we expect. */
 	list_for_each_entry(term, &dev->entities, list) {
-		struct uvc_streaming *streaming;
+		struct uvc_streaming *stream;
 
 		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
 			continue;
@@ -1453,17 +1515,14 @@
 		if (uvc_scan_chain(&dev->video) < 0)
 			continue;
 
-		list_for_each_entry(streaming, &dev->streaming, list) {
-			if (streaming->header.bTerminalLink ==
+		list_for_each_entry(stream, &dev->streams, list) {
+			if (stream->header.bTerminalLink ==
 			    dev->video.sterm->id) {
-				dev->video.streaming = streaming;
+				uvc_register_video(dev, stream);
 				found = 1;
 				break;
 			}
 		}
-
-		if (found)
-			break;
 	}
 
 	if (!found) {
@@ -1471,55 +1530,6 @@
 		return -1;
 	}
 
-	if (uvc_trace_param & UVC_TRACE_PROBE) {
-		uvc_printk(KERN_INFO, "Found a valid video chain (");
-		list_for_each_entry(term, &dev->video.iterms, chain) {
-			printk("%d", term->id);
-			if (term->chain.next != &dev->video.iterms)
-				printk(",");
-		}
-		printk(" -> %d).\n", dev->video.oterm->id);
-	}
-
-	/* Initialize the video buffers queue. */
-	uvc_queue_init(&dev->video.queue, dev->video.streaming->type);
-
-	/* Initialize the streaming interface with default streaming
-	 * parameters.
-	 */
-	if ((ret = uvc_video_init(&dev->video)) < 0) {
-		uvc_printk(KERN_ERR, "Failed to initialize the device "
-			"(%d).\n", ret);
-		return ret;
-	}
-
-	/* Register the device with V4L. */
-	vdev = video_device_alloc();
-	if (vdev == NULL)
-		return -1;
-
-	/* We already hold a reference to dev->udev. The video device will be
-	 * unregistered before the reference is released, so we don't need to
-	 * get another one.
-	 */
-	vdev->parent = &dev->intf->dev;
-	vdev->minor = -1;
-	vdev->fops = &uvc_fops;
-	vdev->release = video_device_release;
-	strlcpy(vdev->name, dev->name, sizeof vdev->name);
-
-	/* Set the driver data before calling video_register_device, otherwise
-	 * uvc_v4l2_open might race us.
-	 */
-	dev->video.vdev = vdev;
-	video_set_drvdata(vdev, &dev->video);
-
-	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
-		dev->video.vdev = NULL;
-		video_device_release(vdev);
-		return -1;
-	}
-
 	return 0;
 }
 
@@ -1558,7 +1568,7 @@
 		kfree(entity);
 	}
 
-	list_for_each_safe(p, n, &dev->streaming) {
+	list_for_each_safe(p, n, &dev->streams) {
 		struct uvc_streaming *streaming;
 		streaming = list_entry(p, struct uvc_streaming, list);
 		usb_driver_release_interface(&uvc_driver.driver,
@@ -1592,7 +1602,7 @@
 		return -ENOMEM;
 
 	INIT_LIST_HEAD(&dev->entities);
-	INIT_LIST_HEAD(&dev->streaming);
+	INIT_LIST_HEAD(&dev->streams);
 	kref_init(&dev->kref);
 	atomic_set(&dev->users, 0);
 
@@ -1633,8 +1643,8 @@
 	if (uvc_ctrl_init_device(dev) < 0)
 		goto error;
 
-	/* Register the video devices. */
-	if (uvc_register_video(dev) < 0)
+	/* Scan the device for video chains and register video devices. */
+	if (uvc_scan_device(dev) < 0)
 		goto error;
 
 	/* Save our data pointer in the interface data. */
@@ -1687,6 +1697,7 @@
 static int uvc_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct uvc_device *dev = usb_get_intfdata(intf);
+	struct uvc_streaming *stream;
 
 	uvc_trace(UVC_TRACE_SUSPEND, "Suspending interface %u\n",
 		intf->cur_altsetting->desc.bInterfaceNumber);
@@ -1695,18 +1706,20 @@
 	if (intf->cur_altsetting->desc.bInterfaceSubClass == SC_VIDEOCONTROL)
 		return uvc_status_suspend(dev);
 
-	if (dev->video.streaming->intf != intf) {
-		uvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB "
-				"interface mismatch.\n");
-		return -EINVAL;
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->intf == intf)
+			return uvc_video_suspend(stream);
 	}
 
-	return uvc_video_suspend(&dev->video);
+	uvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB interface "
+			"mismatch.\n");
+	return -EINVAL;
 }
 
 static int __uvc_resume(struct usb_interface *intf, int reset)
 {
 	struct uvc_device *dev = usb_get_intfdata(intf);
+	struct uvc_streaming *stream;
 
 	uvc_trace(UVC_TRACE_SUSPEND, "Resuming interface %u\n",
 		intf->cur_altsetting->desc.bInterfaceNumber);
@@ -1722,13 +1735,14 @@
 		return uvc_status_resume(dev);
 	}
 
-	if (dev->video.streaming->intf != intf) {
-		uvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB "
-				"interface mismatch.\n");
-		return -EINVAL;
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->intf == intf)
+			return uvc_video_resume(stream);
 	}
 
-	return uvc_video_resume(&dev->video);
+	uvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB interface "
+			"mismatch.\n");
+	return -EINVAL;
 }
 
 static int uvc_resume(struct usb_interface *intf)
diff -r 50059a68c503 -r 88ef3b9f5071 linux/drivers/media/video/uvc/uvc_isight.c
--- a/linux/drivers/media/video/uvc/uvc_isight.c	Thu Jun 04 14:37:43 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_isight.c	Sun Jun 28 13:37:50 2009 +0200
@@ -99,7 +99,7 @@
 	return 0;
 }
 
-void uvc_video_decode_isight(struct urb *urb, struct uvc_video_device *video,
+void uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,
 		struct uvc_buffer *buf)
 {
 	int ret, i;
@@ -120,7 +120,7 @@
 		 * processes the data of the first payload of the new frame.
 		 */
 		do {
-			ret = isight_decode(&video->queue, buf,
+			ret = isight_decode(&stream->queue, buf,
 					urb->transfer_buffer +
 					urb->iso_frame_desc[i].offset,
 					urb->iso_frame_desc[i].actual_length);
@@ -130,7 +130,8 @@
 
 			if (buf->state == UVC_BUF_STATE_DONE ||
 			    buf->state == UVC_BUF_STATE_ERROR)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							buf);
 		} while (ret == -EAGAIN);
 	}
 }
diff -r 50059a68c503 -r 88ef3b9f5071 linux/drivers/media/video/uvc/uvc_v4l2.c
--- a/linux/drivers/media/video/uvc/uvc_v4l2.c	Thu Jun 04 14:37:43 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_v4l2.c	Sun Jun 28 13:37:50 2009 +0200
@@ -103,7 +103,7 @@
 	return interval;
 }
 
-static int uvc_v4l2_try_format(struct uvc_video_device *video,
+static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt, struct uvc_streaming_control *probe,
 	struct uvc_format **uvc_format, struct uvc_frame **uvc_frame)
 {
@@ -116,7 +116,7 @@
 	int ret = 0;
 	__u8 *fcc;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
 	fcc = (__u8 *)&fmt->fmt.pix.pixelformat;
@@ -126,8 +126,8 @@
 			fmt->fmt.pix.width, fmt->fmt.pix.height);
 
 	/* Check if the hardware supports the requested format. */
-	for (i = 0; i < video->streaming->nformats; ++i) {
-		format = &video->streaming->format[i];
+	for (i = 0; i < stream->nformats; ++i) {
+		format = &stream->format[i];
 		if (format->fcc == fmt->fmt.pix.pixelformat)
 			break;
 	}
@@ -192,12 +192,13 @@
 	 * developers test their webcams with the Linux driver as well as with
 	 * the Windows driver).
 	 */
-	if (video->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)
+	if (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)
 		probe->dwMaxVideoFrameSize =
-			video->streaming->ctrl.dwMaxVideoFrameSize;
+			stream->ctrl.dwMaxVideoFrameSize;
 
 	/* Probe the device. */
-	if ((ret = uvc_probe_video(video, probe)) < 0)
+	ret = uvc_probe_video(stream, probe);
+	if (ret < 0)
 		goto done;
 
 	fmt->fmt.pix.width = frame->wWidth;
@@ -217,13 +218,13 @@
 	return ret;
 }
 
-static int uvc_v4l2_get_format(struct uvc_video_device *video,
+static int uvc_v4l2_get_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt)
 {
-	struct uvc_format *format = video->streaming->cur_format;
-	struct uvc_frame *frame = video->streaming->cur_frame;
+	struct uvc_format *format = stream->cur_format;
+	struct uvc_frame *frame = stream->cur_frame;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
 	if (format == NULL || frame == NULL)
@@ -234,14 +235,14 @@
 	fmt->fmt.pix.height = frame->wHeight;
 	fmt->fmt.pix.field = V4L2_FIELD_NONE;
 	fmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;
-	fmt->fmt.pix.sizeimage = video->streaming->ctrl.dwMaxVideoFrameSize;
+	fmt->fmt.pix.sizeimage = stream->ctrl.dwMaxVideoFrameSize;
 	fmt->fmt.pix.colorspace = format->colorspace;
 	fmt->fmt.pix.priv = 0;
 
 	return 0;
 }
 
-static int uvc_v4l2_set_format(struct uvc_video_device *video,
+static int uvc_v4l2_set_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt)
 {
 	struct uvc_streaming_control probe;
@@ -249,39 +250,39 @@
 	struct uvc_frame *frame;
 	int ret;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
-	if (uvc_queue_allocated(&video->queue))
+	if (uvc_queue_allocated(&stream->queue))
 		return -EBUSY;
 
-	ret = uvc_v4l2_try_format(video, fmt, &probe, &format, &frame);
+	ret = uvc_v4l2_try_format(stream, fmt, &probe, &format, &frame);
 	if (ret < 0)
 		return ret;
 
-	memcpy(&video->streaming->ctrl, &probe, sizeof probe);
-	video->streaming->cur_format = format;
-	video->streaming->cur_frame = frame;
+	memcpy(&stream->ctrl, &probe, sizeof probe);
+	stream->cur_format = format;
+	stream->cur_frame = frame;
 
 	return 0;
 }
 
-static int uvc_v4l2_get_streamparm(struct uvc_video_device *video,
+static int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,
 		struct v4l2_streamparm *parm)
 {
 	uint32_t numerator, denominator;
 
-	if (parm->type != video->streaming->type)
+	if (parm->type != stream->type)
 		return -EINVAL;
 
-	numerator = video->streaming->ctrl.dwFrameInterval;
+	numerator = stream->ctrl.dwFrameInterval;
 	denominator = 10000000;
 	uvc_simplify_fraction(&numerator, &denominator, 8, 333);
 
 	memset(parm, 0, sizeof *parm);
-	parm->type = video->streaming->type;
+	parm->type = stream->type;
 
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
 		parm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
 		parm->parm.capture.capturemode = 0;
 		parm->parm.capture.timeperframe.numerator = numerator;
@@ -298,19 +299,19 @@
 	return 0;
 }
 
-static int uvc_v4l2_set_streamparm(struct uvc_video_device *video,
+static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 		struct v4l2_streamparm *parm)
 {
-	struct uvc_frame *frame = video->streaming->cur_frame;
+	struct uvc_frame *frame = stream->cur_frame;
 	struct uvc_streaming_control probe;
 	struct v4l2_fract timeperframe;
 	uint32_t interval;
 	int ret;
 
-	if (parm->type != video->streaming->type)
+	if (parm->type != stream->type)
 		return -EINVAL;
 
-	if (uvc_queue_streaming(&video->queue))
+	if (uvc_queue_streaming(&stream->queue))
 		return -EBUSY;
 
 	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -318,7 +319,7 @@
 	else
 		timeperframe = parm->parm.output.timeperframe;
 
-	memcpy(&probe, &video->streaming->ctrl, sizeof probe);
+	memcpy(&probe, &stream->ctrl, sizeof probe);
 	interval = uvc_fraction_to_interval(timeperframe.numerator,
 		timeperframe.denominator);
 
@@ -327,10 +328,11 @@
 	probe.dwFrameInterval = uvc_try_frame_interval(frame, interval);
 
 	/* Probe the device with the new settings. */
-	if ((ret = uvc_probe_video(video, &probe)) < 0)
+	ret = uvc_probe_video(stream, &probe);
+	if (ret < 0)
 		return ret;
 
-	memcpy(&video->streaming->ctrl, &probe, sizeof probe);
+	memcpy(&stream->ctrl, &probe, sizeof probe);
 
 	/* Return the actual frame period. */
 	timeperframe.numerator = probe.dwFrameInterval;
@@ -346,16 +348,16 @@
 	return 0;
 }
 
-static int uvc_v4l2_get_jpegcomp(struct uvc_video_device *video,
+static int uvc_v4l2_get_jpegcomp(struct uvc_streaming *stream,
 		struct v4l2_jpegcompression *jpeg)
 {
 	memset(jpeg, 0, sizeof *jpeg);
-	jpeg->quality = video->streaming->ctrl.wCompQuality / 100;
+	jpeg->quality = stream->ctrl.wCompQuality / 100;
 	jpeg->jpeg_markers = V4L2_JPEG_MARKER_DQT;
 	return 0;
 }
 
-static int uvc_v4l2_set_jpegcomp(struct uvc_video_device *video,
+static int uvc_v4l2_set_jpegcomp(struct uvc_streaming *stream,
 		struct v4l2_jpegcompression *jpeg)
 {
 	struct uvc_streaming_control probe;
@@ -363,20 +365,21 @@
 	int ret;
 
 	/* The buffer size must be renegotiated when changing quality. */
-	if (uvc_queue_allocated(&video->queue))
+	if (uvc_queue_allocated(&stream->queue))
 		return -EBUSY;
 
-	memcpy(&probe, &video->streaming->ctrl, sizeof probe);
+	memcpy(&probe, &stream->ctrl, sizeof probe);
 	quality = clamp(jpeg->quality, 0, 100) * 100;
 
 	uvc_trace(UVC_TRACE_FORMAT, "Setting JPEG quality to %u.\n", quality);
 	probe.wCompQuality = quality;
 
 	/* Probe the device with the new settings. */
-	if ((ret = uvc_probe_video(video, &probe)) < 0)
+	ret = uvc_probe_video(stream, &probe);
+	if (ret < 0)
 		return ret;
 
-	memcpy(&video->streaming->ctrl, &probe, sizeof probe);
+	memcpy(&stream->ctrl, &probe, sizeof probe);
 	return 0;
 }
 
@@ -417,8 +420,8 @@
 
 	/* Check if the device already has a privileged handle. */
 	mutex_lock(&uvc_driver.open_mutex);
-	if (atomic_inc_return(&handle->device->active) != 1) {
-		atomic_dec(&handle->device->active);
+	if (atomic_inc_return(&handle->stream->active) != 1) {
+		atomic_dec(&handle->stream->active);
 		ret = -EBUSY;
 		goto done;
 	}
@@ -433,7 +436,7 @@
 static void uvc_dismiss_privileges(struct uvc_fh *handle)
 {
 	if (handle->state == UVC_HANDLE_ACTIVE)
-		atomic_dec(&handle->device->active);
+		atomic_dec(&handle->stream->active);
 
 	handle->state = UVC_HANDLE_PASSIVE;
 }
@@ -449,21 +452,21 @@
 
 static int uvc_v4l2_open(struct file *file)
 {
-	struct uvc_video_device *video;
+	struct uvc_streaming *stream;
 	struct uvc_fh *handle;
 	int ret = 0;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_open\n");
 	mutex_lock(&uvc_driver.open_mutex);
-	video = video_drvdata(file);
+	stream = video_drvdata(file);
 
-	if (video->dev->state & UVC_DEV_DISCONNECTED) {
+	if (stream->dev->state & UVC_DEV_DISCONNECTED) {
 		ret = -ENODEV;
 		goto done;
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-	ret = usb_autopm_get_interface(video->dev->intf);
+	ret = usb_autopm_get_interface(stream->dev->intf);
 	if (ret < 0)
 		goto done;
 #endif
@@ -472,28 +475,30 @@
 	handle = kzalloc(sizeof *handle, GFP_KERNEL);
 	if (handle == NULL) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-		usb_autopm_put_interface(video->dev->intf);
+		usb_autopm_put_interface(stream->dev->intf);
 #endif
 		ret = -ENOMEM;
 		goto done;
 	}
 
-	if (atomic_inc_return(&video->dev->users) == 1) {
-		if ((ret = uvc_status_start(video->dev)) < 0) {
+	if (atomic_inc_return(&stream->dev->users) == 1) {
+		ret = uvc_status_start(stream->dev);
+		if (ret < 0) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-			usb_autopm_put_interface(video->dev->intf);
+			usb_autopm_put_interface(stream->dev->intf);
 #endif
-			atomic_dec(&video->dev->users);
+			atomic_dec(&stream->dev->users);
 			kfree(handle);
 			goto done;
 		}
 	}
 
-	handle->device = video;
+	handle->video = &stream->dev->video;
+	handle->stream = stream;
 	handle->state = UVC_HANDLE_PASSIVE;
 	file->private_data = handle;
 
-	kref_get(&video->dev->kref);
+	kref_get(&stream->dev->kref);
 
 done:
 	mutex_unlock(&uvc_driver.open_mutex);
@@ -502,20 +507,20 @@
 
 static int uvc_v4l2_release(struct file *file)
 {
-	struct uvc_video_device *video = video_drvdata(file);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_release\n");
 
 	/* Only free resources if this is a privileged handle. */
 	if (uvc_has_privileges(handle)) {
-		uvc_video_enable(video, 0);
+		uvc_video_enable(stream, 0);
 
-		mutex_lock(&video->queue.mutex);
-		if (uvc_free_buffers(&video->queue) < 0)
+		mutex_lock(&stream->queue.mutex);
+		if (uvc_free_buffers(&stream->queue) < 0)
 			uvc_printk(KERN_ERR, "uvc_v4l2_release: Unable to "
 					"free buffers.\n");
-		mutex_unlock(&video->queue.mutex);
+		mutex_unlock(&stream->queue.mutex);
 	}
 
 	/* Release the file handle. */
@@ -523,21 +528,22 @@
 	kfree(handle);
 	file->private_data = NULL;
 
-	if (atomic_dec_return(&video->dev->users) == 0)
-		uvc_status_stop(video->dev);
+	if (atomic_dec_return(&stream->dev->users) == 0)
+		uvc_status_stop(stream->dev);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-	usb_autopm_put_interface(video->dev->intf);
+	usb_autopm_put_interface(stream->dev->intf);
 #endif
-	kref_put(&video->dev->kref, uvc_delete);
+	kref_put(&stream->dev->kref, uvc_delete);
 	return 0;
 }
 
 static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 {
 	struct video_device *vdev = video_devdata(file);
-	struct uvc_video_device *video = video_get_drvdata(vdev);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_video_device *video = handle->video;
+	struct uvc_streaming *stream = handle->stream;
 	long ret = 0;
 
 	switch (cmd) {
@@ -549,10 +555,10 @@
 		memset(cap, 0, sizeof *cap);
 		strlcpy(cap->driver, "uvcvideo", sizeof cap->driver);
 		strlcpy(cap->card, vdev->name, sizeof cap->card);
-		usb_make_path(video->dev->udev,
+		usb_make_path(stream->dev->udev,
 			      cap->bus_info, sizeof(cap->bus_info));
 		cap->version = DRIVER_VERSION_NUMBER;
-		if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 			cap->capabilities = V4L2_CAP_VIDEO_CAPTURE
 					  | V4L2_CAP_STREAMING;
 		else
@@ -737,15 +743,15 @@
 		enum v4l2_buf_type type = fmt->type;
 		__u32 index = fmt->index;
 
-		if (fmt->type != video->streaming->type ||
-		    fmt->index >= video->streaming->nformats)
+		if (fmt->type != stream->type ||
+		    fmt->index >= stream->nformats)
 			return -EINVAL;
 
 		memset(fmt, 0, sizeof(*fmt));
 		fmt->index = index;
 		fmt->type = type;
 
-		format = &video->streaming->format[fmt->index];
+		format = &stream->format[fmt->index];
 		fmt->flags = 0;
 		if (format->flags & UVC_FMT_FLAG_COMPRESSED)
 			fmt->flags |= V4L2_FMT_FLAG_COMPRESSED;
@@ -763,17 +769,17 @@
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_try_format(video, arg, &probe, NULL, NULL);
+		return uvc_v4l2_try_format(stream, arg, &probe, NULL, NULL);
 	}
 
 	case VIDIOC_S_FMT:
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_set_format(video, arg);
+		return uvc_v4l2_set_format(stream, arg);
 
 	case VIDIOC_G_FMT:
-		return uvc_v4l2_get_format(video, arg);
+		return uvc_v4l2_get_format(stream, arg);
 
 	/* Frame size enumeration */
 	case VIDIOC_ENUM_FRAMESIZES:
@@ -784,10 +790,10 @@
 		int i;
 
 		/* Look for the given pixel format */
-		for (i = 0; i < video->streaming->nformats; i++) {
-			if (video->streaming->format[i].fcc ==
+		for (i = 0; i < stream->nformats; i++) {
+			if (stream->format[i].fcc ==
 					fsize->pixel_format) {
-				format = &video->streaming->format[i];
+				format = &stream->format[i];
 				break;
 			}
 		}
@@ -813,10 +819,10 @@
 		int i;
 
 		/* Look for the given pixel format and frame size */
-		for (i = 0; i < video->streaming->nformats; i++) {
-			if (video->streaming->format[i].fcc ==
+		for (i = 0; i < stream->nformats; i++) {
+			if (stream->format[i].fcc ==
 					fival->pixel_format) {
-				format = &video->streaming->format[i];
+				format = &stream->format[i];
 				break;
 			}
 		}
@@ -866,31 +872,31 @@
 
 	/* Get & Set JPEG compression parameters */
 	case VIDIOC_G_JPEGCOMP:
-		return uvc_v4l2_get_jpegcomp(video, arg);
+		return uvc_v4l2_get_jpegcomp(stream, arg);
 
 	case VIDIOC_S_JPEGCOMP:
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_set_jpegcomp(video, arg);
+		return uvc_v4l2_set_jpegcomp(stream, arg);
 
 	/* Get & Set streaming parameters */
 	case VIDIOC_G_PARM:
-		return uvc_v4l2_get_streamparm(video, arg);
+		return uvc_v4l2_get_streamparm(stream, arg);
 
 	case VIDIOC_S_PARM:
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_set_streamparm(video, arg);
+		return uvc_v4l2_set_streamparm(stream, arg);
 
 	/* Cropping and scaling */
 	case VIDIOC_CROPCAP:
 	{
 		struct v4l2_cropcap *ccap = arg;
-		struct uvc_frame *frame = video->streaming->cur_frame;
+		struct uvc_frame *frame = stream->cur_frame;
 
-		if (ccap->type != video->streaming->type)
+		if (ccap->type != stream->type)
 			return -EINVAL;
 
 		ccap->bounds.left = 0;
@@ -914,16 +920,16 @@
 	{
 		struct v4l2_requestbuffers *rb = arg;
 		unsigned int bufsize =
-			video->streaming->ctrl.dwMaxVideoFrameSize;
+			stream->ctrl.dwMaxVideoFrameSize;
 
-		if (rb->type != video->streaming->type ||
+		if (rb->type != stream->type ||
 		    rb->memory != V4L2_MEMORY_MMAP)
 			return -EINVAL;
 
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		ret = uvc_alloc_buffers(&video->queue, rb->count, bufsize);
+		ret = uvc_alloc_buffers(&stream->queue, rb->count, bufsize);
 		if (ret < 0)
 			return ret;
 
@@ -936,39 +942,40 @@
 	{
 		struct v4l2_buffer *buf = arg;
 
-		if (buf->type != video->streaming->type)
+		if (buf->type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_query_buffer(&video->queue, buf);
+		return uvc_query_buffer(&stream->queue, buf);
 	}
 
 	case VIDIOC_QBUF:
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_queue_buffer(&video->queue, arg);
+		return uvc_queue_buffer(&stream->queue, arg);
 
 	case VIDIOC_DQBUF:
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_dequeue_buffer(&video->queue, arg,
+		return uvc_dequeue_buffer(&stream->queue, arg,
 			file->f_flags & O_NONBLOCK);
 
 	case VIDIOC_STREAMON:
 	{
 		int *type = arg;
 
-		if (*type != video->streaming->type)
+		if (*type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		if ((ret = uvc_video_enable(video, 1)) < 0)
+		ret = uvc_video_enable(stream, 1);
+		if (ret < 0)
 			return ret;
 		break;
 	}
@@ -977,13 +984,13 @@
 	{
 		int *type = arg;
 
-		if (*type != video->streaming->type)
+		if (*type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_video_enable(video, 0);
+		return uvc_video_enable(stream, 0);
 	}
 
 	/* Analog video standards make no sense for digital cameras. */
@@ -1114,7 +1121,9 @@
 
 static int uvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct uvc_video_device *video = video_drvdata(file);
+	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
+	struct uvc_video_queue *queue = &stream->queue;
 	struct uvc_buffer *uninitialized_var(buffer);
 	struct page *page;
 	unsigned long addr, start, size;
@@ -1126,15 +1135,15 @@
 	start = vma->vm_start;
 	size = vma->vm_end - vma->vm_start;
 
-	mutex_lock(&video->queue.mutex);
+	mutex_lock(&queue->mutex);
 
-	for (i = 0; i < video->queue.count; ++i) {
-		buffer = &video->queue.buffer[i];
+	for (i = 0; i < queue->count; ++i) {
+		buffer = &queue->buffer[i];
 		if ((buffer->buf.m.offset >> PAGE_SHIFT) == vma->vm_pgoff)
 			break;
 	}
 
-	if (i == video->queue.count || size != video->queue.buf_size) {
+	if (i == queue->count || size != queue->buf_size) {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -1145,7 +1154,7 @@
 	 */
 	vma->vm_flags |= VM_IO;
 
-	addr = (unsigned long)video->queue.mem + buffer->buf.m.offset;
+	addr = (unsigned long)queue->mem + buffer->buf.m.offset;
 	while (size > 0) {
 		page = vmalloc_to_page((void *)addr);
 		if ((ret = vm_insert_page(vma, start, page)) < 0)
@@ -1161,17 +1170,18 @@
 	uvc_vm_open(vma);
 
 done:
-	mutex_unlock(&video->queue.mutex);
+	mutex_unlock(&queue->mutex);
 	return ret;
 }
 
 static unsigned int uvc_v4l2_poll(struct file *file, poll_table *wait)
 {
-	struct uvc_video_device *video = video_drvdata(file);
+	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_poll\n");
 
-	return uvc_queue_poll(&video->queue, file, wait);
+	return uvc_queue_poll(&stream->queue, file, wait);
 }
 
 const struct v4l2_file_operations uvc_fops = {
diff -r 50059a68c503 -r 88ef3b9f5071 linux/drivers/media/video/uvc/uvc_video.c
--- a/linux/drivers/media/video/uvc/uvc_video.c	Thu Jun 04 14:37:43 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_video.c	Sun Jun 28 13:37:50 2009 +0200
@@ -61,7 +61,7 @@
 	return 0;
 }
 
-static void uvc_fixup_video_ctrl(struct uvc_video_device *video,
+static void uvc_fixup_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl)
 {
 	struct uvc_format *format;
@@ -69,10 +69,10 @@
 	unsigned int i;
 
 	if (ctrl->bFormatIndex <= 0 ||
-	    ctrl->bFormatIndex > video->streaming->nformats)
+	    ctrl->bFormatIndex > stream->nformats)
 		return;
 
-	format = &video->streaming->format[ctrl->bFormatIndex - 1];
+	format = &stream->format[ctrl->bFormatIndex - 1];
 
 	for (i = 0; i < format->nframes; ++i) {
 		if (format->frame[i].bFrameIndex == ctrl->bFrameIndex) {
@@ -86,12 +86,12 @@
 
 	if (!(format->flags & UVC_FMT_FLAG_COMPRESSED) ||
 	     (ctrl->dwMaxVideoFrameSize == 0 &&
-	      video->dev->uvc_version < 0x0110))
+	      stream->dev->uvc_version < 0x0110))
 		ctrl->dwMaxVideoFrameSize =
 			frame->dwMaxVideoFrameBufferSize;
 
-	if (video->dev->quirks & UVC_QUIRK_FIX_BANDWIDTH &&
-	    video->streaming->intf->num_altsetting > 1) {
+	if (stream->dev->quirks & UVC_QUIRK_FIX_BANDWIDTH &&
+	    stream->intf->num_altsetting > 1) {
 		u32 interval;
 		u32 bandwidth;
 
@@ -108,7 +108,7 @@
 		bandwidth = frame->wWidth * frame->wHeight / 8 * format->bpp;
 		bandwidth *= 10000000 / interval + 1;
 		bandwidth /= 1000;
-		if (video->dev->udev->speed == USB_SPEED_HIGH)
+		if (stream->dev->udev->speed == USB_SPEED_HIGH)
 			bandwidth /= 8;
 		bandwidth += 12;
 
@@ -116,19 +116,19 @@
 	}
 }
 
-static int uvc_get_video_ctrl(struct uvc_video_device *video,
+static int uvc_get_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl, int probe, __u8 query)
 {
 	__u8 *data;
 	__u16 size;
 	int ret;
 
-	size = video->dev->uvc_version >= 0x0110 ? 34 : 26;
+	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
 	data = kmalloc(size, GFP_KERNEL);
 	if (data == NULL)
 		return -ENOMEM;
 
-	ret = __uvc_query_ctrl(video->dev, query, 0, video->streaming->intfnum,
+	ret = __uvc_query_ctrl(stream->dev, query, 0, stream->intfnum,
 		probe ? VS_PROBE_CONTROL : VS_COMMIT_CONTROL, data, size,
 		UVC_CTRL_STREAMING_TIMEOUT);
 
@@ -137,7 +137,7 @@
 		 * answer a GET_MIN or GET_MAX request with the wCompQuality
 		 * field only.
 		 */
-		uvc_warn_once(video->dev, UVC_WARN_MINMAX, "UVC non "
+		uvc_warn_once(stream->dev, UVC_WARN_MINMAX, "UVC non "
 			"compliance - GET_MIN/MAX(PROBE) incorrectly "
 			"supported. Enabling workaround.\n");
 		memset(ctrl, 0, sizeof ctrl);
@@ -149,7 +149,7 @@
 		 * video probe control. Warn once and return, the caller will
 		 * fall back to GET_CUR.
 		 */
-		uvc_warn_once(video->dev, UVC_WARN_PROBE_DEF, "UVC non "
+		uvc_warn_once(stream->dev, UVC_WARN_PROBE_DEF, "UVC non "
 			"compliance - GET_DEF(PROBE) not supported. "
 			"Enabling workaround.\n");
 		ret = -EIO;
@@ -181,7 +181,7 @@
 		ctrl->bMinVersion = data[32];
 		ctrl->bMaxVersion = data[33];
 	} else {
-		ctrl->dwClockFrequency = video->dev->clock_frequency;
+		ctrl->dwClockFrequency = stream->dev->clock_frequency;
 		ctrl->bmFramingInfo = 0;
 		ctrl->bPreferedVersion = 0;
 		ctrl->bMinVersion = 0;
@@ -192,7 +192,7 @@
 	 * dwMaxPayloadTransferSize fields. Try to get the value from the
 	 * format and frame descriptors.
 	 */
-	uvc_fixup_video_ctrl(video, ctrl);
+	uvc_fixup_video_ctrl(stream, ctrl);
 	ret = 0;
 
 out:
@@ -200,14 +200,14 @@
 	return ret;
 }
 
-static int uvc_set_video_ctrl(struct uvc_video_device *video,
+static int uvc_set_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl, int probe)
 {
 	__u8 *data;
 	__u16 size;
 	int ret;
 
-	size = video->dev->uvc_version >= 0x0110 ? 34 : 26;
+	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
 	data = kzalloc(size, GFP_KERNEL);
 	if (data == NULL)
 		return -ENOMEM;
@@ -232,8 +232,7 @@
 		data[33] = ctrl->bMaxVersion;
 	}
 
-	ret = __uvc_query_ctrl(video->dev, SET_CUR, 0,
-		video->streaming->intfnum,
+	ret = __uvc_query_ctrl(stream->dev, SET_CUR, 0, stream->intfnum,
 		probe ? VS_PROBE_CONTROL : VS_COMMIT_CONTROL, data, size,
 		UVC_CTRL_STREAMING_TIMEOUT);
 	if (ret != size) {
@@ -247,7 +246,7 @@
 	return ret;
 }
 
-int uvc_probe_video(struct uvc_video_device *video,
+int uvc_probe_video(struct uvc_streaming *stream,
 	struct uvc_streaming_control *probe)
 {
 	struct uvc_streaming_control probe_min, probe_max;
@@ -255,7 +254,7 @@
 	unsigned int i;
 	int ret;
 
-	mutex_lock(&video->streaming->mutex);
+	mutex_lock(&stream->mutex);
 
 	/* Perform probing. The device should adjust the requested values
 	 * according to its capabilities. However, some devices, namely the
@@ -264,15 +263,16 @@
 	 * that reason, if the needed bandwidth exceeds the maximum available
 	 * bandwidth, try to lower the quality.
 	 */
-	if ((ret = uvc_set_video_ctrl(video, probe, 1)) < 0)
+	ret = uvc_set_video_ctrl(stream, probe, 1);
+	if (ret < 0)
 		goto done;
 
 	/* Get the minimum and maximum values for compression settings. */
-	if (!(video->dev->quirks & UVC_QUIRK_PROBE_MINMAX)) {
-		ret = uvc_get_video_ctrl(video, &probe_min, 1, GET_MIN);
+	if (!(stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX)) {
+		ret = uvc_get_video_ctrl(stream, &probe_min, 1, GET_MIN);
 		if (ret < 0)
 			goto done;
-		ret = uvc_get_video_ctrl(video, &probe_max, 1, GET_MAX);
+		ret = uvc_get_video_ctrl(stream, &probe_max, 1, GET_MAX);
 		if (ret < 0)
 			goto done;
 
@@ -282,18 +282,21 @@
 	}
 
 	for (i = 0; i < 2; ++i) {
-		if ((ret = uvc_set_video_ctrl(video, probe, 1)) < 0 ||
-		    (ret = uvc_get_video_ctrl(video, probe, 1, GET_CUR)) < 0)
+		ret = uvc_set_video_ctrl(stream, probe, 1);
+		if (ret < 0)
+			goto done;
+		ret = uvc_get_video_ctrl(stream, probe, 1, GET_CUR);
+		if (ret < 0)
 			goto done;
 
-		if (video->streaming->intf->num_altsetting == 1)
+		if (stream->intf->num_altsetting == 1)
 			break;
 
 		bandwidth = probe->dwMaxPayloadTransferSize;
-		if (bandwidth <= video->streaming->maxpsize)
+		if (bandwidth <= stream->maxpsize)
 			break;
 
-		if (video->dev->quirks & UVC_QUIRK_PROBE_MINMAX) {
+		if (stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX) {
 			ret = -ENOSPC;
 			goto done;
 		}
@@ -306,14 +309,14 @@
 	}
 
 done:
-	mutex_unlock(&video->streaming->mutex);
+	mutex_unlock(&stream->mutex);
 	return ret;
 }
 
-int uvc_commit_video(struct uvc_video_device *video,
+int uvc_commit_video(struct uvc_streaming *stream,
 	struct uvc_streaming_control *probe)
 {
-	return uvc_set_video_ctrl(video, probe, 0);
+	return uvc_set_video_ctrl(stream, probe, 0);
 }
 
 /* ------------------------------------------------------------------------
@@ -365,7 +368,7 @@
  * to be called with a NULL buf parameter. uvc_video_decode_data and
  * uvc_video_decode_end will never be called with a NULL buffer.
  */
-static int uvc_video_decode_start(struct uvc_video_device *video,
+static int uvc_video_decode_start(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
 	__u8 fid;
@@ -391,25 +394,25 @@
 	 * NULL.
 	 */
 	if (buf == NULL) {
-		video->last_fid = fid;
+		stream->last_fid = fid;
 		return -ENODATA;
 	}
 
 	/* Synchronize to the input stream by waiting for the FID bit to be
 	 * toggled when the the buffer state is not UVC_BUF_STATE_ACTIVE.
-	 * video->last_fid is initialized to -1, so the first isochronous
+	 * stream->last_fid is initialized to -1, so the first isochronous
 	 * frame will always be in sync.
 	 *
-	 * If the device doesn't toggle the FID bit, invert video->last_fid
+	 * If the device doesn't toggle the FID bit, invert stream->last_fid
 	 * when the EOF bit is set to force synchronisation on the next packet.
 	 */
 	if (buf->state != UVC_BUF_STATE_ACTIVE) {
-		if (fid == video->last_fid) {
+		if (fid == stream->last_fid) {
 			uvc_trace(UVC_TRACE_FRAME, "Dropping payload (out of "
 				"sync).\n");
-			if ((video->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&
+			if ((stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&
 			    (data[1] & UVC_STREAM_EOF))
-				video->last_fid ^= UVC_STREAM_FID;
+				stream->last_fid ^= UVC_STREAM_FID;
 			return -ENODATA;
 		}
 
@@ -424,7 +427,7 @@
 	 * last payload can be lost anyway). We thus must check if the FID has
 	 * been toggled.
 	 *
-	 * video->last_fid is initialized to -1, so the first isochronous
+	 * stream->last_fid is initialized to -1, so the first isochronous
 	 * frame will never trigger an end of frame detection.
 	 *
 	 * Empty buffers (bytesused == 0) don't trigger end of frame detection
@@ -432,22 +435,22 @@
 	 * avoids detecting end of frame conditions at FID toggling if the
 	 * previous payload had the EOF bit set.
 	 */
-	if (fid != video->last_fid && buf->buf.bytesused != 0) {
+	if (fid != stream->last_fid && buf->buf.bytesused != 0) {
 		uvc_trace(UVC_TRACE_FRAME, "Frame complete (FID bit "
 				"toggled).\n");
 		buf->state = UVC_BUF_STATE_DONE;
 		return -EAGAIN;
 	}
 
-	video->last_fid = fid;
+	stream->last_fid = fid;
 
 	return data[0];
 }
 
-static void uvc_video_decode_data(struct uvc_video_device *video,
+static void uvc_video_decode_data(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_video_queue *queue = &stream->queue;
 	unsigned int maxlen, nbytes;
 	void *mem;
 
@@ -468,7 +471,7 @@
 	}
 }
 
-static void uvc_video_decode_end(struct uvc_video_device *video,
+static void uvc_video_decode_end(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
 	/* Mark the buffer as done if the EOF marker is set. */
@@ -477,8 +480,8 @@
 		if (data[0] == len)
 			uvc_trace(UVC_TRACE_FRAME, "EOF in empty payload.\n");
 		buf->state = UVC_BUF_STATE_DONE;
-		if (video->dev->quirks & UVC_QUIRK_STREAM_NO_FID)
-			video->last_fid ^= UVC_STREAM_FID;
+		if (stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID)
+			stream->last_fid ^= UVC_STREAM_FID;
 	}
 }
 
@@ -493,26 +496,26 @@
  * uvc_video_encode_data is called for every URB and copies the data from the
  * video buffer to the transfer buffer.
  */
-static int uvc_video_encode_header(struct uvc_video_device *video,
+static int uvc_video_encode_header(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, __u8 *data, int len)
 {
 	data[0] = 2;	/* Header length */
 	data[1] = UVC_STREAM_EOH | UVC_STREAM_EOF
-		| (video->last_fid & UVC_STREAM_FID);
+		| (stream->last_fid & UVC_STREAM_FID);
 	return 2;
 }
 
-static int uvc_video_encode_data(struct uvc_video_device *video,
+static int uvc_video_encode_data(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, __u8 *data, int len)
 {
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_video_queue *queue = &stream->queue;
 	unsigned int nbytes;
 	void *mem;
 
 	/* Copy video data to the URB buffer. */
 	mem = queue->mem + buf->buf.m.offset + queue->buf_used;
 	nbytes = min((unsigned int)len, buf->buf.bytesused - queue->buf_used);
-	nbytes = min(video->bulk.max_payload_size - video->bulk.payload_size,
+	nbytes = min(stream->bulk.max_payload_size - stream->bulk.payload_size,
 			nbytes);
 	memcpy(data, mem, nbytes);
 
@@ -528,8 +531,8 @@
 /*
  * Completion handler for video URBs.
  */
-static void uvc_video_decode_isoc(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_decode_isoc(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem;
 	int ret, i;
@@ -544,31 +547,32 @@
 		/* Decode the payload header. */
 		mem = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
 		do {
-			ret = uvc_video_decode_start(video, buf, mem,
+			ret = uvc_video_decode_start(stream, buf, mem,
 				urb->iso_frame_desc[i].actual_length);
 			if (ret == -EAGAIN)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		} while (ret == -EAGAIN);
 
 		if (ret < 0)
 			continue;
 
 		/* Decode the payload data. */
-		uvc_video_decode_data(video, buf, mem + ret,
+		uvc_video_decode_data(stream, buf, mem + ret,
 			urb->iso_frame_desc[i].actual_length - ret);
 
 		/* Process the header again. */
-		uvc_video_decode_end(video, buf, mem,
+		uvc_video_decode_end(stream, buf, mem,
 			urb->iso_frame_desc[i].actual_length);
 
 		if (buf->state == UVC_BUF_STATE_DONE ||
 		    buf->state == UVC_BUF_STATE_ERROR)
-			buf = uvc_queue_next_buffer(&video->queue, buf);
+			buf = uvc_queue_next_buffer(&stream->queue, buf);
 	}
 }
 
-static void uvc_video_decode_bulk(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_decode_bulk(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem;
 	int len, ret;
@@ -578,24 +582,25 @@
 
 	mem = urb->transfer_buffer;
 	len = urb->actual_length;
-	video->bulk.payload_size += len;
+	stream->bulk.payload_size += len;
 
 	/* If the URB is the first of its payload, decode and save the
 	 * header.
 	 */
-	if (video->bulk.header_size == 0 && !video->bulk.skip_payload) {
+	if (stream->bulk.header_size == 0 && !stream->bulk.skip_payload) {
 		do {
-			ret = uvc_video_decode_start(video, buf, mem, len);
+			ret = uvc_video_decode_start(stream, buf, mem, len);
 			if (ret == -EAGAIN)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		} while (ret == -EAGAIN);
 
 		/* If an error occured skip the rest of the payload. */
 		if (ret < 0 || buf == NULL) {
-			video->bulk.skip_payload = 1;
+			stream->bulk.skip_payload = 1;
 		} else {
-			memcpy(video->bulk.header, mem, ret);
-			video->bulk.header_size = ret;
+			memcpy(stream->bulk.header, mem, ret);
+			stream->bulk.header_size = ret;
 
 			mem += ret;
 			len -= ret;
@@ -608,33 +613,34 @@
 	 */
 
 	/* Process video data. */
-	if (!video->bulk.skip_payload && buf != NULL)
-		uvc_video_decode_data(video, buf, mem, len);
+	if (!stream->bulk.skip_payload && buf != NULL)
+		uvc_video_decode_data(stream, buf, mem, len);
 
 	/* Detect the payload end by a URB smaller than the maximum size (or
 	 * a payload size equal to the maximum) and process the header again.
 	 */
 	if (urb->actual_length < urb->transfer_buffer_length ||
-	    video->bulk.payload_size >= video->bulk.max_payload_size) {
-		if (!video->bulk.skip_payload && buf != NULL) {
-			uvc_video_decode_end(video, buf, video->bulk.header,
-				video->bulk.payload_size);
+	    stream->bulk.payload_size >= stream->bulk.max_payload_size) {
+		if (!stream->bulk.skip_payload && buf != NULL) {
+			uvc_video_decode_end(stream, buf, stream->bulk.header,
+				stream->bulk.payload_size);
 			if (buf->state == UVC_BUF_STATE_DONE ||
 			    buf->state == UVC_BUF_STATE_ERROR)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		}
 
-		video->bulk.header_size = 0;
-		video->bulk.skip_payload = 0;
-		video->bulk.payload_size = 0;
+		stream->bulk.header_size = 0;
+		stream->bulk.skip_payload = 0;
+		stream->bulk.payload_size = 0;
 	}
 }
 
-static void uvc_video_encode_bulk(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_encode_bulk(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem = urb->transfer_buffer;
-	int len = video->urb_size, ret;
+	int len = stream->urb_size, ret;
 
 	if (buf == NULL) {
 		urb->transfer_buffer_length = 0;
@@ -642,34 +648,34 @@
 	}
 
 	/* If the URB is the first of its payload, add the header. */
-	if (video->bulk.header_size == 0) {
-		ret = uvc_video_encode_header(video, buf, mem, len);
-		video->bulk.header_size = ret;
-		video->bulk.payload_size += ret;
+	if (stream->bulk.header_size == 0) {
+		ret = uvc_video_encode_header(stream, buf, mem, len);
+		stream->bulk.header_size = ret;
+		stream->bulk.payload_size += ret;
 		mem += ret;
 		len -= ret;
 	}
 
 	/* Process video data. */
-	ret = uvc_video_encode_data(video, buf, mem, len);
+	ret = uvc_video_encode_data(stream, buf, mem, len);
 
-	video->bulk.payload_size += ret;
+	stream->bulk.payload_size += ret;
 	len -= ret;
 
-	if (buf->buf.bytesused == video->queue.buf_used ||
-	    video->bulk.payload_size == video->bulk.max_payload_size) {
-		if (buf->buf.bytesused == video->queue.buf_used) {
-			video->queue.buf_used = 0;
+	if (buf->buf.bytesused == stream->queue.buf_used ||
+	    stream->bulk.payload_size == stream->bulk.max_payload_size) {
+		if (buf->buf.bytesused == stream->queue.buf_used) {
+			stream->queue.buf_used = 0;
 			buf->state = UVC_BUF_STATE_DONE;
-			uvc_queue_next_buffer(&video->queue, buf);
-			video->last_fid ^= UVC_STREAM_FID;
+			uvc_queue_next_buffer(&stream->queue, buf);
+			stream->last_fid ^= UVC_STREAM_FID;
 		}
 
-		video->bulk.header_size = 0;
-		video->bulk.payload_size = 0;
+		stream->bulk.header_size = 0;
+		stream->bulk.payload_size = 0;
 	}
 
-	urb->transfer_buffer_length = video->urb_size - len;
+	urb->transfer_buffer_length = stream->urb_size - len;
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
@@ -678,8 +684,8 @@
 static void uvc_video_complete(struct urb *urb)
 #endif
 {
-	struct uvc_video_device *video = urb->context;
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_streaming *stream = urb->context;
+	struct uvc_video_queue *queue = &stream->queue;
 	struct uvc_buffer *buf = NULL;
 	unsigned long flags;
 	int ret;
@@ -693,7 +699,7 @@
 			"completion handler.\n", urb->status);
 
 	case -ENOENT:		/* usb_kill_urb() called. */
-		if (video->frozen)
+		if (stream->frozen)
 			return;
 
 	case -ECONNRESET:	/* usb_unlink_urb() called. */
@@ -708,7 +714,7 @@
 				       queue);
 	spin_unlock_irqrestore(&queue->irqlock, flags);
 
-	video->decode(urb, video, buf);
+	stream->decode(urb, stream, buf);
 
 	if ((ret = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
 		uvc_printk(KERN_ERR, "Failed to resubmit video URB (%d).\n",
@@ -719,19 +725,19 @@
 /*
  * Free transfer buffers.
  */
-static void uvc_free_urb_buffers(struct uvc_video_device *video)
+static void uvc_free_urb_buffers(struct uvc_streaming *stream)
 {
 	unsigned int i;
 
 	for (i = 0; i < UVC_URBS; ++i) {
-		if (video->urb_buffer[i]) {
-			usb_buffer_free(video->dev->udev, video->urb_size,
-				video->urb_buffer[i], video->urb_dma[i]);
-			video->urb_buffer[i] = NULL;
+		if (stream->urb_buffer[i]) {
+			usb_buffer_free(stream->dev->udev, stream->urb_size,
+				stream->urb_buffer[i], stream->urb_dma[i]);
+			stream->urb_buffer[i] = NULL;
 		}
 	}
 
-	video->urb_size = 0;
+	stream->urb_size = 0;
 }
 
 /*
@@ -745,15 +751,15 @@
  *
  * Return the number of allocated packets on success or 0 when out of memory.
  */
-static int uvc_alloc_urb_buffers(struct uvc_video_device *video,
+static int uvc_alloc_urb_buffers(struct uvc_streaming *stream,
 	unsigned int size, unsigned int psize, gfp_t gfp_flags)
 {
 	unsigned int npackets;
 	unsigned int i;
 
 	/* Buffers are already allocated, bail out. */
-	if (video->urb_size)
-		return video->urb_size / psize;
+	if (stream->urb_size)
+		return stream->urb_size / psize;
 
 	/* Compute the number of packets. Bulk endpoints might transfer UVC
 	 * payloads accross multiple URBs.
@@ -765,17 +771,17 @@
 	/* Retry allocations until one succeed. */
 	for (; npackets > 1; npackets /= 2) {
 		for (i = 0; i < UVC_URBS; ++i) {
-			video->urb_buffer[i] = usb_buffer_alloc(
-				video->dev->udev, psize * npackets,
-				gfp_flags | __GFP_NOWARN, &video->urb_dma[i]);
-			if (!video->urb_buffer[i]) {
-				uvc_free_urb_buffers(video);
+			stream->urb_buffer[i] = usb_buffer_alloc(
+				stream->dev->udev, psize * npackets,
+				gfp_flags | __GFP_NOWARN, &stream->urb_dma[i]);
+			if (!stream->urb_buffer[i]) {
+				uvc_free_urb_buffers(stream);
 				break;
 			}
 		}
 
 		if (i == UVC_URBS) {
-			video->urb_size = psize * npackets;
+			stream->urb_size = psize * npackets;
 			return npackets;
 		}
 	}
@@ -786,29 +792,30 @@
 /*
  * Uninitialize isochronous/bulk URBs and free transfer buffers.
  */
-static void uvc_uninit_video(struct uvc_video_device *video, int free_buffers)
+static void uvc_uninit_video(struct uvc_streaming *stream, int free_buffers)
 {
 	struct urb *urb;
 	unsigned int i;
 
 	for (i = 0; i < UVC_URBS; ++i) {
-		if ((urb = video->urb[i]) == NULL)
+		urb = stream->urb[i];
+		if (urb == NULL)
 			continue;
 
 		usb_kill_urb(urb);
 		usb_free_urb(urb);
-		video->urb[i] = NULL;
+		stream->urb[i] = NULL;
 	}
 
 	if (free_buffers)
-		uvc_free_urb_buffers(video);
+		uvc_free_urb_buffers(stream);
 }
 
 /*
  * Initialize isochronous URBs and allocate transfer buffers. The packet size
  * is given by the endpoint.
  */
-static int uvc_init_video_isoc(struct uvc_video_device *video,
+static int uvc_init_video_isoc(struct uvc_streaming *stream,
 	struct usb_host_endpoint *ep, gfp_t gfp_flags)
 {
 	struct urb *urb;
@@ -818,9 +825,9 @@
 
 	psize = le16_to_cpu(ep->desc.wMaxPacketSize);
 	psize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));
-	size = video->streaming->ctrl.dwMaxVideoFrameSize;
+	size = stream->ctrl.dwMaxVideoFrameSize;
 
-	npackets = uvc_alloc_urb_buffers(video, size, psize, gfp_flags);
+	npackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);
 	if (npackets == 0)
 		return -ENOMEM;
 
@@ -829,18 +836,18 @@
 	for (i = 0; i < UVC_URBS; ++i) {
 		urb = usb_alloc_urb(npackets, gfp_flags);
 		if (urb == NULL) {
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return -ENOMEM;
 		}
 
-		urb->dev = video->dev->udev;
-		urb->context = video;
-		urb->pipe = usb_rcvisocpipe(video->dev->udev,
+		urb->dev = stream->dev->udev;
+		urb->context = stream;
+		urb->pipe = usb_rcvisocpipe(stream->dev->udev,
 				ep->desc.bEndpointAddress);
 		urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
 		urb->interval = ep->desc.bInterval;
-		urb->transfer_buffer = video->urb_buffer[i];
-		urb->transfer_dma = video->urb_dma[i];
+		urb->transfer_buffer = stream->urb_buffer[i];
+		urb->transfer_dma = stream->urb_dma[i];
 		urb->complete = uvc_video_complete;
 		urb->number_of_packets = npackets;
 		urb->transfer_buffer_length = size;
@@ -850,7 +857,7 @@
 			urb->iso_frame_desc[j].length = psize;
 		}
 
-		video->urb[i] = urb;
+		stream->urb[i] = urb;
 	}
 
 	return 0;
@@ -860,7 +867,7 @@
  * Initialize bulk URBs and allocate transfer buffers. The packet size is
  * given by the endpoint.
  */
-static int uvc_init_video_bulk(struct uvc_video_device *video,
+static int uvc_init_video_bulk(struct uvc_streaming *stream,
 	struct usb_host_endpoint *ep, gfp_t gfp_flags)
 {
 	struct urb *urb;
@@ -869,39 +876,39 @@
 	u32 size;
 
 	psize = le16_to_cpu(ep->desc.wMaxPacketSize) & 0x07ff;
-	size = video->streaming->ctrl.dwMaxPayloadTransferSize;
-	video->bulk.max_payload_size = size;
+	size = stream->ctrl.dwMaxPayloadTransferSize;
+	stream->bulk.max_payload_size = size;
 
-	npackets = uvc_alloc_urb_buffers(video, size, psize, gfp_flags);
+	npackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);
 	if (npackets == 0)
 		return -ENOMEM;
 
 	size = npackets * psize;
 
 	if (usb_endpoint_dir_in(&ep->desc))
-		pipe = usb_rcvbulkpipe(video->dev->udev,
+		pipe = usb_rcvbulkpipe(stream->dev->udev,
 				       ep->desc.bEndpointAddress);
 	else
-		pipe = usb_sndbulkpipe(video->dev->udev,
+		pipe = usb_sndbulkpipe(stream->dev->udev,
 				       ep->desc.bEndpointAddress);
 
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
 		size = 0;
 
 	for (i = 0; i < UVC_URBS; ++i) {
 		urb = usb_alloc_urb(0, gfp_flags);
 		if (urb == NULL) {
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return -ENOMEM;
 		}
 
-		usb_fill_bulk_urb(urb, video->dev->udev, pipe,
-			video->urb_buffer[i], size, uvc_video_complete,
-			video);
+		usb_fill_bulk_urb(urb, stream->dev->udev, pipe,
+			stream->urb_buffer[i], size, uvc_video_complete,
+			stream);
 		urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
-		urb->transfer_dma = video->urb_dma[i];
+		urb->transfer_dma = stream->urb_dma[i];
 
-		video->urb[i] = urb;
+		stream->urb[i] = urb;
 	}
 
 	return 0;
@@ -910,35 +917,35 @@
 /*
  * Initialize isochronous/bulk URBs and allocate transfer buffers.
  */
-static int uvc_init_video(struct uvc_video_device *video, gfp_t gfp_flags)
+static int uvc_init_video(struct uvc_streaming *stream, gfp_t gfp_flags)
 {
-	struct usb_interface *intf = video->streaming->intf;
+	struct usb_interface *intf = stream->intf;
 	struct usb_host_interface *alts;
 	struct usb_host_endpoint *ep = NULL;
-	int intfnum = video->streaming->intfnum;
+	int intfnum = stream->intfnum;
 	unsigned int bandwidth, psize, i;
 	int ret;
 
-	video->last_fid = -1;
-	video->bulk.header_size = 0;
-	video->bulk.skip_payload = 0;
-	video->bulk.payload_size = 0;
+	stream->last_fid = -1;
+	stream->bulk.header_size = 0;
+	stream->bulk.skip_payload = 0;
+	stream->bulk.payload_size = 0;
 
 	if (intf->num_altsetting > 1) {
 		/* Isochronous endpoint, select the alternate setting. */
-		bandwidth = video->streaming->ctrl.dwMaxPayloadTransferSize;
+		bandwidth = stream->ctrl.dwMaxPayloadTransferSize;
 
 		if (bandwidth == 0) {
 			uvc_printk(KERN_WARNING, "device %s requested null "
 				"bandwidth, defaulting to lowest.\n",
-				video->vdev->name);
+				stream->dev->name);
 			bandwidth = 1;
 		}
 
 		for (i = 0; i < intf->num_altsetting; ++i) {
 			alts = &intf->altsetting[i];
 			ep = uvc_find_endpoint(alts,
-				video->streaming->header.bEndpointAddress);
+				stream->header.bEndpointAddress);
 			if (ep == NULL)
 				continue;
 
@@ -952,18 +959,19 @@
 		if (i >= intf->num_altsetting)
 			return -EIO;
 
-		if ((ret = usb_set_interface(video->dev->udev, intfnum, i)) < 0)
+		ret = usb_set_interface(stream->dev->udev, intfnum, i);
+		if (ret < 0)
 			return ret;
 
-		ret = uvc_init_video_isoc(video, ep, gfp_flags);
+		ret = uvc_init_video_isoc(stream, ep, gfp_flags);
 	} else {
 		/* Bulk endpoint, proceed to URB initialization. */
 		ep = uvc_find_endpoint(&intf->altsetting[0],
-				video->streaming->header.bEndpointAddress);
+				stream->header.bEndpointAddress);
 		if (ep == NULL)
 			return -EIO;
 
-		ret = uvc_init_video_bulk(video, ep, gfp_flags);
+		ret = uvc_init_video_bulk(stream, ep, gfp_flags);
 	}
 
 	if (ret < 0)
@@ -971,10 +979,11 @@
 
 	/* Submit the URBs. */
 	for (i = 0; i < UVC_URBS; ++i) {
-		if ((ret = usb_submit_urb(video->urb[i], gfp_flags)) < 0) {
+		ret = usb_submit_urb(stream->urb[i], gfp_flags);
+		if (ret < 0) {
 			uvc_printk(KERN_ERR, "Failed to submit URB %u "
 					"(%d).\n", i, ret);
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return ret;
 		}
 	}
@@ -993,14 +1002,14 @@
  * video buffers in any way. We mark the device as frozen to make sure the URB
  * completion handler won't try to cancel the queue when we kill the URBs.
  */
-int uvc_video_suspend(struct uvc_video_device *video)
+int uvc_video_suspend(struct uvc_streaming *stream)
 {
-	if (!uvc_queue_streaming(&video->queue))
+	if (!uvc_queue_streaming(&stream->queue))
 		return 0;
 
-	video->frozen = 1;
-	uvc_uninit_video(video, 0);
-	usb_set_interface(video->dev->udev, video->streaming->intfnum, 0);
+	stream->frozen = 1;
+	uvc_uninit_video(stream, 0);
+	usb_set_interface(stream->dev->udev, stream->intfnum, 0);
 	return 0;
 }
 
@@ -1012,22 +1021,24 @@
  * buffers, making sure userspace applications are notified of the problem
  * instead of waiting forever.
  */
-int uvc_video_resume(struct uvc_video_device *video)
+int uvc_video_resume(struct uvc_streaming *stream)
 {
 	int ret;
 
-	video->frozen = 0;
+	stream->frozen = 0;
 
-	if ((ret = uvc_commit_video(video, &video->streaming->ctrl)) < 0) {
-		uvc_queue_enable(&video->queue, 0);
+	ret = uvc_commit_video(stream, &stream->ctrl);
+	if (ret < 0) {
+		uvc_queue_enable(&stream->queue, 0);
 		return ret;
 	}
 
-	if (!uvc_queue_streaming(&video->queue))
+	if (!uvc_queue_streaming(&stream->queue))
 		return 0;
 
-	if ((ret = uvc_init_video(video, GFP_NOIO)) < 0)
-		uvc_queue_enable(&video->queue, 0);
+	ret = uvc_init_video(stream, GFP_NOIO);
+	if (ret < 0)
+		uvc_queue_enable(&stream->queue, 0);
 
 	return ret;
 }
@@ -1046,47 +1057,53 @@
  *
  * This function is called before registering the device with V4L.
  */
-int uvc_video_init(struct uvc_video_device *video)
+int uvc_video_init(struct uvc_streaming *stream)
 {
-	struct uvc_streaming_control *probe = &video->streaming->ctrl;
+	struct uvc_streaming_control *probe = &stream->ctrl;
 	struct uvc_format *format = NULL;
 	struct uvc_frame *frame = NULL;
 	unsigned int i;
 	int ret;
 
-	if (video->streaming->nformats == 0) {
+	if (stream->nformats == 0) {
 		uvc_printk(KERN_INFO, "No supported video formats found.\n");
 		return -EINVAL;
 	}
 
+	atomic_set(&stream->active, 0);
+
+	/* Initialize the video buffers queue. */
+	uvc_queue_init(&stream->queue, stream->type);
+
 	/* Alternate setting 0 should be the default, yet the XBox Live Vision
 	 * Cam (and possibly other devices) crash or otherwise misbehave if
 	 * they don't receive a SET_INTERFACE request before any other video
 	 * control request.
 	 */
-	usb_set_interface(video->dev->udev, video->streaming->intfnum, 0);
+	usb_set_interface(stream->dev->udev, stream->intfnum, 0);
 
 	/* Set the streaming probe control with default streaming parameters
 	 * retrieved from the device. Webcams that don't suport GET_DEF
 	 * requests on the probe control will just keep their current streaming
 	 * parameters.
 	 */
-	if (uvc_get_video_ctrl(video, probe, 1, GET_DEF) == 0)
-		uvc_set_video_ctrl(video, probe, 1);
+	if (uvc_get_video_ctrl(stream, probe, 1, GET_DEF) == 0)
+		uvc_set_video_ctrl(stream, probe, 1);
 
 	/* Initialize the streaming parameters with the probe control current
 	 * value. This makes sure SET_CUR requests on the streaming commit
 	 * control will always use values retrieved from a successful GET_CUR
 	 * request on the probe control, as required by the UVC specification.
 	 */
-	if ((ret = uvc_get_video_ctrl(video, probe, 1, GET_CUR)) < 0)
+	ret = uvc_get_video_ctrl(stream, probe, 1, GET_CUR);
+	if (ret < 0)
 		return ret;
 
 	/* Check if the default format descriptor exists. Use the first
 	 * available format otherwise.
 	 */
-	for (i = video->streaming->nformats; i > 0; --i) {
-		format = &video->streaming->format[i-1];
+	for (i = stream->nformats; i > 0; --i) {
+		format = &stream->format[i-1];
 		if (format->index == probe->bFormatIndex)
 			break;
 	}
@@ -1111,21 +1128,20 @@
 	probe->bFormatIndex = format->index;
 	probe->bFrameIndex = frame->bFrameIndex;
 
-	video->streaming->cur_format = format;
-	video->streaming->cur_frame = frame;
-	atomic_set(&video->active, 0);
+	stream->cur_format = format;
+	stream->cur_frame = frame;
 
 	/* Select the video decoding function */
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		if (video->dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)
-			video->decode = uvc_video_decode_isight;
-		else if (video->streaming->intf->num_altsetting > 1)
-			video->decode = uvc_video_decode_isoc;
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		if (stream->dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)
+			stream->decode = uvc_video_decode_isight;
+		else if (stream->intf->num_altsetting > 1)
+			stream->decode = uvc_video_decode_isoc;
 		else
-			video->decode = uvc_video_decode_bulk;
+			stream->decode = uvc_video_decode_bulk;
 	} else {
-		if (video->streaming->intf->num_altsetting == 1)
-			video->decode = uvc_video_encode_bulk;
+		if (stream->intf->num_altsetting == 1)
+			stream->decode = uvc_video_encode_bulk;
 		else {
 			uvc_printk(KERN_INFO, "Isochronous endpoints are not "
 				"supported for video output devices.\n");
@@ -1139,31 +1155,32 @@
 /*
  * Enable or disable the video stream.
  */
-int uvc_video_enable(struct uvc_video_device *video, int enable)
+int uvc_video_enable(struct uvc_streaming *stream, int enable)
 {
 	int ret;
 
 	if (!enable) {
-		uvc_uninit_video(video, 1);
-		usb_set_interface(video->dev->udev,
-			video->streaming->intfnum, 0);
-		uvc_queue_enable(&video->queue, 0);
+		uvc_uninit_video(stream, 1);
+		usb_set_interface(stream->dev->udev, stream->intfnum, 0);
+		uvc_queue_enable(&stream->queue, 0);
 		return 0;
 	}
 
-	if ((video->streaming->cur_format->flags & UVC_FMT_FLAG_COMPRESSED) ||
+	if ((stream->cur_format->flags & UVC_FMT_FLAG_COMPRESSED) ||
 	    uvc_no_drop_param)
-		video->queue.flags &= ~UVC_QUEUE_DROP_INCOMPLETE;
+		stream->queue.flags &= ~UVC_QUEUE_DROP_INCOMPLETE;
 	else
-		video->queue.flags |= UVC_QUEUE_DROP_INCOMPLETE;
+		stream->queue.flags |= UVC_QUEUE_DROP_INCOMPLETE;
 
-	if ((ret = uvc_queue_enable(&video->queue, 1)) < 0)
+	ret = uvc_queue_enable(&stream->queue, 1);
+	if (ret < 0)
 		return ret;
 
 	/* Commit the streaming parameters. */
-	if ((ret = uvc_commit_video(video, &video->streaming->ctrl)) < 0)
+	ret = uvc_commit_video(stream, &stream->ctrl);
+	if (ret < 0)
 		return ret;
 
-	return uvc_init_video(video, GFP_KERNEL);
+	return uvc_init_video(stream, GFP_KERNEL);
 }
 
diff -r 50059a68c503 -r 88ef3b9f5071 linux/drivers/media/video/uvc/uvcvideo.h
--- a/linux/drivers/media/video/uvc/uvcvideo.h	Thu Jun 04 14:37:43 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvcvideo.h	Sun Jun 28 13:37:50 2009 +0200
@@ -519,26 +519,6 @@
 	__u8 bTriggerUsage;
 };
 
-struct uvc_streaming {
-	struct list_head list;
-
-	struct usb_interface *intf;
-	int intfnum;
-	__u16 maxpsize;
-
-	struct uvc_streaming_header header;
-	enum v4l2_buf_type type;
-
-	unsigned int nformats;
-	struct uvc_format *format;
-
-	struct uvc_streaming_control ctrl;
-	struct uvc_format *cur_format;
-	struct uvc_frame *cur_frame;
-
-	struct mutex mutex;
-};
-
 enum uvc_buffer_state {
 	UVC_BUF_STATE_IDLE	= 0,
 	UVC_BUF_STATE_QUEUED	= 1,
@@ -580,26 +560,31 @@
 	struct list_head irqqueue;
 };
 
-struct uvc_video_device {
+struct uvc_streaming {
+	struct list_head list;
 	struct uvc_device *dev;
 	struct video_device *vdev;
 	atomic_t active;
+
+	struct usb_interface *intf;
+	int intfnum;
+	__u16 maxpsize;
+
+	struct uvc_streaming_header header;
+	enum v4l2_buf_type type;
+
+	unsigned int nformats;
+	struct uvc_format *format;
+
+	struct uvc_streaming_control ctrl;
+	struct uvc_format *cur_format;
+	struct uvc_frame *cur_frame;
+
+	struct mutex mutex;
+
 	unsigned int frozen : 1;
-
-	struct list_head iterms;		/* Input terminals */
-	struct uvc_entity *oterm;		/* Output terminal */
-	struct uvc_entity *sterm;		/* USB streaming terminal */
-	struct uvc_entity *processing;
-	struct uvc_entity *selector;
-	struct list_head extensions;
-	struct mutex ctrl_mutex;
-
 	struct uvc_video_queue queue;
-
-	/* Video streaming object, must always be non-NULL. */
-	struct uvc_streaming *streaming;
-
-	void (*decode) (struct urb *urb, struct uvc_video_device *video,
+	void (*decode) (struct urb *urb, struct uvc_streaming *video,
 			struct uvc_buffer *buf);
 
 	/* Context data used by the bulk completion handler. */
@@ -619,6 +604,18 @@
 	__u8 last_fid;
 };
 
+struct uvc_video_device {
+	struct uvc_device *dev;
+
+	struct list_head iterms;		/* Input terminals */
+	struct uvc_entity *oterm;		/* Output terminal */
+	struct uvc_entity *sterm;		/* USB streaming terminal */
+	struct uvc_entity *processing;
+	struct uvc_entity *selector;
+	struct list_head extensions;
+	struct mutex ctrl_mutex;
+};
+
 enum uvc_device_state {
 	UVC_DEV_DISCONNECTED = 1,
 };
@@ -644,15 +641,15 @@
 
 	struct uvc_video_device video;
 
+	/* Video Streaming interfaces */
+	struct list_head streams;
+
 	/* Status Interrupt Endpoint */
 	struct usb_host_endpoint *int_ep;
 	struct urb *int_urb;
 	__u8 *status;
 	struct input_dev *input;
 	char input_phys[64];
-
-	/* Video Streaming interfaces */
-	struct list_head streaming;
 };
 
 enum uvc_handle_state {
@@ -661,7 +658,8 @@
 };
 
 struct uvc_fh {
-	struct uvc_video_device *device;
+	struct uvc_video_device *video;
+	struct uvc_streaming *stream;
 	enum uvc_handle_state state;
 };
 
@@ -758,13 +756,13 @@
 extern const struct v4l2_file_operations uvc_fops;
 
 /* Video */
-extern int uvc_video_init(struct uvc_video_device *video);
-extern int uvc_video_suspend(struct uvc_video_device *video);
-extern int uvc_video_resume(struct uvc_video_device *video);
-extern int uvc_video_enable(struct uvc_video_device *video, int enable);
-extern int uvc_probe_video(struct uvc_video_device *video,
+extern int uvc_video_init(struct uvc_streaming *stream);
+extern int uvc_video_suspend(struct uvc_streaming *stream);
+extern int uvc_video_resume(struct uvc_streaming *stream);
+extern int uvc_video_enable(struct uvc_streaming *stream, int enable);
+extern int uvc_probe_video(struct uvc_streaming *stream,
 		struct uvc_streaming_control *probe);
-extern int uvc_commit_video(struct uvc_video_device *video,
+extern int uvc_commit_video(struct uvc_streaming *stream,
 		struct uvc_streaming_control *ctrl);
 extern int uvc_query_ctrl(struct uvc_device *dev, __u8 query, __u8 unit,
 		__u8 intfnum, __u8 cs, void *data, __u16 size);
@@ -818,7 +816,7 @@
 		struct usb_host_interface *alts, __u8 epaddr);
 
 /* Quirks support */
-void uvc_video_decode_isight(struct urb *urb, struct uvc_video_device *video,
+void uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,
 		struct uvc_buffer *buf);
 
 #endif /* __KERNEL__ */



From mikiwoz at yahoo.co.uk  Thu Jul  2 02:46:53 2009
From: mikiwoz at yahoo.co.uk (=?utf-8?q?Micha=C5=82_Andrzej_Wo=C5=BAniak?=)
Date: Thu, 2 Jul 2009 02:46:53 +0200
Subject: [Linux-uvc-devel] CLI software to record video
In-Reply-To: <59cf47a80907011420s8ef6b49nba0f7bad904a0fbc@mail.gmail.com>
References: <FE9E9F08-F22F-472E-A553-52359DF157E3@luckyluke.org>
	<20090701210600.GA17768@sunshine.barsnick.net>
	<59cf47a80907011420s8ef6b49nba0f7bad904a0fbc@mail.gmail.com>
Message-ID: <200907020246.53664.mikiwoz@yahoo.co.uk>

Dnia ?roda 01 lipiec 2009, Paulo Assis napisa?(a):
> Hi,
>
> > > The _real_ problem is that video is never recorded at constant
> > > speed.
> >
> > That I have no experience with. My (pwc) Logitech QuickCam Pro 4000
> > exposes no such behavior. Has there ever been any solution to this,
> > to creating constant speed video files from non-constant FPS
> > /dev/video?
>
> This should only be a problem when using old containers like AVI.
> The matroska format uses timecodes for each frame, so video should be
> in sync whatever the fps of the device.
I have been using VLC (VideoLAN Player) to record video, both from various 
(3-4 different models) webcams - both UVC-compatible, and not - and from 
MiniDV camera through firewire.

VLC has some neat options so that you can use it without GUI, pure CLI.

Heck, I had even set-up impromptu encoding and streaming server with 
VLC! :)

Cheers
Mike aka rysiek


From joeborn at gmail.com  Thu Jul  2 05:19:37 2009
From: joeborn at gmail.com (Joe Born)
Date: Wed, 1 Jul 2009 22:19:37 -0500
Subject: [Linux-uvc-devel] Micro Innovations/Digital Innovations Webcam
Message-ID: <aa742dba0907012019k3ff05f1enc0f11a2e4cd0d3e5@mail.gmail.com>

Hi All,

I'm writing from Digital Innovations, and we'd like to donate samples
of our webcams to uvc devs in need.? Basically, I'm working on a
project to make sure that all our peripherals are supported for Linux
users.? Not the usual "check the serial number to ensure
compatibility" type thing, but well supported in linux out of the box
(and listed on the box).

We have an extensive line of peripherals, and I'm starting with
webcams.? see www.digitalinnovations.com for more information about
products or forums.digitalinnovations.com for, you guessed it, the
forums we just started for our products.? The webcams are not yet
listed on the store, but we do stock them.

Please feel free to reach out to me directly with question etc.

http://www.twitter.com/JoeBorn


From laurent.pinchart at skynet.be  Thu Jul  2 13:33:29 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 13:33:29 +0200
Subject: [Linux-uvc-devel] Setting camera priority
In-Reply-To: <9ad1ec5d0906280418o23f46f27ubf1c28d597ed89b3@mail.gmail.com>
References: <9ad1ec5d0906280418o23f46f27ubf1c28d597ed89b3@mail.gmail.com>
Message-ID: <200907021333.30236.laurent.pinchart@skynet.be>

Hi Enrico,

On Sunday 28 June 2009 13:18:18 Enrico Di Lello wrote:
> Hello everibody,
>
> I am currently working on integrating a camera on small robotic
> platform. The robot mounts a FoxBoard running an embedded 2.6.25 linux
> kernel. The camera I am using is a Logitech E3500, which works pretty
> much ok.  The camera is connected via a USB 1.1 port, so it looks like
> that, even setting a very low frame rate, 176x144 is the maximum
> resolution allowed for YUYV format.

Most cameras don't have any video frame buffer, so instead of sending

F------R------A------M------E------F------R------A------M------E

at low frame rates they just send

FRAME------------------------------FRAME------------------------

The required bandwidth is thus quite high during short bursts, making it 
impossible to stream high resolutions in uncompressed formats.

> Anyway, even thought my issue is not directly related to the uvcvideo
> driver, I hope that some of the people reading this newsletter could
> help.
>
> When grabbing frames, everything goes fine.
> The problem arises when trying to acquire frames and reading from a
> serial port (not necessarily at the same time). If one application is
> reading data from a serial port, it gets interrupted (pretty much
> randomly) after that another application does the VIDIOC_STREAMON
> ioctl call, even if it is not grabbing frames yet.

What do you mean by "gets interrupted" ?

> Probably the issue is related with the USB DMA configuration of the
> FoxBoard, but I would like to ask if it is possible to lower the
> priority that the linux scheduler assigns to the uvcdriver somehow, or
> have a little more detail about how the driver behaves in this
> context.

The Linux kernel scheduler assigns priorities to processes, not to drivers. 
The uvcvideo code is run either in userspace context (ioctl handlers for 
instance), in which case the code runs using the priority associated with the 
userspace process, or in interrupt context (URB completion handlers), in which 
case the concept of priority isn't really relevant, as the scheduler won't 
interfere with interrupts (except when using threaded interrupt handlers which 
are a very new and experimental feature).

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Thu Jul  2 13:51:14 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 13:51:14 +0200
Subject: [Linux-uvc-devel] CLI software to record video
In-Reply-To: <FE9E9F08-F22F-472E-A553-52359DF157E3@luckyluke.org>
References: <FE9E9F08-F22F-472E-A553-52359DF157E3@luckyluke.org>
Message-ID: <200907021351.15056.laurent.pinchart@skynet.be>

Hi Luca,

On Monday 29 June 2009 23:18:05 Luca Lesinigo wrote:
> Hello there.
>
> I spent some time googling around and looking at the list archives,
> but I cannot find a (non-X11) software that would let me do a 'simple'
> video recording without any fancy stuff or reencoding.
>
> I'm using a logitech S7500 for my tests, it's an UVC cam with support
> for MJPEG. I could use mencoder to record the 'raw' mjpeg stream
> without any re-encoding but that also means without audio: it
> segfaults if I try to record audio too (either from the cam usb audio
> source or from the alsa soundcard in the pc).
>
> I can still record audio in another process and mix everything
> afterwards, no big problem. The _real_ problem is that video is never
> recorded at constant speed. It probably depends on the camera varying
> the framerate (autoexposure or stuff like that, probably) and/or usb
> or the hci loosing some data here and there. But this is also not a
> problem (loosing frames) as long as I get a playable video. Too bad
> this is not the case: the actual speed will vary and some parts will
> be faster than others.
>
> I'm not an expert but I suspect this is due to the "timestamps not
> implemented" that I read on UVC homepage.

Implementing timestamps support shouldn't be extremely difficult, do you want 
to give it a try ? Many users will be thankful :-)

To be honest, I'm not sure if this would be enough to avoid all audio/video 
sync issues.

Both the audio and the video devices can suffer from data loss. Video frames 
can be corrupted or completely lost, and audio samples can be missed as well. 
To resynchronize the two streams in such a case, you need

1. to timestamp each video and audio sample (or groups of samples), and 
2. to use the timestamps during plyaback

The uvcvideo driver currently uses the system time to timestamp video frames. 
This is not a perfect solution but is probably accurate enough for most 
applications. Implementing timestamps support would provide a better accuracy 
in the timestamp value.

The usbaudio driver doesn't, as far as I know, timestamp audio data. If 
samples are lost, I don't think the driver will notice. You should ask the 
usbaudio developer(s) for confirmation.

As mentioned already in an answer to your mail, you will need to use a 
container that supports timestamps, otherwise the player will not be able to 
resynchronize audio and video.

> I'm working on a more-or-less embedded platform (the prototype
> actually is a notebook without any human operator and also without
> X11) and I'm looking for a software (or a combination of) that would
> let me:
> - set the cam to turn off fancy stuff and run as constant fps as it
> can - don't need ultrafast, 640x480 at 25fps would be enough
> - record the video with the lowest possible cpu usage - I think a
> direct MJPEG recording from the cam to file should be the best option
> - playback / reencode the video afterwards and get a 'constant wall
> clock speed' video (no problems if it looses frames as long as this is
> accounted for)
> - audio recording in the same file would be a bonus but not needed,
> alsarec is already doing its job
>
> I don't really need anything else, the system will start recording
> right after boot and keep on until power off. Right now I'm using the
> latest stable kernels from kernel.org, but applying any patch and
> recompiling is not a problem. If possible, I plan to stick to UVC
> cameras with MJPEG support, probably logitech ones.
> Any help would be really appreciated, thanks.

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Thu Jul  2 15:59:15 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 15:59:15 +0200
Subject: [Linux-uvc-devel] Micro Innovations/Digital Innovations Webcam
In-Reply-To: <aa742dba0907012019k3ff05f1enc0f11a2e4cd0d3e5@mail.gmail.com>
References: <aa742dba0907012019k3ff05f1enc0f11a2e4cd0d3e5@mail.gmail.com>
Message-ID: <200907021559.15944.laurent.pinchart@skynet.be>

Hi Joe,

On Thursday 02 July 2009 05:19:37 Joe Born wrote:
> Hi All,
>
> I'm writing from Digital Innovations, and we'd like to donate samples
> of our webcams to uvc devs in need.

First of all, thank you very much for supporting the Linux UVC driver project.

> Basically, I'm working on a project to make sure that all our peripherals
> are supported for Linux users.  Not the usual "check the serial number to
> ensure compatibility" type thing, but well supported in linux out of the box
> (and listed on the box).
>
> We have an extensive line of peripherals, and I'm starting with
> webcams.  see www.digitalinnovations.com for more information about
> products or forums.digitalinnovations.com for, you guessed it, the
> forums we just started for our products.  The webcams are not yet
> listed on the store, but we do stock them.
>
> Please feel free to reach out to me directly with question etc.

Most webcams are nowadays supported out of the box by the Linux UVC driver. 
Common problems come from

- webcam firmware/hardware bugs that require workarounds in the driver or, 
worse, can't be worked around at all

- multimedia integration in Linux (or lack thereof), and various bug in 
applications that make the user experience rather shaky

Depending on how serious the FW/HW bug is, problems in the first category can 
be fixed remotely or require access to the hardware. I could definitely use 
hardware samples to (try and) fix the most serious ones.

Some cameras also have bugs that can't be easily worked around. For instance, 
I've received reports of webcams that had a bad auto-exposure algorithm that 
got stuck in very low-exposure mode, making the image extremely dark. There's 
not much the host software can do about that.

Fixing application bugs and improving multimedia integration doesn't usually 
require access to every webcam model. What is needed there is a few developers 
with free time and access to a few webcams. Providing hardware samples can 
definitely help.

Obviously, bugs in proprietary applications (such as Skype) can not be fixed 
by open-source developers. The end-user might feel that a particular webcam 
model is "crap because it doesn't work with Skype", but little can be done 
about that if Skype is at fault.

How many different webcam models do you plan to sell ? Do you plan to perform 
some basic testing yourself and provide hardware samples to developers when 
problems are detected, or would you prefer to donate hardware samples for all 
models to someone who would test them all ?

Best regards,

Laurent Pinchart



From lescopc at esiee.fr  Thu Jul  2 17:34:04 2009
From: lescopc at esiee.fr (lescopc at esiee.fr)
Date: Thu, 2 Jul 2009 17:34:04 +0200 (CEST)
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
 interfaces support
In-Reply-To: <200907020131.34726.laurent.pinchart@skynet.be>
References: <200907020130.10001.laurent.pinchart@skynet.be>
	<200907020131.34726.laurent.pinchart@skynet.be>
Message-ID: <57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>

Hello everyone,

I am trying to stream with 2 webcams simultaneously so I tried your patch.
The thing is I am not that good with Linux so.... didn't work. Here what I
did:

**I downloaded your source from:
http://linuxtv.org/hg/~pinchartl/uvcvideo/


**I copied/pasted the content of this mail and the second one started from:

diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_ctrl.c

till the end to files that I named patchOne.diff and patchTwo.diff

**Then, in a terminal, I went to:
uvcvideo-bff77ec33116/linux/drivers/media/video/uvc

**I did:
patch <patchOne.diff

It did not changed the content of the original files and I got:
patching file uvc_driver.c
Hunk #1 FAILED at 551.
Hunk #2 FAILED at 752.
Hunk #3 FAILED at 1167.
Hunk #5 FAILED at 1494.
Hunk #6 FAILED at 1515.
Hunk #7 FAILED at 1530.
Hunk #8 FAILED at 1568.
Hunk #9 FAILED at 1602.
Hunk #10 FAILED at 1643.
Hunk #11 FAILED at 1697.
Hunk #12 FAILED at 1706.
Hunk #13 FAILED at 1735.
12 out of 13 hunks FAILED -- saving rejects to file uvc_driver.c.rej
patching file uvc_isight.c
Hunk #1 FAILED at 99.
Hunk #2 FAILED at 120.
etc...

Can anyone tell me what I am doing wrong?
Regards,


LESCOP C?dric




On Thu, July 2, 2009 01:31, Laurent Pinchart wrote:
> Restructure the UVC descriptors parsing code to handle multiple streaming
>  interfaces. The driver now creates a uvc_video_chain instance for each
> chain detected in the UVC control interface descriptors, and tries to
> register one video device per streaming endpoint.
>
> Priority: normal
>
>
> Signed-off-by: Laurent Pinchart <laurent.pinchart at skynet.be>
>
>
> diff -r 88ef3b9f5071 -r 012e480c8e6a
> linux/drivers/media/video/uvc/uvc_ctrl.c ---
> a/linux/drivers/media/video/uvc/uvc_ctrl.c	Sun Jun 28 13:37:50 2009 +0200
>  +++ b/linux/drivers/media/video/uvc/uvc_ctrl.c	Thu Jul 02 01:24:47 2009
> +0200
> @@ -731,7 +731,7 @@
> }
> }
>
>
> -struct uvc_control *uvc_find_control(struct uvc_video_device *video,
> +struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
> __u32 v4l2_id, struct uvc_control_mapping **mapping)
> {
> struct uvc_control *ctrl = NULL; @@ -744,17 +744,17 @@
> v4l2_id &= V4L2_CTRL_ID_MASK;
>
> /* Find the control. */
> -	__uvc_find_control(video->processing, v4l2_id, mapping, &ctrl, next);
> +	__uvc_find_control(chain->processing, v4l2_id, mapping, &ctrl, next);
> if (ctrl && !next) return ctrl;
>
> -	list_for_each_entry(entity, &video->iterms, chain) {
> +	list_for_each_entry(entity, &chain->iterms, chain) {
> __uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
> if (ctrl && !next) return ctrl; }
>
>
> -	list_for_each_entry(entity, &video->extensions, chain) {
> +	list_for_each_entry(entity, &chain->extensions, chain) {
> __uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
> if (ctrl && !next) return ctrl; @@ -767,7 +767,7 @@
> return ctrl; }
>
>
> -int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
> +int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
> struct v4l2_queryctrl *v4l2_ctrl) {
> struct uvc_control *ctrl; @@ -777,7 +777,7 @@
> __u8 *data;
> int ret;
>
> -	ctrl = uvc_find_control(video, v4l2_ctrl->id, &mapping);
> +	ctrl = uvc_find_control(chain, v4l2_ctrl->id, &mapping);
> if (ctrl == NULL) return -EINVAL;
>
> @@ -795,9 +795,10 @@
> v4l2_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
>
> if (ctrl->info->flags & UVC_CONTROL_GET_DEF) { -		if ((ret =
> uvc_query_ctrl(video->dev, GET_DEF, ctrl->entity->id, -
> video->dev->intfnum, ctrl->info->selector, -				data, ctrl->info->size)) <
> 0)
> +		ret = uvc_query_ctrl(chain->dev, GET_DEF, ctrl->entity->id,
> +				     chain->dev->intfnum, ctrl->info->selector,
> +				     data, ctrl->info->size);
> +		if (ret < 0)
> goto out; v4l2_ctrl->default_value = mapping->get(mapping, GET_DEF,
data); }
>  @@ -831,23 +832,26 @@
> }
>
>
> if (ctrl->info->flags & UVC_CONTROL_GET_MIN) { -		if ((ret =
> uvc_query_ctrl(video->dev, GET_MIN, ctrl->entity->id, -
> video->dev->intfnum, ctrl->info->selector, -				data, ctrl->info->size)) <
> 0)
> +		ret = uvc_query_ctrl(chain->dev, GET_MIN, ctrl->entity->id,
> +				     chain->dev->intfnum, ctrl->info->selector,
> +				     data, ctrl->info->size);
> +		if (ret < 0)
> goto out; v4l2_ctrl->minimum = mapping->get(mapping, GET_MIN, data); }
> if (ctrl->info->flags & UVC_CONTROL_GET_MAX) { -		if ((ret =
> uvc_query_ctrl(video->dev, GET_MAX, ctrl->entity->id, -
> video->dev->intfnum, ctrl->info->selector, -				data, ctrl->info->size)) <
> 0)
> +		ret = uvc_query_ctrl(chain->dev, GET_MAX, ctrl->entity->id,
> +				     chain->dev->intfnum, ctrl->info->selector,
> +				     data, ctrl->info->size);
> +		if (ret < 0)
> goto out; v4l2_ctrl->maximum = mapping->get(mapping, GET_MAX, data); }
> if (ctrl->info->flags & UVC_CONTROL_GET_RES) { -		if ((ret =
> uvc_query_ctrl(video->dev, GET_RES, ctrl->entity->id, -
> video->dev->intfnum, ctrl->info->selector, -				data, ctrl->info->size)) <
> 0)
> +		ret = uvc_query_ctrl(chain->dev, GET_RES, ctrl->entity->id,
> +				     chain->dev->intfnum, ctrl->info->selector,
> +				     data, ctrl->info->size);
> +		if (ret < 0)
> goto out; v4l2_ctrl->step = mapping->get(mapping, GET_RES, data); }
> @@ -883,9 +887,9 @@
> * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release
> the * control lock.
> */
> -int uvc_ctrl_begin(struct uvc_video_device *video)
> +int uvc_ctrl_begin(struct uvc_video_chain *chain)
> {
> -	return mutex_lock_interruptible(&video->ctrl_mutex) ? -ERESTARTSYS : 0;
> +	return mutex_lock_interruptible(&chain->ctrl_mutex) ? -ERESTARTSYS : 0;
> }
>
>
> static int uvc_ctrl_commit_entity(struct uvc_device *dev, @@ -935,34
> +939,34 @@
> return 0; }
>
>
> -int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
> +int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
> {
> struct uvc_entity *entity; int ret = 0;
>
> /* Find the control. */
> -	ret = uvc_ctrl_commit_entity(video->dev, video->processing, rollback);
> +	ret = uvc_ctrl_commit_entity(chain->dev, chain->processing, rollback);
> if (ret < 0) goto done;
>
> -	list_for_each_entry(entity, &video->iterms, chain) {
> -		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
> +	list_for_each_entry(entity, &chain->iterms, chain) {
> +		ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
> if (ret < 0) goto done; }
>
>
> -	list_for_each_entry(entity, &video->extensions, chain) {
> -		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
> +	list_for_each_entry(entity, &chain->extensions, chain) {
> +		ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
> if (ret < 0) goto done; }
>
>
> done:
> -	mutex_unlock(&video->ctrl_mutex);
> +	mutex_unlock(&chain->ctrl_mutex);
> return ret; }
>
>
> -int uvc_ctrl_get(struct uvc_video_device *video,
> +int uvc_ctrl_get(struct uvc_video_chain *chain,
> struct v4l2_ext_control *xctrl) {
> struct uvc_control *ctrl; @@ -971,13 +975,13 @@
> unsigned int i; int ret;
>
> -	ctrl = uvc_find_control(video, xctrl->id, &mapping);
> +	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
> if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_GET_CUR) == 0) return
> -EINVAL;
>
>
> if (!ctrl->loaded) { -		ret = uvc_query_ctrl(video->dev, GET_CUR,
> ctrl->entity->id, -				video->dev->intfnum, ctrl->info->selector,
> +		ret = uvc_query_ctrl(chain->dev, GET_CUR, ctrl->entity->id,
> +				chain->dev->intfnum, ctrl->info->selector,
> uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), ctrl->info->size); if (ret < 0)
> @@ -1002,7 +1006,7 @@
> return 0; }
>
>
> -int uvc_ctrl_set(struct uvc_video_device *video,
> +int uvc_ctrl_set(struct uvc_video_chain *chain,
> struct v4l2_ext_control *xctrl) {
> struct uvc_control *ctrl; @@ -1010,7 +1014,7 @@
> s32 value = xctrl->value; int ret;
>
> -	ctrl = uvc_find_control(video, xctrl->id, &mapping);
> +	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
> if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_SET_CUR) == 0) return
> -EINVAL;
>
>
> @@ -1025,8 +1029,8 @@
> memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), 0, ctrl->info->size);
> } else {
> -			ret = uvc_query_ctrl(video->dev, GET_CUR,
> -				ctrl->entity->id, video->dev->intfnum,
> +			ret = uvc_query_ctrl(chain->dev, GET_CUR,
> +				ctrl->entity->id, chain->dev->intfnum,
> ctrl->info->selector, uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
> ctrl->info->size); @@ -1055,7 +1059,7 @@
> * Dynamic controls
> */
>
>
> -int uvc_xu_ctrl_query(struct uvc_video_device *video,
> +int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
> struct uvc_xu_control *xctrl, int set) {
> struct uvc_entity *entity; @@ -1065,7 +1069,7 @@
> int ret;
>
> /* Find the extension unit. */
> -	list_for_each_entry(entity, &video->extensions, chain) {
> +	list_for_each_entry(entity, &chain->extensions, chain) {
> if (entity->id == xctrl->unit) break; }
> @@ -1104,7 +1108,7 @@
> (!set && !(ctrl->info->flags & UVC_CONTROL_GET_CUR)))
> return -EINVAL;
>
> -	if (mutex_lock_interruptible(&video->ctrl_mutex))
> +	if (mutex_lock_interruptible(&chain->ctrl_mutex))
> return -ERESTARTSYS;
>
> memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), @@ -1117,8 +1121,8 @@
> goto out; }
>
>
> -	ret = uvc_query_ctrl(video->dev, set ? SET_CUR : GET_CUR, xctrl->unit,
> -			     video->dev->intfnum, xctrl->selector, data,
> +	ret = uvc_query_ctrl(chain->dev, set ? SET_CUR : GET_CUR, xctrl->unit,
> +			     chain->dev->intfnum, xctrl->selector, data,
> xctrl->size); if (ret < 0) goto out; @@ -1134,7 +1138,7 @@
> uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), xctrl->size);
>
> -	mutex_unlock(&video->ctrl_mutex);
> +	mutex_unlock(&chain->ctrl_mutex);
> return ret; }
>
>
> diff -r 88ef3b9f5071 -r 012e480c8e6a
> linux/drivers/media/video/uvc/uvc_driver.c ---
> a/linux/drivers/media/video/uvc/uvc_driver.c	Sun Jun 28 13:37:50 2009
> +0200
> +++ b/linux/drivers/media/video/uvc/uvc_driver.c	Thu Jul 02 01:24:47 2009
> +0200
> @@ -276,8 +276,20 @@
> return NULL; }
>
>
> +static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev,
> int id) +{
> +	struct uvc_streaming *stream;
> +
> +	list_for_each_entry(stream, &dev->streams, list) {
> +		if (stream->header.bTerminalLink == id)
> +			return stream;
> +	}
> +
> +	return NULL;
> +}
> +
> /*
> ------------------------------------------------------------------------
> - * Descriptors handling
> + * Descriptors parsing
> */
>
>
> static int uvc_parse_format(struct uvc_device *dev, @@ -1159,101 +1171,36
> @@
> }
>
>
> /*
> ------------------------------------------------------------------------
> - * USB probe and disconnect
> + * UVC device scan
> */
>
>
> /*
> - * Unregister the video devices.
> - */
> -static void uvc_unregister_video(struct uvc_device *dev)
> -{
> -	struct uvc_streaming *streaming;
> -
> -	list_for_each_entry(streaming, &dev->streams, list) {
> -		if (streaming->vdev == NULL)
> -			continue;
> -
> -		if (streaming->vdev->minor == -1)
> -			video_device_release(streaming->vdev);
> -		else
> -			video_unregister_device(streaming->vdev);
> -		streaming->vdev = NULL;
> -	}
> -}
> -
> -static int uvc_register_video(struct uvc_device *dev,
> -		struct uvc_streaming *stream)
> -{
> -	struct video_device *vdev;
> -	struct uvc_entity *term;
> -	int ret;
> -
> -	if (uvc_trace_param & UVC_TRACE_PROBE) {
> -		uvc_printk(KERN_INFO, "Found a valid video chain (");
> -		list_for_each_entry(term, &dev->video.iterms, chain) {
> -			printk("%d", term->id);
> -			if (term->chain.next != &dev->video.iterms)
> -				printk(",");
> -		}
> -		printk(" -> %d).\n", dev->video.oterm->id);
> -	}
> -
> -	/* Initialize the streaming interface with default streaming
> -	 * parameters.
> -	 */
> -	ret = uvc_video_init(stream);
> -	if (ret < 0) {
> -		uvc_printk(KERN_ERR, "Failed to initialize the device "
> -			"(%d).\n", ret);
> -		return ret;
> -	}
> -
> -	/* Register the device with V4L. */
> -	vdev = video_device_alloc();
> -	if (vdev == NULL)
> -		return -1;
> -
> -	/* We already hold a reference to dev->udev. The video device will be
> -	 * unregistered before the reference is released, so we don't need to
> -	 * get another one.
> -	 */
> -	vdev->parent = &dev->intf->dev;
> -	vdev->minor = -1;
> -	vdev->fops = &uvc_fops;
> -	vdev->release = video_device_release;
> -	strlcpy(vdev->name, dev->name, sizeof vdev->name);
> -
> -	/* Set the driver data before calling video_register_device, otherwise
> -	 * uvc_v4l2_open might race us.
> -	 */
> -	stream->vdev = vdev;
> -	video_set_drvdata(vdev, stream);
> -
> -	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
> -		stream->vdev = NULL;
> -		video_device_release(vdev);
> -		return -1;
> -	}
> -
> -	return 0;
> -}
> -
> -/*
> * Scan the UVC descriptors to locate a chain starting at an Output
> Terminal
> * and containing the following units:
> *
> - * - one Output Terminal (USB Streaming or Display)
> + * - one or more Output Terminals (USB Streaming or Display)
> * - zero or one Processing Unit
> - * - zero, one or mode single-input Selector Units
> + * - zero, one or more single-input Selector Units
> * - zero or one multiple-input Selector Units, provided all inputs are
> *   connected to input terminals
> * - zero, one or mode single-input Extension Units
> * - one or more Input Terminals (Camera, External or USB Streaming)
> *
> - * A side forward scan is made on each detected entity to check for
> additional - * extension units.
> + * The terminal and units must match on of the following structures:
> + *
> + * ITT_*(0) -> +---------+    +---------+    +---------+ ->
> TT_STREAMING(0)
> + * ...         | SU{0,1} | -> | PU{0,1} | -> | XU{0,n} |    ...
> + * ITT_*(n) -> +---------+    +---------+    +---------+ ->
> TT_STREAMING(n)
> + *
> + *                 +---------+    +---------+ -> OTT_*(0)
> + * TT_STREAMING -> | PU{0,1} | -> | XU{0,n} |    ...
> + *                 +---------+    +---------+ -> OTT_*(n)
> + *
> + * The Processing Unit and Extension Units can be in any order.
> Additional
> + * Extension Units connected to the main chain as single-unit branches
> are + * also supported. Single-input Selector Units are ignored.
> */
> -static int uvc_scan_chain_entity(struct uvc_video_device *video,
> +static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
> struct uvc_entity *entity) {
> switch (UVC_ENTITY_TYPE(entity)) { @@ -1267,20 +1214,20 @@
> return -1; }
>
>
> -		list_add_tail(&entity->chain, &video->extensions);
> +		list_add_tail(&entity->chain, &chain->extensions);
> break;
>
> case VC_PROCESSING_UNIT: if (uvc_trace_param & UVC_TRACE_PROBE) printk(" <-
> PU %d", entity->id);
>
>
> -		if (video->processing != NULL) {
> +		if (chain->processing != NULL) {
> uvc_trace(UVC_TRACE_DESCR, "Found multiple " "Processing Units in
> chain.\n"); return -1; }
>
>
> -		video->processing = entity;
> +		chain->processing = entity;
> break;
>
> case VC_SELECTOR_UNIT: @@ -1291,13 +1238,13 @@
> if (entity->selector.bNrInPins == 1) break;
>
> -		if (video->selector != NULL) {
> +		if (chain->selector != NULL) {
> uvc_trace(UVC_TRACE_DESCR, "Found multiple Selector " "Units in chain.\n");
>  return -1; }
>
>
> -		video->selector = entity;
> +		chain->selector = entity;
> break;
>
> case ITT_VENDOR_SPECIFIC: @@ -1306,7 +1253,7 @@
> if (uvc_trace_param & UVC_TRACE_PROBE) printk(" <- IT %d\n", entity->id);
>
> -		list_add_tail(&entity->chain, &video->iterms);
> +		list_add_tail(&entity->chain, &chain->iterms);
> break;
>
> case TT_STREAMING: @@ -1319,14 +1266,7 @@
> return -1; }
>
>
> -		if (video->sterm != NULL) {
> -			uvc_trace(UVC_TRACE_DESCR, "Found multiple streaming "
> -				"entities in chain.\n");
> -			return -1;
> -		}
> -
> -		list_add_tail(&entity->chain, &video->iterms);
> -		video->sterm = entity;
> +		list_add_tail(&entity->chain, &chain->iterms);
> break;
>
> default:
> @@ -1338,7 +1278,7 @@
> return 0; }
>
>
> -static int uvc_scan_chain_forward(struct uvc_video_device *video,
> +static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
> struct uvc_entity *entity, struct uvc_entity *prev) {
> struct uvc_entity *forward; @@ -1349,28 +1289,51 @@
> found = 0;
>
> while (1) { -		forward = uvc_entity_by_reference(video->dev, entity->id,
> +		forward = uvc_entity_by_reference(chain->dev, entity->id,
> forward); if (forward == NULL) break; -
> -		if (UVC_ENTITY_TYPE(forward) != VC_EXTENSION_UNIT ||
> -		    forward == prev)
> +		if (forward == prev)
> continue;
>
> -		if (forward->extension.bNrInPins != 1) {
> -			uvc_trace(UVC_TRACE_DESCR, "Extension unit %d has "
> -				"more than 1 input pin.\n", entity->id);
> -			return -1;
> -		}
> +		switch (UVC_ENTITY_TYPE(forward)) {
> +		case VC_EXTENSION_UNIT:
> +			if (forward->extension.bNrInPins != 1) {
> +				uvc_trace(UVC_TRACE_DESCR, "Extension unit %d "
> +					  "has more than 1 input pin.\n",
> +					  entity->id);
> +				return -EINVAL;
> +			}
>
>
> -		list_add_tail(&forward->chain, &video->extensions);
> -		if (uvc_trace_param & UVC_TRACE_PROBE) {
> -			if (!found)
> -				printk(" (-> XU");
> +			list_add_tail(&forward->chain, &chain->extensions);
> +			if (uvc_trace_param & UVC_TRACE_PROBE) {
> +				if (!found)
> +					printk(" (->");
>
>
> -			printk(" %d", forward->id);
> -			found = 1;
> +				printk(" XU %d", forward->id);
> +				found = 1;
> +			}
> +			break;
> +
> +		case OTT_VENDOR_SPECIFIC:
> +		case OTT_DISPLAY:
> +		case OTT_MEDIA_TRANSPORT_OUTPUT:
> +		case TT_STREAMING:
> +			if (UVC_ENTITY_IS_ITERM(forward)) {
> +				uvc_trace(UVC_TRACE_DESCR, "Unsupported input "
> +					"terminal %u.\n", forward->id);
> +				return -EINVAL;
> +			}
> +
> +			list_add_tail(&forward->chain, &chain->oterms);
> +			if (uvc_trace_param & UVC_TRACE_PROBE) {
> +				if (!found)
> +					printk(" (->");
> +
> +				printk(" OT %d", forward->id);
> +				found = 1;
> +			}
> +			break;
> }
> }
> if (found) @@ -1379,7 +1342,7 @@
> return 0; }
>
>
> -static int uvc_scan_chain_backward(struct uvc_video_device *video,
> +static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
> struct uvc_entity *entity) {
> struct uvc_entity *term; @@ -1404,10 +1367,10 @@
> if (uvc_trace_param & UVC_TRACE_PROBE) printk(" <- IT");
>
> -		video->selector = entity;
> +		chain->selector = entity;
> for (i = 0; i < entity->selector.bNrInPins; ++i) { id =
> entity->selector.baSourceID[i]; -			term = uvc_entity_by_id(video->dev,
> id); +			term = uvc_entity_by_id(chain->dev, id);
> if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
> uvc_trace(UVC_TRACE_DESCR, "Selector unit %d " "input %d isn't connected
> to an " @@ -1418,8 +1381,8 @@
> if (uvc_trace_param & UVC_TRACE_PROBE) printk(" %d", term->id);
>
> -			list_add_tail(&term->chain, &video->iterms);
> -			uvc_scan_chain_forward(video, term, entity);
> +			list_add_tail(&term->chain, &chain->iterms);
> +			uvc_scan_chain_forward(chain, term, entity);
> }
>
>
> if (uvc_trace_param & UVC_TRACE_PROBE) @@ -1432,108 +1395,264 @@
> return id; }
>
>
> -static int uvc_scan_chain(struct uvc_video_device *video)
> +static int uvc_scan_chain(struct uvc_video_chain *chain,
> +			  struct uvc_entity *oterm)
> {
> struct uvc_entity *entity, *prev; int id;
>
> -	entity = video->oterm;
> +	entity = oterm;
> +	list_add_tail(&entity->chain, &chain->oterms);
> uvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain: OT %d", entity->id);
>
> -	if (UVC_ENTITY_TYPE(entity) == TT_STREAMING)
> -		video->sterm = entity;
> -
> id = entity->output.bSourceID; while (id != 0) { prev = entity; -		entity =
> uvc_entity_by_id(video->dev, id); +		entity = uvc_entity_by_id(chain->dev,
> id); if (entity == NULL) { uvc_trace(UVC_TRACE_DESCR, "Found reference to "
>  "unknown entity %d.\n", id);
> -			return -1;
> +			return -EINVAL;
> +		}
> +
> +		if (entity->chain.next || entity->chain.prev) {
> +			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
> +				"entity %d already in chain.\n", id);
> +			return -EINVAL;
> }
>
>
> /* Process entity */
> -		if (uvc_scan_chain_entity(video, entity) < 0)
> -			return -1;
> +		if (uvc_scan_chain_entity(chain, entity) < 0)
> +			return -EINVAL;
>
>
> /* Forward scan */
> -		if (uvc_scan_chain_forward(video, entity, prev) < 0)
> -			return -1;
> +		if (uvc_scan_chain_forward(chain, entity, prev) < 0)
> +			return -EINVAL;
>
>
> /* Stop when a terminal is found. */
> -		if (!UVC_ENTITY_IS_UNIT(entity))
> +		if (UVC_ENTITY_IS_TERM(entity))
> break;
>
> /* Backward scan */
> -		id = uvc_scan_chain_backward(video, entity);
> +		id = uvc_scan_chain_backward(chain, entity);
> if (id < 0) return id; }
>
>
> -	if (video->sterm == NULL) {
> -		uvc_trace(UVC_TRACE_DESCR, "No streaming entity found in "
> -			"chain.\n");
> +	return 0;
> +}
> +
> +static unsigned int uvc_print_terms(struct list_head *terms, char
> *buffer)
> +{
> +	struct uvc_entity *term;
> +	unsigned int nterms = 0;
> +	char *p = buffer;
> +
> +	list_for_each_entry(term, terms, chain) {
> +		p += sprintf(p, "%u", term->id);
> +		if (term->chain.next != terms) {
> +			p += sprintf(p, ",");
> +			if (++nterms >= 4) {
> +				p += sprintf(p, "...");
> +				break;
> +			}
> +		}
> +	}
> +
> +	return p - buffer;
> +}
> +
> +static const char *uvc_print_chain(struct uvc_video_chain *chain)
> +{
> +	static char buffer[43];
> +	char *p = buffer;
> +
> +	p += uvc_print_terms(&chain->iterms, p);
> +	p += sprintf(p, " -> ");
> +	uvc_print_terms(&chain->oterms, p);
> +
> +	return buffer;
> +}
> +
> +/*
> + * Scan the device for video chains and register video devices.
> + *
> + * Chains are scanned starting at their output terminals and walked
> backwards. + */
> +static int uvc_scan_device(struct uvc_device *dev)
> +{
> +	struct uvc_video_chain *chain;
> +	struct uvc_entity *term;
> +
> +	list_for_each_entry(term, &dev->entities, list) {
> +		if (!UVC_ENTITY_IS_OTERM(term))
> +			continue;
> +
> +		/* If the terminal is already included in a chain, skip it.
> +		 * This can happen for chains that have multiple output
> +		 * terminals, where all output terminals beside the first one
> +		 * will be inserted in the chain in forward scans.
> +		 */
> +		if (term->chain.next || term->chain.prev)
> +			continue;
> +
> +		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
> +		if (chain == NULL)
> +			return -ENOMEM;
> +
> +		INIT_LIST_HEAD(&chain->iterms);
> +		INIT_LIST_HEAD(&chain->oterms);
> +		INIT_LIST_HEAD(&chain->extensions);
> +		mutex_init(&chain->ctrl_mutex);
> +		chain->dev = dev;
> +
> +		if (uvc_scan_chain(chain, term) < 0) {
> +			kfree(chain);
> +			continue;
> +		}
> +
> +		uvc_trace(UVC_TRACE_PROBE, "Found a valid video chain (%s).\n",
> +			  uvc_print_chain(chain));
> +
> +		list_add_tail(&chain->list, &dev->chains);
> +	}
> +
> +	if (list_empty(&dev->chains)) {
> +		uvc_printk(KERN_INFO, "No valid video chain found.\n");
> return -1; }
>
>
> return 0; }
>
>
> +/*
> ------------------------------------------------------------------------
> + * Video device registration and unregistration
> + */
> +
> /*
> - * Scan the device for video chains and register video devices.
> - *
> - * The driver currently supports a single video device per control
> interface - * only. The terminal and units must match the following
> structure:
> - *
> - * ITT_* -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> TT_STREAMING
> - * TT_STREAMING -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> OTT_*
> - *
> - * The Extension Units, if present, must have a single input pin. The
> - * Processing Unit and Extension Units can be in any order. Additional
> - * Extension Units connected to the main chain as single-unit branches
> are - * also supported.
> + * Unregister the video devices.
> */
> -static int uvc_scan_device(struct uvc_device *dev)
> +static void uvc_unregister_video(struct uvc_device *dev)
> {
> -	struct uvc_entity *term;
> -	int found = 0;
> +	struct uvc_streaming *stream;
>
>
> -	/* Check if the control interface matches the structure we expect. */
> -	list_for_each_entry(term, &dev->entities, list) {
> -		struct uvc_streaming *stream;
> -
> -		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
> +	list_for_each_entry(stream, &dev->streams, list) {
> +		if (stream->vdev == NULL)
> continue;
>
> -		memset(&dev->video, 0, sizeof dev->video);
> -		mutex_init(&dev->video.ctrl_mutex);
> -		INIT_LIST_HEAD(&dev->video.iterms);
> -		INIT_LIST_HEAD(&dev->video.extensions);
> -		dev->video.oterm = term;
> -		dev->video.dev = dev;
> -		if (uvc_scan_chain(&dev->video) < 0)
> -			continue;
> +		if (stream->vdev->minor == -1)
> +			video_device_release(stream->vdev);
> +		else
> +			video_unregister_device(stream->vdev);
> +		stream->vdev = NULL;
> +	}
> +}
>
>
> -		list_for_each_entry(stream, &dev->streams, list) {
> -			if (stream->header.bTerminalLink ==
> -			    dev->video.sterm->id) {
> -				uvc_register_video(dev, stream);
> -				found = 1;
> -				break;
> -			}
> -		}
> +static int uvc_register_video(struct uvc_device *dev,
> +		struct uvc_streaming *stream)
> +{
> +	struct video_device *vdev;
> +	int ret;
> +
> +	/* Initialize the streaming interface with default streaming
> +	 * parameters.
> +	 */
> +	ret = uvc_video_init(stream);
> +	if (ret < 0) {
> +		uvc_printk(KERN_ERR, "Failed to initialize the device "
> +			"(%d).\n", ret);
> +		return ret;
> }
>
>
> -	if (!found) {
> -		uvc_printk(KERN_INFO, "No valid video chain found.\n");
> -		return -1;
> +	/* Register the device with V4L. */
> +	vdev = video_device_alloc();
> +	if (vdev == NULL) {
> +		uvc_printk(KERN_ERR, "Failed to allocate video device (%d).\n",
> +			   ret);
> +		return -ENOMEM;
> +	}
> +
> +	/* We already hold a reference to dev->udev. The video device will be
> +	 * unregistered before the reference is released, so we don't need to
> +	 * get another one.
> +	 */
> +	vdev->parent = &dev->intf->dev;
> +	vdev->minor = -1;
> +	vdev->fops = &uvc_fops;
> +	vdev->release = video_device_release;
> +	strlcpy(vdev->name, dev->name, sizeof vdev->name);
> +
> +	/* Set the driver data before calling video_register_device, otherwise
> +	 * uvc_v4l2_open might race us.
> +	 */
> +	stream->vdev = vdev;
> +	video_set_drvdata(vdev, stream);
> +
> +	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
> +	if (ret < 0) {
> +		uvc_printk(KERN_ERR, "Failed to register video device (%d).\n",
> +			   ret);
> +		stream->vdev = NULL;
> +		video_device_release(vdev);
> +		return ret;
> }
>
>
> return 0; }
>
>
> /*
> + * Register all video devices in all chains.
> + */
> +static int uvc_register_terms(struct uvc_device *dev,
> +	struct uvc_video_chain *chain, struct list_head *terms)
> +{
> +	struct uvc_streaming *stream;
> +	struct uvc_entity *term;
> +	int ret;
> +
> +	list_for_each_entry(term, terms, chain) {
> +		if (UVC_ENTITY_TYPE(term) != TT_STREAMING)
> +			continue;
> +
> +		stream = uvc_stream_by_id(dev, term->id);
> +		if (stream == NULL) {
> +			uvc_printk(KERN_INFO, "No streaming interface found "
> +				   "for terminal %u.", term->id);
> +			continue;
> +		}
> +
> +		stream->chain = chain;
> +		ret = uvc_register_video(dev, stream);
> +		if (ret < 0)
> +			return ret;
> +	}
> +
> +	return 0;
> +}
> +
> +static int uvc_register_chains(struct uvc_device *dev)
> +{
> +	struct uvc_video_chain *chain;
> +	int ret;
> +
> +	list_for_each_entry(chain, &dev->chains, list) {
> +		ret = uvc_register_terms(dev, chain, &chain->iterms);
> +		if (ret < 0)
> +			return ret;
> +
> +		ret = uvc_register_terms(dev, chain, &chain->oterms);
> +		if (ret < 0)
> +			return ret;
> +	}
> +
> +	return 0;
> +}
> +
> +/*
> ------------------------------------------------------------------------
> + * USB probe, disconnect, suspend and resume
> + */
> +
> +/*
> * Delete the UVC device.
> *
> * Called by the kernel when the last reference to the uvc_device structure
>  @@ -1554,7 +1673,7 @@
> struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
> struct list_head *p, *n;
>
> -	/* Unregister the video device. */
> +	/* Unregister the video devices. */
> uvc_unregister_video(dev); usb_put_intf(dev->intf); usb_put_dev(dev->udev);
> @@ -1562,6 +1681,12 @@
> uvc_status_cleanup(dev); uvc_ctrl_cleanup_device(dev);
>
> +	list_for_each_safe(p, n, &dev->chains) {
> +		struct uvc_video_chain *chain;
> +		chain = list_entry(p, struct uvc_video_chain, list);
> +		kfree(chain);
> +	}
> +
> list_for_each_safe(p, n, &dev->entities) { struct uvc_entity *entity;
entity
> = list_entry(p, struct uvc_entity, list);
> @@ -1602,6 +1727,7 @@
> return -ENOMEM;
>
> INIT_LIST_HEAD(&dev->entities);
> +	INIT_LIST_HEAD(&dev->chains);
> INIT_LIST_HEAD(&dev->streams);
> kref_init(&dev->kref); atomic_set(&dev->users, 0); @@ -1643,10 +1769,14 @@
> if (uvc_ctrl_init_device(dev) < 0) goto error;
>
> -	/* Scan the device for video chains and register video devices. */
> +	/* Scan the device for video chains. */
> if (uvc_scan_device(dev) < 0) goto error;
>
> +	/* Register video devices. */
> +	if (uvc_register_chains(dev) < 0)
> +		goto error;
> +
> /* Save our data pointer in the interface data. */
> usb_set_intfdata(intf, dev);
>
> diff -r 88ef3b9f5071 -r 012e480c8e6a
> linux/drivers/media/video/uvc/uvc_v4l2.c ---
> a/linux/drivers/media/video/uvc/uvc_v4l2.c	Sun Jun 28 13:37:50 2009 +0200
>  +++ b/linux/drivers/media/video/uvc/uvc_v4l2.c	Thu Jul 02 01:24:47 2009
> +0200
> @@ -40,7 +40,7 @@
> * table for the controls that can be mapped directly, and handle the
> others * manually.
> */
> -static int uvc_v4l2_query_menu(struct uvc_video_device *video,
> +static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
> struct v4l2_querymenu *query_menu) {
> struct uvc_menu_info *menu_info; @@ -49,7 +49,7 @@
> u32 index = query_menu->index; u32 id = query_menu->id;
>
> -	ctrl = uvc_find_control(video, query_menu->id, &mapping);
> +	ctrl = uvc_find_control(chain, query_menu->id, &mapping);
> if (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU) return
> -EINVAL;
>
>
> @@ -493,7 +493,7 @@
> }
> }
>
>
> -	handle->video = &stream->dev->video;
> +	handle->chain = stream->chain;
> handle->stream = stream; handle->state = UVC_HANDLE_PASSIVE;
> file->private_data = handle; @@ -542,7 +542,7 @@
> {
> struct video_device *vdev = video_devdata(file); struct uvc_fh *handle =
> (struct uvc_fh *)file->private_data;
> -	struct uvc_video_device *video = handle->video;
> +	struct uvc_video_chain *chain = handle->chain;
> struct uvc_streaming *stream = handle->stream; long ret = 0;
>
> @@ -569,7 +569,7 @@
>
>
> /* Get, Set & Query control */
> case VIDIOC_QUERYCTRL: -		return uvc_query_v4l2_ctrl(video, arg);
> +		return uvc_query_v4l2_ctrl(chain, arg);
>
>
> case VIDIOC_G_CTRL: {
> @@ -579,9 +579,9 @@
> memset(&xctrl, 0, sizeof xctrl); xctrl.id = ctrl->id;
>
> -		uvc_ctrl_begin(video);
> -		ret = uvc_ctrl_get(video, &xctrl);
> -		uvc_ctrl_rollback(video);
> +		uvc_ctrl_begin(chain);
> +		ret = uvc_ctrl_get(chain, &xctrl);
> +		uvc_ctrl_rollback(chain);
> if (ret >= 0) ctrl->value = xctrl.value; break; @@ -596,18 +596,18 @@
> xctrl.id = ctrl->id; xctrl.value = ctrl->value;
>
> -		uvc_ctrl_begin(video);
> -		ret = uvc_ctrl_set(video, &xctrl);
> +		uvc_ctrl_begin(chain);
> +		ret = uvc_ctrl_set(chain, &xctrl);
> if (ret < 0) { -			uvc_ctrl_rollback(video);
> +			uvc_ctrl_rollback(chain);
> return ret; }
> -		ret = uvc_ctrl_commit(video);
> +		ret = uvc_ctrl_commit(chain);
> break; }
>
>
> case VIDIOC_QUERYMENU: -		return uvc_v4l2_query_menu(video, arg);
> +		return uvc_v4l2_query_menu(chain, arg);
>
>
> case VIDIOC_G_EXT_CTRLS: {
> @@ -615,17 +615,17 @@
> struct v4l2_ext_control *ctrl = ctrls->controls; unsigned int i;
>
> -		uvc_ctrl_begin(video);
> +		uvc_ctrl_begin(chain);
> for (i = 0; i < ctrls->count; ++ctrl, ++i) { -			ret = uvc_ctrl_get(video,
> ctrl); +			ret = uvc_ctrl_get(chain, ctrl);
> if (ret < 0) { -				uvc_ctrl_rollback(video);
> +				uvc_ctrl_rollback(chain);
> ctrls->error_idx = i; return ret; }
> }
> ctrls->error_idx = 0; -		ret = uvc_ctrl_rollback(video);
> +		ret = uvc_ctrl_rollback(chain);
> break; }
>
>
> @@ -636,14 +636,14 @@
> struct v4l2_ext_control *ctrl = ctrls->controls; unsigned int i;
>
> -		ret = uvc_ctrl_begin(video);
> +		ret = uvc_ctrl_begin(chain);
> if (ret < 0) return ret;
>
> for (i = 0; i < ctrls->count; ++ctrl, ++i) { -			ret = uvc_ctrl_set(video,
> ctrl); +			ret = uvc_ctrl_set(chain, ctrl);
> if (ret < 0) { -				uvc_ctrl_rollback(video);
> +				uvc_ctrl_rollback(chain);
> ctrls->error_idx = i; return ret; }
> @@ -652,31 +652,31 @@
> ctrls->error_idx = 0;
>
> if (cmd == VIDIOC_S_EXT_CTRLS) -			ret = uvc_ctrl_commit(video);
> +			ret = uvc_ctrl_commit(chain);
> else -			ret = uvc_ctrl_rollback(video);
> +			ret = uvc_ctrl_rollback(chain);
> break; }
>
>
> /* Get, Set & Enum input */
> case VIDIOC_ENUMINPUT: {
> -		const struct uvc_entity *selector = video->selector;
> +		const struct uvc_entity *selector = chain->selector;
> struct v4l2_input *input = arg; struct uvc_entity *iterm = NULL; u32
index =
> input->index; int pin = 0;
>
> if (selector == NULL || -		    (video->dev->quirks &
> UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
> +		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
> if (index != 0) return -EINVAL; -			iterm =
list_first_entry(&video->iterms,
>  +			iterm = list_first_entry(&chain->iterms,
> struct uvc_entity, chain); pin = iterm->id; } else if (pin <
> selector->selector.bNrInPins) { pin =
> selector->selector.baSourceID[index]; -			list_for_each_entry(iterm,
> video->iterms.next, chain) { +			list_for_each_entry(iterm,
> chain->iterms.next, chain) { if (iterm->id == pin) break; }
> @@ -697,14 +697,14 @@
> {
> u8 input;
>
> -		if (video->selector == NULL ||
> -		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
> +		if (chain->selector == NULL ||
> +		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
> *(int *)arg = 0;
> break; }
>
>
> -		ret = uvc_query_ctrl(video->dev, GET_CUR, video->selector->id,
> -			video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> +		ret = uvc_query_ctrl(chain->dev, GET_CUR, chain->selector->id,
> +			chain->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> &input, 1);
> if (ret < 0) return ret; @@ -720,18 +720,18 @@
> if ((ret = uvc_acquire_privileges(handle)) < 0) return ret;
>
> -		if (video->selector == NULL ||
> -		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
> +		if (chain->selector == NULL ||
> +		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
> if (input != 1) return -EINVAL; break; }
>
>
> -		if (input == 0 || input > video->selector->selector.bNrInPins)
> +		if (input == 0 || input > chain->selector->selector.bNrInPins)
> return -EINVAL;
>
> -		return uvc_query_ctrl(video->dev, SET_CUR, video->selector->id,
> -			video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> +		return uvc_query_ctrl(chain->dev, SET_CUR, chain->selector->id,
> +			chain->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> &input, 1);
> }
>
>
> @@ -1064,10 +1064,10 @@
> }
>
>
> case UVCIOC_CTRL_GET: -		return uvc_xu_ctrl_query(video, arg, 0);
> +		return uvc_xu_ctrl_query(chain, arg, 0);
>
>
> case UVCIOC_CTRL_SET: -		return uvc_xu_ctrl_query(video, arg, 1);
> +		return uvc_xu_ctrl_query(chain, arg, 1);
>
>
> default:
> if ((ret = v4l_compat_translate_ioctl(file, cmd, arg, diff -r 88ef3b9f5071
> -r 012e480c8e6a linux/drivers/media/video/uvc/uvcvideo.h
> --- a/linux/drivers/media/video/uvc/uvcvideo.h	Sun Jun 28 13:37:50 2009
> +0200
> +++ b/linux/drivers/media/video/uvc/uvcvideo.h	Thu Jul 02 01:24:47 2009
> +0200
> @@ -224,9 +224,11 @@
> #define UVC_ENTITY_IS_UNIT(entity)	(((entity)->type & 0xff00) == 0)
> #define UVC_ENTITY_IS_TERM(entity)	(((entity)->type & 0xff00) != 0)
> #define UVC_ENTITY_IS_ITERM(entity) \
> -	(((entity)->type & 0x8000) == UVC_TERM_INPUT)
> +	(UVC_ENTITY_IS_TERM(entity) && \
> +	((entity)->type & 0x8000) == UVC_TERM_INPUT)
> #define UVC_ENTITY_IS_OTERM(entity) \
> -	(((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
> +	(UVC_ENTITY_IS_TERM(entity) && \
> +	((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
>
>
> #define UVC_STATUS_TYPE_CONTROL		1
> #define UVC_STATUS_TYPE_STREAMING	2
> @@ -560,10 +562,24 @@
> struct list_head irqqueue; };
>
>
> +struct uvc_video_chain {
> +	struct uvc_device *dev;
> +	struct list_head list;
> +
> +	struct list_head iterms;		/* Input terminals */
> +	struct list_head oterms;		/* Output terminals */
> +	struct uvc_entity *processing;		/* Processing unit */
> +	struct uvc_entity *selector;		/* Selector unit */
> +	struct list_head extensions;		/* Extension units */
> +
> +	struct mutex ctrl_mutex;
> +};
> +
> struct uvc_streaming { struct list_head list; struct uvc_device *dev;
struct
> video_device *vdev; +	struct uvc_video_chain *chain;
> atomic_t active;
>
> struct usb_interface *intf; @@ -604,18 +620,6 @@
> __u8 last_fid;
> };
>
>
> -struct uvc_video_device {
> -	struct uvc_device *dev;
> -
> -	struct list_head iterms;		/* Input terminals */
> -	struct uvc_entity *oterm;		/* Output terminal */
> -	struct uvc_entity *sterm;		/* USB streaming terminal */
> -	struct uvc_entity *processing;
> -	struct uvc_entity *selector;
> -	struct list_head extensions;
> -	struct mutex ctrl_mutex;
> -};
> -
> enum uvc_device_state { UVC_DEV_DISCONNECTED = 1,
> };
> @@ -638,8 +642,7 @@
> __u32 clock_frequency;
>
>
> struct list_head entities; -
> -	struct uvc_video_device video;
> +	struct list_head chains;
>
>
> /* Video Streaming interfaces */
> struct list_head streams; @@ -658,7 +661,7 @@
> };
>
>
> struct uvc_fh { -	struct uvc_video_device *video;
> +	struct uvc_video_chain *chain;
> struct uvc_streaming *stream; enum uvc_handle_state state; };
> @@ -776,9 +779,9 @@
> extern int uvc_status_resume(struct uvc_device *dev);
>
> /* Controls */
> -extern struct uvc_control *uvc_find_control(struct uvc_video_device
> *video,
> +extern struct uvc_control *uvc_find_control(struct uvc_video_chain
> *chain,
> __u32 v4l2_id, struct uvc_control_mapping **mapping);
> -extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
> +extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
> struct v4l2_queryctrl *v4l2_ctrl);
>
> extern int uvc_ctrl_add_info(struct uvc_control_info *info); @@ -788,23
> +791,23 @@
> extern int uvc_ctrl_resume_device(struct uvc_device *dev); extern void
> uvc_ctrl_init(void);
>
> -extern int uvc_ctrl_begin(struct uvc_video_device *video);
> -extern int __uvc_ctrl_commit(struct uvc_video_device *video, int
> rollback); -static inline int uvc_ctrl_commit(struct uvc_video_device
> *video)
> +extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
> +extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int
> rollback); +static inline int uvc_ctrl_commit(struct uvc_video_chain
> *chain)
> {
> -	return __uvc_ctrl_commit(video, 0);
> +	return __uvc_ctrl_commit(chain, 0);
> }
> -static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
> +static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
> {
> -	return __uvc_ctrl_commit(video, 1);
> +	return __uvc_ctrl_commit(chain, 1);
> }
>
>
> -extern int uvc_ctrl_get(struct uvc_video_device *video,
> +extern int uvc_ctrl_get(struct uvc_video_chain *chain,
> struct v4l2_ext_control *xctrl); -extern int uvc_ctrl_set(struct
> uvc_video_device *video, +extern int uvc_ctrl_set(struct uvc_video_chain
> *chain,
> struct v4l2_ext_control *xctrl);
>
> -extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
> +extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
> struct uvc_xu_control *ctrl, int set);
>
> /* Utility functions */
>
>
> _______________________________________________
> Linux-uvc-devel mailing list
> Linux-uvc-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
>
>




From laurent.pinchart at skynet.be  Thu Jul  2 17:41:03 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 2 Jul 2009 17:41:03 +0200
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
	interfaces support
In-Reply-To: <57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>
References: <200907020130.10001.laurent.pinchart@skynet.be>
	<200907020131.34726.laurent.pinchart@skynet.be>
	<57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>
Message-ID: <200907021741.03673.laurent.pinchart@skynet.be>

Hi C?dric,

On Thursday 02 July 2009 17:34:04 lescopc at esiee.fr wrote:
> Hello everyone,
>
> I am trying to stream with 2 webcams simultaneously so I tried your patch.
> The thing is I am not that good with Linux so.... didn't work. Here what I
> did:

Don't use that patch when streaming from two separate webcams. The patch is 
only meant to support cameras that have multiple streaming interfaces.

Best regards,

Laurent Pinchart



From joeborn at gmail.com  Thu Jul  2 18:39:11 2009
From: joeborn at gmail.com (Joe Born)
Date: Thu, 2 Jul 2009 11:39:11 -0500
Subject: [Linux-uvc-devel] Micro Innovations/Digital Innovations Webcam
In-Reply-To: <200907021559.15944.laurent.pinchart@skynet.be>
References: <aa742dba0907012019k3ff05f1enc0f11a2e4cd0d3e5@mail.gmail.com>
	<200907021559.15944.laurent.pinchart@skynet.be>
Message-ID: <aa742dba0907020939n3e46b7c0ue00070313ee31e00@mail.gmail.com>

Thanks for your quick response.  As you know, we are new to this
community, and it's often not easy to find your way around right away.

> Some cameras also have bugs that can't be easily worked around. For instance,
> I've received reports of webcams that had a bad auto-exposure algorithm that
> got stuck in very low-exposure mode, making the image extremely dark. There's
> not much the host software can do about that.
>
> Fixing application bugs and improving multimedia integration doesn't usually
> require access to every webcam model. What is needed there is a few developers
> with free time and access to a few webcams. Providing hardware samples can
> definitely help.

You articulated well a number of the benefits we'll get from
additional outside testers:  Workarounds, troubleshooting, feedback.
It's a very inexpensive way to get feedback IMHO.  I'm always
surprised that more manufacturers don't do it.

>
> Obviously, bugs in proprietary applications (such as Skype) can not be fixed
> by open-source developers. The end-user might feel that a particular webcam
> model is "crap because it doesn't work with Skype", but little can be done
> about that if Skype is at fault.

Sure, I'm not expecting miracles, and I would naturally expect to work
with the skype folks and have some samples in their hands as well.  Of
course, ultimately we, as the manfuacturers have the responsibility to
make sure our devices work well, but having outside help and feedback
can only help.

>
> How many different webcam models do you plan to sell ? Do you plan to perform
> some basic testing yourself and provide hardware samples to developers when
> problems are detected, or would you prefer to donate hardware samples for all
> models to someone who would test them all ?

I would guess that we'll see about 3 models.  My personal view is that
getting samples to developers early is always better.  My main job is
at neuros (neurostechnology.com) and we have a history of releasing
early "gamma" or developer kit samples to the market even before full
production.  We might even try to do some of that here.  The biggest
issue for us is finding the legitimately involved users, who will at
least poke around with the device.  It's certainly not the standard
that a free unit obliges a developer to fix bugs (a free unit is
hardly fair compensation for doing bug fixing), but its always sad to
send out free units and get no feedback whatsoever.  To me, if you get
a developer to use the unit and provide feedback then the free unit
was well invested.

To be honest, the best way I have found to "self select" the right
devs/users is to sell the units at discounted rates rather than give
them away.  But in either case, if you can point us to the right
folks, we can certainly seed the community with a few samples.

Joe


From malte.gell at gmx.de  Thu Jul  2 21:09:48 2009
From: malte.gell at gmx.de (Malte Gell)
Date: Thu, 2 Jul 2009 21:09:48 +0200
Subject: [Linux-uvc-devel] No working microphone with usb webcam,
	possible solution
In-Reply-To: <4A2E6CA0.7030904@gmx.de>
References: <4A2E6CA0.7030904@gmx.de>
Message-ID: <200907022109.49021.malte.gell@gmx.de>


Malte Gell <malte.gell at gmx.de> wrote

> Hi there,
>
> just a hint for folks who may need it... The USB microphone of my
> Philips SPC 620 NC never worked with Linux. I could never use the mic
> with Skype.
>
> A few days agos, when I installed a dual boot system with Windows Vista
> I noticed something interesting: after installing the Windows drivers
> and using the cam/mic with Skype under Windows it suddenly started to
> work under Linux as well!
>
> My guess is, the Windows driver loads necessary firmware into the camera
> that makes the microphone work under Linux.


I have to finally correct my statement! The reason why my webcam microphone 
never worked has probably been due to missing correct USB kernel module snd-
usb-audio and muted mixer settings. After loading snd-usb-audio i could use 
the webcam microphone, though I sound like Mickey Mouse... but audio works now 
at least. I am sorry for making false hopes :-)

Malte


From shaohuang at gmail.com  Thu Jul  2 18:50:23 2009
From: shaohuang at gmail.com (Brian Pin)
Date: Thu, 2 Jul 2009 09:50:23 -0700
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
	interfaces support
In-Reply-To: <57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>
References: <200907020130.10001.laurent.pinchart@skynet.be>
	<200907020131.34726.laurent.pinchart@skynet.be>
	<57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>
Message-ID: <a81f87bb0907020950t42e98ad8x7333ff69868cf914@mail.gmail.com>

I think 1) you should do the patch under Linux top dir not uvc dir.2) use
patch -p1 < the_patch
That probably helps..

On Thu, Jul 2, 2009 at 8:34 AM, <lescopc at esiee.fr> wrote:

> Hello everyone,
>
> I am trying to stream with 2 webcams simultaneously so I tried your patch.
> The thing is I am not that good with Linux so.... didn't work. Here what I
> did:
>
> **I downloaded your source from:
> http://linuxtv.org/hg/~pinchartl/uvcvideo/
>
>
> **I copied/pasted the content of this mail and the second one started from:
>
> diff -r 88ef3b9f5071 -r 012e480c8e6a
> linux/drivers/media/video/uvc/uvc_ctrl.c
>
> till the end to files that I named patchOne.diff and patchTwo.diff
>
> **Then, in a terminal, I went to:
> uvcvideo-bff77ec33116/linux/drivers/media/video/uvc
>
> **I did:
> patch <patchOne.diff
>
> It did not changed the content of the original files and I got:
> patching file uvc_driver.c
> Hunk #1 FAILED at 551.
> Hunk #2 FAILED at 752.
> Hunk #3 FAILED at 1167.
> Hunk #5 FAILED at 1494.
> Hunk #6 FAILED at 1515.
> Hunk #7 FAILED at 1530.
> Hunk #8 FAILED at 1568.
> Hunk #9 FAILED at 1602.
> Hunk #10 FAILED at 1643.
> Hunk #11 FAILED at 1697.
> Hunk #12 FAILED at 1706.
> Hunk #13 FAILED at 1735.
> 12 out of 13 hunks FAILED -- saving rejects to file uvc_driver.c.rej
> patching file uvc_isight.c
> Hunk #1 FAILED at 99.
> Hunk #2 FAILED at 120.
> etc...
>
> Can anyone tell me what I am doing wrong?
> Regards,
>
>
> LESCOP C?dric
>
>
>
>
> On Thu, July 2, 2009 01:31, Laurent Pinchart wrote:
> > Restructure the UVC descriptors parsing code to handle multiple streaming
> >  interfaces. The driver now creates a uvc_video_chain instance for each
> > chain detected in the UVC control interface descriptors, and tries to
> > register one video device per streaming endpoint.
> >
> > Priority: normal
> >
> >
> > Signed-off-by: Laurent Pinchart <laurent.pinchart at skynet.be>
> >
> >
> > diff -r 88ef3b9f5071 -r 012e480c8e6a
> > linux/drivers/media/video/uvc/uvc_ctrl.c ---
> > a/linux/drivers/media/video/uvc/uvc_ctrl.c    Sun Jun 28 13:37:50 2009
> +0200
> >  +++ b/linux/drivers/media/video/uvc/uvc_ctrl.c       Thu Jul 02 01:24:47
> 2009
> > +0200
> > @@ -731,7 +731,7 @@
> > }
> > }
> >
> >
> > -struct uvc_control *uvc_find_control(struct uvc_video_device *video,
> > +struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
> > __u32 v4l2_id, struct uvc_control_mapping **mapping)
> > {
> > struct uvc_control *ctrl = NULL; @@ -744,17 +744,17 @@
> > v4l2_id &= V4L2_CTRL_ID_MASK;
> >
> > /* Find the control. */
> > -     __uvc_find_control(video->processing, v4l2_id, mapping, &ctrl,
> next);
> > +     __uvc_find_control(chain->processing, v4l2_id, mapping, &ctrl,
> next);
> > if (ctrl && !next) return ctrl;
> >
> > -     list_for_each_entry(entity, &video->iterms, chain) {
> > +     list_for_each_entry(entity, &chain->iterms, chain) {
> > __uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
> > if (ctrl && !next) return ctrl; }
> >
> >
> > -     list_for_each_entry(entity, &video->extensions, chain) {
> > +     list_for_each_entry(entity, &chain->extensions, chain) {
> > __uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
> > if (ctrl && !next) return ctrl; @@ -767,7 +767,7 @@
> > return ctrl; }
> >
> >
> > -int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
> > +int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
> > struct v4l2_queryctrl *v4l2_ctrl) {
> > struct uvc_control *ctrl; @@ -777,7 +777,7 @@
> > __u8 *data;
> > int ret;
> >
> > -     ctrl = uvc_find_control(video, v4l2_ctrl->id, &mapping);
> > +     ctrl = uvc_find_control(chain, v4l2_ctrl->id, &mapping);
> > if (ctrl == NULL) return -EINVAL;
> >
> > @@ -795,9 +795,10 @@
> > v4l2_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
> >
> > if (ctrl->info->flags & UVC_CONTROL_GET_DEF) { -              if ((ret =
> > uvc_query_ctrl(video->dev, GET_DEF, ctrl->entity->id, -
> > video->dev->intfnum, ctrl->info->selector, -
>  data, ctrl->info->size)) <
> > 0)
> > +             ret = uvc_query_ctrl(chain->dev, GET_DEF, ctrl->entity->id,
> > +                                  chain->dev->intfnum,
> ctrl->info->selector,
> > +                                  data, ctrl->info->size);
> > +             if (ret < 0)
> > goto out; v4l2_ctrl->default_value = mapping->get(mapping, GET_DEF,
> data); }
> >  @@ -831,23 +832,26 @@
> > }
> >
> >
> > if (ctrl->info->flags & UVC_CONTROL_GET_MIN) { -              if ((ret =
> > uvc_query_ctrl(video->dev, GET_MIN, ctrl->entity->id, -
> > video->dev->intfnum, ctrl->info->selector, -
>  data, ctrl->info->size)) <
> > 0)
> > +             ret = uvc_query_ctrl(chain->dev, GET_MIN, ctrl->entity->id,
> > +                                  chain->dev->intfnum,
> ctrl->info->selector,
> > +                                  data, ctrl->info->size);
> > +             if (ret < 0)
> > goto out; v4l2_ctrl->minimum = mapping->get(mapping, GET_MIN, data); }
> > if (ctrl->info->flags & UVC_CONTROL_GET_MAX) { -              if ((ret =
> > uvc_query_ctrl(video->dev, GET_MAX, ctrl->entity->id, -
> > video->dev->intfnum, ctrl->info->selector, -
>  data, ctrl->info->size)) <
> > 0)
> > +             ret = uvc_query_ctrl(chain->dev, GET_MAX, ctrl->entity->id,
> > +                                  chain->dev->intfnum,
> ctrl->info->selector,
> > +                                  data, ctrl->info->size);
> > +             if (ret < 0)
> > goto out; v4l2_ctrl->maximum = mapping->get(mapping, GET_MAX, data); }
> > if (ctrl->info->flags & UVC_CONTROL_GET_RES) { -              if ((ret =
> > uvc_query_ctrl(video->dev, GET_RES, ctrl->entity->id, -
> > video->dev->intfnum, ctrl->info->selector, -
>  data, ctrl->info->size)) <
> > 0)
> > +             ret = uvc_query_ctrl(chain->dev, GET_RES, ctrl->entity->id,
> > +                                  chain->dev->intfnum,
> ctrl->info->selector,
> > +                                  data, ctrl->info->size);
> > +             if (ret < 0)
> > goto out; v4l2_ctrl->step = mapping->get(mapping, GET_RES, data); }
> > @@ -883,9 +887,9 @@
> > * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release
> > the * control lock.
> > */
> > -int uvc_ctrl_begin(struct uvc_video_device *video)
> > +int uvc_ctrl_begin(struct uvc_video_chain *chain)
> > {
> > -     return mutex_lock_interruptible(&video->ctrl_mutex) ? -ERESTARTSYS
> : 0;
> > +     return mutex_lock_interruptible(&chain->ctrl_mutex) ? -ERESTARTSYS
> : 0;
> > }
> >
> >
> > static int uvc_ctrl_commit_entity(struct uvc_device *dev, @@ -935,34
> > +939,34 @@
> > return 0; }
> >
> >
> > -int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
> > +int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
> > {
> > struct uvc_entity *entity; int ret = 0;
> >
> > /* Find the control. */
> > -     ret = uvc_ctrl_commit_entity(video->dev, video->processing,
> rollback);
> > +     ret = uvc_ctrl_commit_entity(chain->dev, chain->processing,
> rollback);
> > if (ret < 0) goto done;
> >
> > -     list_for_each_entry(entity, &video->iterms, chain) {
> > -             ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
> > +     list_for_each_entry(entity, &chain->iterms, chain) {
> > +             ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
> > if (ret < 0) goto done; }
> >
> >
> > -     list_for_each_entry(entity, &video->extensions, chain) {
> > -             ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
> > +     list_for_each_entry(entity, &chain->extensions, chain) {
> > +             ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
> > if (ret < 0) goto done; }
> >
> >
> > done:
> > -     mutex_unlock(&video->ctrl_mutex);
> > +     mutex_unlock(&chain->ctrl_mutex);
> > return ret; }
> >
> >
> > -int uvc_ctrl_get(struct uvc_video_device *video,
> > +int uvc_ctrl_get(struct uvc_video_chain *chain,
> > struct v4l2_ext_control *xctrl) {
> > struct uvc_control *ctrl; @@ -971,13 +975,13 @@
> > unsigned int i; int ret;
> >
> > -     ctrl = uvc_find_control(video, xctrl->id, &mapping);
> > +     ctrl = uvc_find_control(chain, xctrl->id, &mapping);
> > if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_GET_CUR) == 0)
> return
> > -EINVAL;
> >
> >
> > if (!ctrl->loaded) { -                ret = uvc_query_ctrl(video->dev,
> GET_CUR,
> > ctrl->entity->id, -                           video->dev->intfnum,
> ctrl->info->selector,
> > +             ret = uvc_query_ctrl(chain->dev, GET_CUR, ctrl->entity->id,
> > +                             chain->dev->intfnum, ctrl->info->selector,
> > uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), ctrl->info->size); if (ret <
> 0)
> > @@ -1002,7 +1006,7 @@
> > return 0; }
> >
> >
> > -int uvc_ctrl_set(struct uvc_video_device *video,
> > +int uvc_ctrl_set(struct uvc_video_chain *chain,
> > struct v4l2_ext_control *xctrl) {
> > struct uvc_control *ctrl; @@ -1010,7 +1014,7 @@
> > s32 value = xctrl->value; int ret;
> >
> > -     ctrl = uvc_find_control(video, xctrl->id, &mapping);
> > +     ctrl = uvc_find_control(chain, xctrl->id, &mapping);
> > if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_SET_CUR) == 0)
> return
> > -EINVAL;
> >
> >
> > @@ -1025,8 +1029,8 @@
> > memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), 0, ctrl->info->size);
> > } else {
> > -                     ret = uvc_query_ctrl(video->dev, GET_CUR,
> > -                             ctrl->entity->id, video->dev->intfnum,
> > +                     ret = uvc_query_ctrl(chain->dev, GET_CUR,
> > +                             ctrl->entity->id, chain->dev->intfnum,
> > ctrl->info->selector, uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
> > ctrl->info->size); @@ -1055,7 +1059,7 @@
> > * Dynamic controls
> > */
> >
> >
> > -int uvc_xu_ctrl_query(struct uvc_video_device *video,
> > +int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
> > struct uvc_xu_control *xctrl, int set) {
> > struct uvc_entity *entity; @@ -1065,7 +1069,7 @@
> > int ret;
> >
> > /* Find the extension unit. */
> > -     list_for_each_entry(entity, &video->extensions, chain) {
> > +     list_for_each_entry(entity, &chain->extensions, chain) {
> > if (entity->id == xctrl->unit) break; }
> > @@ -1104,7 +1108,7 @@
> > (!set && !(ctrl->info->flags & UVC_CONTROL_GET_CUR)))
> > return -EINVAL;
> >
> > -     if (mutex_lock_interruptible(&video->ctrl_mutex))
> > +     if (mutex_lock_interruptible(&chain->ctrl_mutex))
> > return -ERESTARTSYS;
> >
> > memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), @@ -1117,8 +1121,8 @@
> > goto out; }
> >
> >
> > -     ret = uvc_query_ctrl(video->dev, set ? SET_CUR : GET_CUR,
> xctrl->unit,
> > -                          video->dev->intfnum, xctrl->selector, data,
> > +     ret = uvc_query_ctrl(chain->dev, set ? SET_CUR : GET_CUR,
> xctrl->unit,
> > +                          chain->dev->intfnum, xctrl->selector, data,
> > xctrl->size); if (ret < 0) goto out; @@ -1134,7 +1138,7 @@
> > uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), xctrl->size);
> >
> > -     mutex_unlock(&video->ctrl_mutex);
> > +     mutex_unlock(&chain->ctrl_mutex);
> > return ret; }
> >
> >
> > diff -r 88ef3b9f5071 -r 012e480c8e6a
> > linux/drivers/media/video/uvc/uvc_driver.c ---
> > a/linux/drivers/media/video/uvc/uvc_driver.c  Sun Jun 28 13:37:50 2009
> > +0200
> > +++ b/linux/drivers/media/video/uvc/uvc_driver.c      Thu Jul 02 01:24:47
> 2009
> > +0200
> > @@ -276,8 +276,20 @@
> > return NULL; }
> >
> >
> > +static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev,
> > int id) +{
> > +     struct uvc_streaming *stream;
> > +
> > +     list_for_each_entry(stream, &dev->streams, list) {
> > +             if (stream->header.bTerminalLink == id)
> > +                     return stream;
> > +     }
> > +
> > +     return NULL;
> > +}
> > +
> > /*
> > ------------------------------------------------------------------------
> > - * Descriptors handling
> > + * Descriptors parsing
> > */
> >
> >
> > static int uvc_parse_format(struct uvc_device *dev, @@ -1159,101 +1171,36
> > @@
> > }
> >
> >
> > /*
> > ------------------------------------------------------------------------
> > - * USB probe and disconnect
> > + * UVC device scan
> > */
> >
> >
> > /*
> > - * Unregister the video devices.
> > - */
> > -static void uvc_unregister_video(struct uvc_device *dev)
> > -{
> > -     struct uvc_streaming *streaming;
> > -
> > -     list_for_each_entry(streaming, &dev->streams, list) {
> > -             if (streaming->vdev == NULL)
> > -                     continue;
> > -
> > -             if (streaming->vdev->minor == -1)
> > -                     video_device_release(streaming->vdev);
> > -             else
> > -                     video_unregister_device(streaming->vdev);
> > -             streaming->vdev = NULL;
> > -     }
> > -}
> > -
> > -static int uvc_register_video(struct uvc_device *dev,
> > -             struct uvc_streaming *stream)
> > -{
> > -     struct video_device *vdev;
> > -     struct uvc_entity *term;
> > -     int ret;
> > -
> > -     if (uvc_trace_param & UVC_TRACE_PROBE) {
> > -             uvc_printk(KERN_INFO, "Found a valid video chain (");
> > -             list_for_each_entry(term, &dev->video.iterms, chain) {
> > -                     printk("%d", term->id);
> > -                     if (term->chain.next != &dev->video.iterms)
> > -                             printk(",");
> > -             }
> > -             printk(" -> %d).\n", dev->video.oterm->id);
> > -     }
> > -
> > -     /* Initialize the streaming interface with default streaming
> > -      * parameters.
> > -      */
> > -     ret = uvc_video_init(stream);
> > -     if (ret < 0) {
> > -             uvc_printk(KERN_ERR, "Failed to initialize the device "
> > -                     "(%d).\n", ret);
> > -             return ret;
> > -     }
> > -
> > -     /* Register the device with V4L. */
> > -     vdev = video_device_alloc();
> > -     if (vdev == NULL)
> > -             return -1;
> > -
> > -     /* We already hold a reference to dev->udev. The video device will
> be
> > -      * unregistered before the reference is released, so we don't need
> to
> > -      * get another one.
> > -      */
> > -     vdev->parent = &dev->intf->dev;
> > -     vdev->minor = -1;
> > -     vdev->fops = &uvc_fops;
> > -     vdev->release = video_device_release;
> > -     strlcpy(vdev->name, dev->name, sizeof vdev->name);
> > -
> > -     /* Set the driver data before calling video_register_device,
> otherwise
> > -      * uvc_v4l2_open might race us.
> > -      */
> > -     stream->vdev = vdev;
> > -     video_set_drvdata(vdev, stream);
> > -
> > -     if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
> > -             stream->vdev = NULL;
> > -             video_device_release(vdev);
> > -             return -1;
> > -     }
> > -
> > -     return 0;
> > -}
> > -
> > -/*
> > * Scan the UVC descriptors to locate a chain starting at an Output
> > Terminal
> > * and containing the following units:
> > *
> > - * - one Output Terminal (USB Streaming or Display)
> > + * - one or more Output Terminals (USB Streaming or Display)
> > * - zero or one Processing Unit
> > - * - zero, one or mode single-input Selector Units
> > + * - zero, one or more single-input Selector Units
> > * - zero or one multiple-input Selector Units, provided all inputs are
> > *   connected to input terminals
> > * - zero, one or mode single-input Extension Units
> > * - one or more Input Terminals (Camera, External or USB Streaming)
> > *
> > - * A side forward scan is made on each detected entity to check for
> > additional - * extension units.
> > + * The terminal and units must match on of the following structures:
> > + *
> > + * ITT_*(0) -> +---------+    +---------+    +---------+ ->
> > TT_STREAMING(0)
> > + * ...         | SU{0,1} | -> | PU{0,1} | -> | XU{0,n} |    ...
> > + * ITT_*(n) -> +---------+    +---------+    +---------+ ->
> > TT_STREAMING(n)
> > + *
> > + *                 +---------+    +---------+ -> OTT_*(0)
> > + * TT_STREAMING -> | PU{0,1} | -> | XU{0,n} |    ...
> > + *                 +---------+    +---------+ -> OTT_*(n)
> > + *
> > + * The Processing Unit and Extension Units can be in any order.
> > Additional
> > + * Extension Units connected to the main chain as single-unit branches
> > are + * also supported. Single-input Selector Units are ignored.
> > */
> > -static int uvc_scan_chain_entity(struct uvc_video_device *video,
> > +static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
> > struct uvc_entity *entity) {
> > switch (UVC_ENTITY_TYPE(entity)) { @@ -1267,20 +1214,20 @@
> > return -1; }
> >
> >
> > -             list_add_tail(&entity->chain, &video->extensions);
> > +             list_add_tail(&entity->chain, &chain->extensions);
> > break;
> >
> > case VC_PROCESSING_UNIT: if (uvc_trace_param & UVC_TRACE_PROBE) printk("
> <-
> > PU %d", entity->id);
> >
> >
> > -             if (video->processing != NULL) {
> > +             if (chain->processing != NULL) {
> > uvc_trace(UVC_TRACE_DESCR, "Found multiple " "Processing Units in
> > chain.\n"); return -1; }
> >
> >
> > -             video->processing = entity;
> > +             chain->processing = entity;
> > break;
> >
> > case VC_SELECTOR_UNIT: @@ -1291,13 +1238,13 @@
> > if (entity->selector.bNrInPins == 1) break;
> >
> > -             if (video->selector != NULL) {
> > +             if (chain->selector != NULL) {
> > uvc_trace(UVC_TRACE_DESCR, "Found multiple Selector " "Units in
> chain.\n");
> >  return -1; }
> >
> >
> > -             video->selector = entity;
> > +             chain->selector = entity;
> > break;
> >
> > case ITT_VENDOR_SPECIFIC: @@ -1306,7 +1253,7 @@
> > if (uvc_trace_param & UVC_TRACE_PROBE) printk(" <- IT %d\n", entity->id);
> >
> > -             list_add_tail(&entity->chain, &video->iterms);
> > +             list_add_tail(&entity->chain, &chain->iterms);
> > break;
> >
> > case TT_STREAMING: @@ -1319,14 +1266,7 @@
> > return -1; }
> >
> >
> > -             if (video->sterm != NULL) {
> > -                     uvc_trace(UVC_TRACE_DESCR, "Found multiple
> streaming "
> > -                             "entities in chain.\n");
> > -                     return -1;
> > -             }
> > -
> > -             list_add_tail(&entity->chain, &video->iterms);
> > -             video->sterm = entity;
> > +             list_add_tail(&entity->chain, &chain->iterms);
> > break;
> >
> > default:
> > @@ -1338,7 +1278,7 @@
> > return 0; }
> >
> >
> > -static int uvc_scan_chain_forward(struct uvc_video_device *video,
> > +static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
> > struct uvc_entity *entity, struct uvc_entity *prev) {
> > struct uvc_entity *forward; @@ -1349,28 +1289,51 @@
> > found = 0;
> >
> > while (1) { -         forward = uvc_entity_by_reference(video->dev,
> entity->id,
> > +             forward = uvc_entity_by_reference(chain->dev, entity->id,
> > forward); if (forward == NULL) break; -
> > -             if (UVC_ENTITY_TYPE(forward) != VC_EXTENSION_UNIT ||
> > -                 forward == prev)
> > +             if (forward == prev)
> > continue;
> >
> > -             if (forward->extension.bNrInPins != 1) {
> > -                     uvc_trace(UVC_TRACE_DESCR, "Extension unit %d has "
> > -                             "more than 1 input pin.\n", entity->id);
> > -                     return -1;
> > -             }
> > +             switch (UVC_ENTITY_TYPE(forward)) {
> > +             case VC_EXTENSION_UNIT:
> > +                     if (forward->extension.bNrInPins != 1) {
> > +                             uvc_trace(UVC_TRACE_DESCR, "Extension unit
> %d "
> > +                                       "has more than 1 input pin.\n",
> > +                                       entity->id);
> > +                             return -EINVAL;
> > +                     }
> >
> >
> > -             list_add_tail(&forward->chain, &video->extensions);
> > -             if (uvc_trace_param & UVC_TRACE_PROBE) {
> > -                     if (!found)
> > -                             printk(" (-> XU");
> > +                     list_add_tail(&forward->chain, &chain->extensions);
> > +                     if (uvc_trace_param & UVC_TRACE_PROBE) {
> > +                             if (!found)
> > +                                     printk(" (->");
> >
> >
> > -                     printk(" %d", forward->id);
> > -                     found = 1;
> > +                             printk(" XU %d", forward->id);
> > +                             found = 1;
> > +                     }
> > +                     break;
> > +
> > +             case OTT_VENDOR_SPECIFIC:
> > +             case OTT_DISPLAY:
> > +             case OTT_MEDIA_TRANSPORT_OUTPUT:
> > +             case TT_STREAMING:
> > +                     if (UVC_ENTITY_IS_ITERM(forward)) {
> > +                             uvc_trace(UVC_TRACE_DESCR, "Unsupported
> input "
> > +                                     "terminal %u.\n", forward->id);
> > +                             return -EINVAL;
> > +                     }
> > +
> > +                     list_add_tail(&forward->chain, &chain->oterms);
> > +                     if (uvc_trace_param & UVC_TRACE_PROBE) {
> > +                             if (!found)
> > +                                     printk(" (->");
> > +
> > +                             printk(" OT %d", forward->id);
> > +                             found = 1;
> > +                     }
> > +                     break;
> > }
> > }
> > if (found) @@ -1379,7 +1342,7 @@
> > return 0; }
> >
> >
> > -static int uvc_scan_chain_backward(struct uvc_video_device *video,
> > +static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
> > struct uvc_entity *entity) {
> > struct uvc_entity *term; @@ -1404,10 +1367,10 @@
> > if (uvc_trace_param & UVC_TRACE_PROBE) printk(" <- IT");
> >
> > -             video->selector = entity;
> > +             chain->selector = entity;
> > for (i = 0; i < entity->selector.bNrInPins; ++i) { id =
> > entity->selector.baSourceID[i]; -                     term =
> uvc_entity_by_id(video->dev,
> > id); +                        term = uvc_entity_by_id(chain->dev, id);
> > if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
> > uvc_trace(UVC_TRACE_DESCR, "Selector unit %d " "input %d isn't connected
> > to an " @@ -1418,8 +1381,8 @@
> > if (uvc_trace_param & UVC_TRACE_PROBE) printk(" %d", term->id);
> >
> > -                     list_add_tail(&term->chain, &video->iterms);
> > -                     uvc_scan_chain_forward(video, term, entity);
> > +                     list_add_tail(&term->chain, &chain->iterms);
> > +                     uvc_scan_chain_forward(chain, term, entity);
> > }
> >
> >
> > if (uvc_trace_param & UVC_TRACE_PROBE) @@ -1432,108 +1395,264 @@
> > return id; }
> >
> >
> > -static int uvc_scan_chain(struct uvc_video_device *video)
> > +static int uvc_scan_chain(struct uvc_video_chain *chain,
> > +                       struct uvc_entity *oterm)
> > {
> > struct uvc_entity *entity, *prev; int id;
> >
> > -     entity = video->oterm;
> > +     entity = oterm;
> > +     list_add_tail(&entity->chain, &chain->oterms);
> > uvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain: OT %d", entity->id);
> >
> > -     if (UVC_ENTITY_TYPE(entity) == TT_STREAMING)
> > -             video->sterm = entity;
> > -
> > id = entity->output.bSourceID; while (id != 0) { prev = entity; -
>     entity =
> > uvc_entity_by_id(video->dev, id); +           entity =
> uvc_entity_by_id(chain->dev,
> > id); if (entity == NULL) { uvc_trace(UVC_TRACE_DESCR, "Found reference to
> "
> >  "unknown entity %d.\n", id);
> > -                     return -1;
> > +                     return -EINVAL;
> > +             }
> > +
> > +             if (entity->chain.next || entity->chain.prev) {
> > +                     uvc_trace(UVC_TRACE_DESCR, "Found reference to "
> > +                             "entity %d already in chain.\n", id);
> > +                     return -EINVAL;
> > }
> >
> >
> > /* Process entity */
> > -             if (uvc_scan_chain_entity(video, entity) < 0)
> > -                     return -1;
> > +             if (uvc_scan_chain_entity(chain, entity) < 0)
> > +                     return -EINVAL;
> >
> >
> > /* Forward scan */
> > -             if (uvc_scan_chain_forward(video, entity, prev) < 0)
> > -                     return -1;
> > +             if (uvc_scan_chain_forward(chain, entity, prev) < 0)
> > +                     return -EINVAL;
> >
> >
> > /* Stop when a terminal is found. */
> > -             if (!UVC_ENTITY_IS_UNIT(entity))
> > +             if (UVC_ENTITY_IS_TERM(entity))
> > break;
> >
> > /* Backward scan */
> > -             id = uvc_scan_chain_backward(video, entity);
> > +             id = uvc_scan_chain_backward(chain, entity);
> > if (id < 0) return id; }
> >
> >
> > -     if (video->sterm == NULL) {
> > -             uvc_trace(UVC_TRACE_DESCR, "No streaming entity found in "
> > -                     "chain.\n");
> > +     return 0;
> > +}
> > +
> > +static unsigned int uvc_print_terms(struct list_head *terms, char
> > *buffer)
> > +{
> > +     struct uvc_entity *term;
> > +     unsigned int nterms = 0;
> > +     char *p = buffer;
> > +
> > +     list_for_each_entry(term, terms, chain) {
> > +             p += sprintf(p, "%u", term->id);
> > +             if (term->chain.next != terms) {
> > +                     p += sprintf(p, ",");
> > +                     if (++nterms >= 4) {
> > +                             p += sprintf(p, "...");
> > +                             break;
> > +                     }
> > +             }
> > +     }
> > +
> > +     return p - buffer;
> > +}
> > +
> > +static const char *uvc_print_chain(struct uvc_video_chain *chain)
> > +{
> > +     static char buffer[43];
> > +     char *p = buffer;
> > +
> > +     p += uvc_print_terms(&chain->iterms, p);
> > +     p += sprintf(p, " -> ");
> > +     uvc_print_terms(&chain->oterms, p);
> > +
> > +     return buffer;
> > +}
> > +
> > +/*
> > + * Scan the device for video chains and register video devices.
> > + *
> > + * Chains are scanned starting at their output terminals and walked
> > backwards. + */
> > +static int uvc_scan_device(struct uvc_device *dev)
> > +{
> > +     struct uvc_video_chain *chain;
> > +     struct uvc_entity *term;
> > +
> > +     list_for_each_entry(term, &dev->entities, list) {
> > +             if (!UVC_ENTITY_IS_OTERM(term))
> > +                     continue;
> > +
> > +             /* If the terminal is already included in a chain, skip it.
> > +              * This can happen for chains that have multiple output
> > +              * terminals, where all output terminals beside the first
> one
> > +              * will be inserted in the chain in forward scans.
> > +              */
> > +             if (term->chain.next || term->chain.prev)
> > +                     continue;
> > +
> > +             chain = kzalloc(sizeof(*chain), GFP_KERNEL);
> > +             if (chain == NULL)
> > +                     return -ENOMEM;
> > +
> > +             INIT_LIST_HEAD(&chain->iterms);
> > +             INIT_LIST_HEAD(&chain->oterms);
> > +             INIT_LIST_HEAD(&chain->extensions);
> > +             mutex_init(&chain->ctrl_mutex);
> > +             chain->dev = dev;
> > +
> > +             if (uvc_scan_chain(chain, term) < 0) {
> > +                     kfree(chain);
> > +                     continue;
> > +             }
> > +
> > +             uvc_trace(UVC_TRACE_PROBE, "Found a valid video chain
> (%s).\n",
> > +                       uvc_print_chain(chain));
> > +
> > +             list_add_tail(&chain->list, &dev->chains);
> > +     }
> > +
> > +     if (list_empty(&dev->chains)) {
> > +             uvc_printk(KERN_INFO, "No valid video chain found.\n");
> > return -1; }
> >
> >
> > return 0; }
> >
> >
> > +/*
> > ------------------------------------------------------------------------
> > + * Video device registration and unregistration
> > + */
> > +
> > /*
> > - * Scan the device for video chains and register video devices.
> > - *
> > - * The driver currently supports a single video device per control
> > interface - * only. The terminal and units must match the following
> > structure:
> > - *
> > - * ITT_* -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> TT_STREAMING
> > - * TT_STREAMING -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> OTT_*
> > - *
> > - * The Extension Units, if present, must have a single input pin. The
> > - * Processing Unit and Extension Units can be in any order. Additional
> > - * Extension Units connected to the main chain as single-unit branches
> > are - * also supported.
> > + * Unregister the video devices.
> > */
> > -static int uvc_scan_device(struct uvc_device *dev)
> > +static void uvc_unregister_video(struct uvc_device *dev)
> > {
> > -     struct uvc_entity *term;
> > -     int found = 0;
> > +     struct uvc_streaming *stream;
> >
> >
> > -     /* Check if the control interface matches the structure we expect.
> */
> > -     list_for_each_entry(term, &dev->entities, list) {
> > -             struct uvc_streaming *stream;
> > -
> > -             if (!UVC_ENTITY_IS_TERM(term) ||
> !UVC_ENTITY_IS_OTERM(term))
> > +     list_for_each_entry(stream, &dev->streams, list) {
> > +             if (stream->vdev == NULL)
> > continue;
> >
> > -             memset(&dev->video, 0, sizeof dev->video);
> > -             mutex_init(&dev->video.ctrl_mutex);
> > -             INIT_LIST_HEAD(&dev->video.iterms);
> > -             INIT_LIST_HEAD(&dev->video.extensions);
> > -             dev->video.oterm = term;
> > -             dev->video.dev = dev;
> > -             if (uvc_scan_chain(&dev->video) < 0)
> > -                     continue;
> > +             if (stream->vdev->minor == -1)
> > +                     video_device_release(stream->vdev);
> > +             else
> > +                     video_unregister_device(stream->vdev);
> > +             stream->vdev = NULL;
> > +     }
> > +}
> >
> >
> > -             list_for_each_entry(stream, &dev->streams, list) {
> > -                     if (stream->header.bTerminalLink ==
> > -                         dev->video.sterm->id) {
> > -                             uvc_register_video(dev, stream);
> > -                             found = 1;
> > -                             break;
> > -                     }
> > -             }
> > +static int uvc_register_video(struct uvc_device *dev,
> > +             struct uvc_streaming *stream)
> > +{
> > +     struct video_device *vdev;
> > +     int ret;
> > +
> > +     /* Initialize the streaming interface with default streaming
> > +      * parameters.
> > +      */
> > +     ret = uvc_video_init(stream);
> > +     if (ret < 0) {
> > +             uvc_printk(KERN_ERR, "Failed to initialize the device "
> > +                     "(%d).\n", ret);
> > +             return ret;
> > }
> >
> >
> > -     if (!found) {
> > -             uvc_printk(KERN_INFO, "No valid video chain found.\n");
> > -             return -1;
> > +     /* Register the device with V4L. */
> > +     vdev = video_device_alloc();
> > +     if (vdev == NULL) {
> > +             uvc_printk(KERN_ERR, "Failed to allocate video device
> (%d).\n",
> > +                        ret);
> > +             return -ENOMEM;
> > +     }
> > +
> > +     /* We already hold a reference to dev->udev. The video device will
> be
> > +      * unregistered before the reference is released, so we don't need
> to
> > +      * get another one.
> > +      */
> > +     vdev->parent = &dev->intf->dev;
> > +     vdev->minor = -1;
> > +     vdev->fops = &uvc_fops;
> > +     vdev->release = video_device_release;
> > +     strlcpy(vdev->name, dev->name, sizeof vdev->name);
> > +
> > +     /* Set the driver data before calling video_register_device,
> otherwise
> > +      * uvc_v4l2_open might race us.
> > +      */
> > +     stream->vdev = vdev;
> > +     video_set_drvdata(vdev, stream);
> > +
> > +     ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
> > +     if (ret < 0) {
> > +             uvc_printk(KERN_ERR, "Failed to register video device
> (%d).\n",
> > +                        ret);
> > +             stream->vdev = NULL;
> > +             video_device_release(vdev);
> > +             return ret;
> > }
> >
> >
> > return 0; }
> >
> >
> > /*
> > + * Register all video devices in all chains.
> > + */
> > +static int uvc_register_terms(struct uvc_device *dev,
> > +     struct uvc_video_chain *chain, struct list_head *terms)
> > +{
> > +     struct uvc_streaming *stream;
> > +     struct uvc_entity *term;
> > +     int ret;
> > +
> > +     list_for_each_entry(term, terms, chain) {
> > +             if (UVC_ENTITY_TYPE(term) != TT_STREAMING)
> > +                     continue;
> > +
> > +             stream = uvc_stream_by_id(dev, term->id);
> > +             if (stream == NULL) {
> > +                     uvc_printk(KERN_INFO, "No streaming interface found
> "
> > +                                "for terminal %u.", term->id);
> > +                     continue;
> > +             }
> > +
> > +             stream->chain = chain;
> > +             ret = uvc_register_video(dev, stream);
> > +             if (ret < 0)
> > +                     return ret;
> > +     }
> > +
> > +     return 0;
> > +}
> > +
> > +static int uvc_register_chains(struct uvc_device *dev)
> > +{
> > +     struct uvc_video_chain *chain;
> > +     int ret;
> > +
> > +     list_for_each_entry(chain, &dev->chains, list) {
> > +             ret = uvc_register_terms(dev, chain, &chain->iterms);
> > +             if (ret < 0)
> > +                     return ret;
> > +
> > +             ret = uvc_register_terms(dev, chain, &chain->oterms);
> > +             if (ret < 0)
> > +                     return ret;
> > +     }
> > +
> > +     return 0;
> > +}
> > +
> > +/*
> > ------------------------------------------------------------------------
> > + * USB probe, disconnect, suspend and resume
> > + */
> > +
> > +/*
> > * Delete the UVC device.
> > *
> > * Called by the kernel when the last reference to the uvc_device
> structure
> >  @@ -1554,7 +1673,7 @@
> > struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
> > struct list_head *p, *n;
> >
> > -     /* Unregister the video device. */
> > +     /* Unregister the video devices. */
> > uvc_unregister_video(dev); usb_put_intf(dev->intf);
> usb_put_dev(dev->udev);
> > @@ -1562,6 +1681,12 @@
> > uvc_status_cleanup(dev); uvc_ctrl_cleanup_device(dev);
> >
> > +     list_for_each_safe(p, n, &dev->chains) {
> > +             struct uvc_video_chain *chain;
> > +             chain = list_entry(p, struct uvc_video_chain, list);
> > +             kfree(chain);
> > +     }
> > +
> > list_for_each_safe(p, n, &dev->entities) { struct uvc_entity *entity;
> entity
> > = list_entry(p, struct uvc_entity, list);
> > @@ -1602,6 +1727,7 @@
> > return -ENOMEM;
> >
> > INIT_LIST_HEAD(&dev->entities);
> > +     INIT_LIST_HEAD(&dev->chains);
> > INIT_LIST_HEAD(&dev->streams);
> > kref_init(&dev->kref); atomic_set(&dev->users, 0); @@ -1643,10 +1769,14
> @@
> > if (uvc_ctrl_init_device(dev) < 0) goto error;
> >
> > -     /* Scan the device for video chains and register video devices. */
> > +     /* Scan the device for video chains. */
> > if (uvc_scan_device(dev) < 0) goto error;
> >
> > +     /* Register video devices. */
> > +     if (uvc_register_chains(dev) < 0)
> > +             goto error;
> > +
> > /* Save our data pointer in the interface data. */
> > usb_set_intfdata(intf, dev);
> >
> > diff -r 88ef3b9f5071 -r 012e480c8e6a
> > linux/drivers/media/video/uvc/uvc_v4l2.c ---
> > a/linux/drivers/media/video/uvc/uvc_v4l2.c    Sun Jun 28 13:37:50 2009
> +0200
> >  +++ b/linux/drivers/media/video/uvc/uvc_v4l2.c       Thu Jul 02 01:24:47
> 2009
> > +0200
> > @@ -40,7 +40,7 @@
> > * table for the controls that can be mapped directly, and handle the
> > others * manually.
> > */
> > -static int uvc_v4l2_query_menu(struct uvc_video_device *video,
> > +static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
> > struct v4l2_querymenu *query_menu) {
> > struct uvc_menu_info *menu_info; @@ -49,7 +49,7 @@
> > u32 index = query_menu->index; u32 id = query_menu->id;
> >
> > -     ctrl = uvc_find_control(video, query_menu->id, &mapping);
> > +     ctrl = uvc_find_control(chain, query_menu->id, &mapping);
> > if (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU) return
> > -EINVAL;
> >
> >
> > @@ -493,7 +493,7 @@
> > }
> > }
> >
> >
> > -     handle->video = &stream->dev->video;
> > +     handle->chain = stream->chain;
> > handle->stream = stream; handle->state = UVC_HANDLE_PASSIVE;
> > file->private_data = handle; @@ -542,7 +542,7 @@
> > {
> > struct video_device *vdev = video_devdata(file); struct uvc_fh *handle =
> > (struct uvc_fh *)file->private_data;
> > -     struct uvc_video_device *video = handle->video;
> > +     struct uvc_video_chain *chain = handle->chain;
> > struct uvc_streaming *stream = handle->stream; long ret = 0;
> >
> > @@ -569,7 +569,7 @@
> >
> >
> > /* Get, Set & Query control */
> > case VIDIOC_QUERYCTRL: -              return uvc_query_v4l2_ctrl(video,
> arg);
> > +             return uvc_query_v4l2_ctrl(chain, arg);
> >
> >
> > case VIDIOC_G_CTRL: {
> > @@ -579,9 +579,9 @@
> > memset(&xctrl, 0, sizeof xctrl); xctrl.id = ctrl->id;
> >
> > -             uvc_ctrl_begin(video);
> > -             ret = uvc_ctrl_get(video, &xctrl);
> > -             uvc_ctrl_rollback(video);
> > +             uvc_ctrl_begin(chain);
> > +             ret = uvc_ctrl_get(chain, &xctrl);
> > +             uvc_ctrl_rollback(chain);
> > if (ret >= 0) ctrl->value = xctrl.value; break; @@ -596,18 +596,18 @@
> > xctrl.id = ctrl->id; xctrl.value = ctrl->value;
> >
> > -             uvc_ctrl_begin(video);
> > -             ret = uvc_ctrl_set(video, &xctrl);
> > +             uvc_ctrl_begin(chain);
> > +             ret = uvc_ctrl_set(chain, &xctrl);
> > if (ret < 0) { -                      uvc_ctrl_rollback(video);
> > +                     uvc_ctrl_rollback(chain);
> > return ret; }
> > -             ret = uvc_ctrl_commit(video);
> > +             ret = uvc_ctrl_commit(chain);
> > break; }
> >
> >
> > case VIDIOC_QUERYMENU: -              return uvc_v4l2_query_menu(video,
> arg);
> > +             return uvc_v4l2_query_menu(chain, arg);
> >
> >
> > case VIDIOC_G_EXT_CTRLS: {
> > @@ -615,17 +615,17 @@
> > struct v4l2_ext_control *ctrl = ctrls->controls; unsigned int i;
> >
> > -             uvc_ctrl_begin(video);
> > +             uvc_ctrl_begin(chain);
> > for (i = 0; i < ctrls->count; ++ctrl, ++i) { -                        ret
> = uvc_ctrl_get(video,
> > ctrl); +                      ret = uvc_ctrl_get(chain, ctrl);
> > if (ret < 0) { -                              uvc_ctrl_rollback(video);
> > +                             uvc_ctrl_rollback(chain);
> > ctrls->error_idx = i; return ret; }
> > }
> > ctrls->error_idx = 0; -               ret = uvc_ctrl_rollback(video);
> > +             ret = uvc_ctrl_rollback(chain);
> > break; }
> >
> >
> > @@ -636,14 +636,14 @@
> > struct v4l2_ext_control *ctrl = ctrls->controls; unsigned int i;
> >
> > -             ret = uvc_ctrl_begin(video);
> > +             ret = uvc_ctrl_begin(chain);
> > if (ret < 0) return ret;
> >
> > for (i = 0; i < ctrls->count; ++ctrl, ++i) { -                        ret
> = uvc_ctrl_set(video,
> > ctrl); +                      ret = uvc_ctrl_set(chain, ctrl);
> > if (ret < 0) { -                              uvc_ctrl_rollback(video);
> > +                             uvc_ctrl_rollback(chain);
> > ctrls->error_idx = i; return ret; }
> > @@ -652,31 +652,31 @@
> > ctrls->error_idx = 0;
> >
> > if (cmd == VIDIOC_S_EXT_CTRLS) -                      ret =
> uvc_ctrl_commit(video);
> > +                     ret = uvc_ctrl_commit(chain);
> > else -                        ret = uvc_ctrl_rollback(video);
> > +                     ret = uvc_ctrl_rollback(chain);
> > break; }
> >
> >
> > /* Get, Set & Enum input */
> > case VIDIOC_ENUMINPUT: {
> > -             const struct uvc_entity *selector = video->selector;
> > +             const struct uvc_entity *selector = chain->selector;
> > struct v4l2_input *input = arg; struct uvc_entity *iterm = NULL; u32
> index =
> > input->index; int pin = 0;
> >
> > if (selector == NULL || -                 (video->dev->quirks &
> > UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
> > +                 (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT))
> {
> > if (index != 0) return -EINVAL; -                     iterm =
> list_first_entry(&video->iterms,
> >  +                    iterm = list_first_entry(&chain->iterms,
> > struct uvc_entity, chain); pin = iterm->id; } else if (pin <
> > selector->selector.bNrInPins) { pin =
> > selector->selector.baSourceID[index]; -
> list_for_each_entry(iterm,
> > video->iterms.next, chain) { +
>  list_for_each_entry(iterm,
> > chain->iterms.next, chain) { if (iterm->id == pin) break; }
> > @@ -697,14 +697,14 @@
> > {
> > u8 input;
> >
> > -             if (video->selector == NULL ||
> > -                 (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT))
> {
> > +             if (chain->selector == NULL ||
> > +                 (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT))
> {
> > *(int *)arg = 0;
> > break; }
> >
> >
> > -             ret = uvc_query_ctrl(video->dev, GET_CUR,
> video->selector->id,
> > -                     video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> > +             ret = uvc_query_ctrl(chain->dev, GET_CUR,
> chain->selector->id,
> > +                     chain->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> > &input, 1);
> > if (ret < 0) return ret; @@ -720,18 +720,18 @@
> > if ((ret = uvc_acquire_privileges(handle)) < 0) return ret;
> >
> > -             if (video->selector == NULL ||
> > -                 (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT))
> {
> > +             if (chain->selector == NULL ||
> > +                 (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT))
> {
> > if (input != 1) return -EINVAL; break; }
> >
> >
> > -             if (input == 0 || input >
> video->selector->selector.bNrInPins)
> > +             if (input == 0 || input >
> chain->selector->selector.bNrInPins)
> > return -EINVAL;
> >
> > -             return uvc_query_ctrl(video->dev, SET_CUR,
> video->selector->id,
> > -                     video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> > +             return uvc_query_ctrl(chain->dev, SET_CUR,
> chain->selector->id,
> > +                     chain->dev->intfnum, SU_INPUT_SELECT_CONTROL,
> > &input, 1);
> > }
> >
> >
> > @@ -1064,10 +1064,10 @@
> > }
> >
> >
> > case UVCIOC_CTRL_GET: -               return uvc_xu_ctrl_query(video,
> arg, 0);
> > +             return uvc_xu_ctrl_query(chain, arg, 0);
> >
> >
> > case UVCIOC_CTRL_SET: -               return uvc_xu_ctrl_query(video,
> arg, 1);
> > +             return uvc_xu_ctrl_query(chain, arg, 1);
> >
> >
> > default:
> > if ((ret = v4l_compat_translate_ioctl(file, cmd, arg, diff -r
> 88ef3b9f5071
> > -r 012e480c8e6a linux/drivers/media/video/uvc/uvcvideo.h
> > --- a/linux/drivers/media/video/uvc/uvcvideo.h        Sun Jun 28 13:37:50
> 2009
> > +0200
> > +++ b/linux/drivers/media/video/uvc/uvcvideo.h        Thu Jul 02 01:24:47
> 2009
> > +0200
> > @@ -224,9 +224,11 @@
> > #define UVC_ENTITY_IS_UNIT(entity)    (((entity)->type & 0xff00) == 0)
> > #define UVC_ENTITY_IS_TERM(entity)    (((entity)->type & 0xff00) != 0)
> > #define UVC_ENTITY_IS_ITERM(entity) \
> > -     (((entity)->type & 0x8000) == UVC_TERM_INPUT)
> > +     (UVC_ENTITY_IS_TERM(entity) && \
> > +     ((entity)->type & 0x8000) == UVC_TERM_INPUT)
> > #define UVC_ENTITY_IS_OTERM(entity) \
> > -     (((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
> > +     (UVC_ENTITY_IS_TERM(entity) && \
> > +     ((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
> >
> >
> > #define UVC_STATUS_TYPE_CONTROL               1
> > #define UVC_STATUS_TYPE_STREAMING     2
> > @@ -560,10 +562,24 @@
> > struct list_head irqqueue; };
> >
> >
> > +struct uvc_video_chain {
> > +     struct uvc_device *dev;
> > +     struct list_head list;
> > +
> > +     struct list_head iterms;                /* Input terminals */
> > +     struct list_head oterms;                /* Output terminals */
> > +     struct uvc_entity *processing;          /* Processing unit */
> > +     struct uvc_entity *selector;            /* Selector unit */
> > +     struct list_head extensions;            /* Extension units */
> > +
> > +     struct mutex ctrl_mutex;
> > +};
> > +
> > struct uvc_streaming { struct list_head list; struct uvc_device *dev;
> struct
> > video_device *vdev; + struct uvc_video_chain *chain;
> > atomic_t active;
> >
> > struct usb_interface *intf; @@ -604,18 +620,6 @@
> > __u8 last_fid;
> > };
> >
> >
> > -struct uvc_video_device {
> > -     struct uvc_device *dev;
> > -
> > -     struct list_head iterms;                /* Input terminals */
> > -     struct uvc_entity *oterm;               /* Output terminal */
> > -     struct uvc_entity *sterm;               /* USB streaming terminal
> */
> > -     struct uvc_entity *processing;
> > -     struct uvc_entity *selector;
> > -     struct list_head extensions;
> > -     struct mutex ctrl_mutex;
> > -};
> > -
> > enum uvc_device_state { UVC_DEV_DISCONNECTED = 1,
> > };
> > @@ -638,8 +642,7 @@
> > __u32 clock_frequency;
> >
> >
> > struct list_head entities; -
> > -     struct uvc_video_device video;
> > +     struct list_head chains;
> >
> >
> > /* Video Streaming interfaces */
> > struct list_head streams; @@ -658,7 +661,7 @@
> > };
> >
> >
> > struct uvc_fh { -     struct uvc_video_device *video;
> > +     struct uvc_video_chain *chain;
> > struct uvc_streaming *stream; enum uvc_handle_state state; };
> > @@ -776,9 +779,9 @@
> > extern int uvc_status_resume(struct uvc_device *dev);
> >
> > /* Controls */
> > -extern struct uvc_control *uvc_find_control(struct uvc_video_device
> > *video,
> > +extern struct uvc_control *uvc_find_control(struct uvc_video_chain
> > *chain,
> > __u32 v4l2_id, struct uvc_control_mapping **mapping);
> > -extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
> > +extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
> > struct v4l2_queryctrl *v4l2_ctrl);
> >
> > extern int uvc_ctrl_add_info(struct uvc_control_info *info); @@ -788,23
> > +791,23 @@
> > extern int uvc_ctrl_resume_device(struct uvc_device *dev); extern void
> > uvc_ctrl_init(void);
> >
> > -extern int uvc_ctrl_begin(struct uvc_video_device *video);
> > -extern int __uvc_ctrl_commit(struct uvc_video_device *video, int
> > rollback); -static inline int uvc_ctrl_commit(struct uvc_video_device
> > *video)
> > +extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
> > +extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int
> > rollback); +static inline int uvc_ctrl_commit(struct uvc_video_chain
> > *chain)
> > {
> > -     return __uvc_ctrl_commit(video, 0);
> > +     return __uvc_ctrl_commit(chain, 0);
> > }
> > -static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
> > +static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
> > {
> > -     return __uvc_ctrl_commit(video, 1);
> > +     return __uvc_ctrl_commit(chain, 1);
> > }
> >
> >
> > -extern int uvc_ctrl_get(struct uvc_video_device *video,
> > +extern int uvc_ctrl_get(struct uvc_video_chain *chain,
> > struct v4l2_ext_control *xctrl); -extern int uvc_ctrl_set(struct
> > uvc_video_device *video, +extern int uvc_ctrl_set(struct uvc_video_chain
> > *chain,
> > struct v4l2_ext_control *xctrl);
> >
> > -extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
> > +extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
> > struct uvc_xu_control *ctrl, int set);
> >
> > /* Utility functions */
> >
> >
> > _______________________________________________
> > Linux-uvc-devel mailing list
> > Linux-uvc-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
> >
> >
>
>
> _______________________________________________
> Linux-uvc-devel mailing list
> Linux-uvc-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
>



-- 
Best Regards
Brian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090702/786421ea/attachment.html>

From lescopc at esiee.fr  Fri Jul  3 10:00:46 2009
From: lescopc at esiee.fr (lescopc at esiee.fr)
Date: Fri, 3 Jul 2009 10:00:46 +0200 (CEST)
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
 interfaces support
In-Reply-To: <200907021741.03673.laurent.pinchart@skynet.be>
References: <200907020130.10001.laurent.pinchart@skynet.be>
	<200907020131.34726.laurent.pinchart@skynet.be>
	<57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>
	<200907021741.03673.laurent.pinchart@skynet.be>
Message-ID: <45549.194.3.40.246.1246608046.squirrel@mail2.esiee.fr>

Hi Laurent,

The thing is, I am using 2 webcams on 2 different USB ports. I start
streaming with the first one at 800x600 at 20fps. Everything works ok.

During this, I try to stream from the second one with "mencoder". I got
this error:
v4l2: ioctl streamon failed: No space left on device

mencoder still runs but skips every single frame.
Here what I get from a dmesg:
uvcvideo: Failed to query (1) UVC control 10 (unit 2) : -32 (exp. 2).
uvcvideo: Failed to submit URB 0 (-28).

I must admit I edited one line in your driver, I changed the max URB from
5 to 2 (I know you told me not to :p). But then, I changed it back, I even
tried with more URBs and less PACKETs (from 32 to 16), still same error.

Do you know how I could solve this space problem?
Best regards,


LESCOP C?dric

On Thu, July 2, 2009 17:41, Laurent Pinchart wrote:
> Hi C?dric,
>
>
> On Thursday 02 July 2009 17:34:04 lescopc at esiee.fr wrote:
>
>> Hello everyone,
>>
>>
>> I am trying to stream with 2 webcams simultaneously so I tried your
>> patch. The thing is I am not that good with Linux so.... didn't work.
>> Here what I
>> did:
>>
>
> Don't use that patch when streaming from two separate webcams. The patch
> is only meant to support cameras that have multiple streaming interfaces.
>
> Best regards,
>
>
> Laurent Pinchart
>
>
>




From lescopc at esiee.fr  Fri Jul  3 10:25:37 2009
From: lescopc at esiee.fr (lescopc at esiee.fr)
Date: Fri, 3 Jul 2009 10:25:37 +0200 (CEST)
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
 interfaces support
In-Reply-To: <a81f87bb0907020950t42e98ad8x7333ff69868cf914@mail.gmail.com>
References: <200907020130.10001.laurent.pinchart@skynet.be> 
	<200907020131.34726.laurent.pinchart@skynet.be> 
	<57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>
	<a81f87bb0907020950t42e98ad8x7333ff69868cf914@mail.gmail.com>
Message-ID: <59786.194.3.40.246.1246609537.squirrel@mail2.esiee.fr>

Thank you, I'll give it a try. It'll help me to learn how to use linux and
its tools.

On Thu, July 2, 2009 18:50, Brian Pin wrote:
> I think 1) you should do the patch under Linux top dir not uvc dir.2) use
>  patch -p1 < the_patch That probably helps..
>
>
> On Thu, Jul 2, 2009 at 8:34 AM, <lescopc at esiee.fr> wrote:
>
>
>> Hello everyone,
>>
>>
>> I am trying to stream with 2 webcams simultaneously so I tried your
>> patch. The thing is I am not that good with Linux so.... didn't work.
>> Here what I
>> did:
>>
>>
>> **I downloaded your source from:
>> http://linuxtv.org/hg/~pinchartl/uvcvideo/
>>
>>
>>
>> **I copied/pasted the content of this mail and the second one started
>> from:
>>
>>
>> diff -r 88ef3b9f5071 -r 012e480c8e6a
>> linux/drivers/media/video/uvc/uvc_ctrl.c
>>
>> till the end to files that I named patchOne.diff and patchTwo.diff
>>
>> **Then, in a terminal, I went to:
>> uvcvideo-bff77ec33116/linux/drivers/media/video/uvc
>>
>> **I did:
>> patch <patchOne.diff
>>
>> It did not changed the content of the original files and I got:
>> patching file uvc_driver.c Hunk #1 FAILED at 551.
>> Hunk #2 FAILED at 752.
>> Hunk #3 FAILED at 1167.
>> Hunk #5 FAILED at 1494.
>> Hunk #6 FAILED at 1515.
>> Hunk #7 FAILED at 1530.
>> Hunk #8 FAILED at 1568.
>> Hunk #9 FAILED at 1602.
>> Hunk #10 FAILED at 1643.
>> Hunk #11 FAILED at 1697.
>> Hunk #12 FAILED at 1706.
>> Hunk #13 FAILED at 1735.
>> 12 out of 13 hunks FAILED -- saving rejects to file uvc_driver.c.rej
>> patching file uvc_isight.c Hunk #1 FAILED at 99.
>> Hunk #2 FAILED at 120.
>> etc...
>>
>> Can anyone tell me what I am doing wrong?
>> Regards,
>>
>>
>>
>> LESCOP C?dric
>>
>>
>>
>>
>>
>> On Thu, July 2, 2009 01:31, Laurent Pinchart wrote:
>>
>>> Restructure the UVC descriptors parsing code to handle multiple
>>> streaming interfaces. The driver now creates a uvc_video_chain
>>> instance for each chain detected in the UVC control interface
>>> descriptors, and tries to register one video device per streaming
>>> endpoint.
>>>
>>> Priority: normal
>>>
>>>
>>>
>>> Signed-off-by: Laurent Pinchart <laurent.pinchart at skynet.be>
>>>
>>>
>>>
>>> diff -r 88ef3b9f5071 -r 012e480c8e6a
>>> linux/drivers/media/video/uvc/uvc_ctrl.c ---
>>> a/linux/drivers/media/video/uvc/uvc_ctrl.c    Sun Jun 28 13:37:50
>>> 2009
>>>
>> +0200
>>
>>> +++ b/linux/drivers/media/video/uvc/uvc_ctrl.c       Thu Jul 02
>>> 01:24:47
>>>
>> 2009
>>
>>> +0200
>>> @@ -731,7 +731,7 @@
>>> }
>>> }
...




From lescopc at esiee.fr  Fri Jul  3 11:05:20 2009
From: lescopc at esiee.fr (lescopc at esiee.fr)
Date: Fri, 3 Jul 2009 11:05:20 +0200 (CEST)
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
 interfaces support
In-Reply-To: <45549.194.3.40.246.1246608046.squirrel@mail2.esiee.fr>
References: <200907020130.10001.laurent.pinchart@skynet.be>   
	<200907020131.34726.laurent.pinchart@skynet.be>   
	<57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>   
	<200907021741.03673.laurent.pinchart@skynet.be>
	<45549.194.3.40.246.1246608046.squirrel@mail2.esiee.fr>
Message-ID: <40537.194.3.40.246.1246611920.squirrel@mail2.esiee.fr>

Ok, I know I know I reply to myself but it might helps someone :)
I kept looking for an answer and I found one:

http://osdir.com/ml/linux.drivers.uvc.devel/2007-03/msg00005.html

Basically, I started the streaming with my first webcam. Then, I started
luvcview with my second webcam, which use MJPG:640:480:30fps and it
worked.
So, as Laurent says in the link, it exceeds the bandwidth.

I'll try to change my mencoder command to make it use MJPG (if someone
know let me know).
Thank you and Best regards,


LESCOP C?dric


On Fri, July 3, 2009 10:00, lescopc at esiee.fr wrote:
> Hi Laurent,
>
>
> The thing is, I am using 2 webcams on 2 different USB ports. I start
> streaming with the first one at 800x600 at 20fps. Everything works ok.
>
> During this, I try to stream from the second one with "mencoder". I got
> this error: v4l2: ioctl streamon failed: No space left on device
>
>
> mencoder still runs but skips every single frame. Here what I get from a
> dmesg:
> uvcvideo: Failed to query (1) UVC control 10 (unit 2) : -32 (exp. 2).
> uvcvideo: Failed to submit URB 0 (-28).
>
>
> I must admit I edited one line in your driver, I changed the max URB from
>  5 to 2 (I know you told me not to :p). But then, I changed it back, I
> even tried with more URBs and less PACKETs (from 32 to 16), still same
> error.
>
> Do you know how I could solve this space problem?
> Best regards,
>
>
>
> LESCOP C?dric
>
>
> On Thu, July 2, 2009 17:41, Laurent Pinchart wrote:
>
>> Hi C?dric,
>>
>>
>>
>> On Thursday 02 July 2009 17:34:04 lescopc at esiee.fr wrote:
>>
>>
>>> Hello everyone,
>>>
>>>
>>>
>>> I am trying to stream with 2 webcams simultaneously so I tried your
>>> patch. The thing is I am not that good with Linux so.... didn't work.
>>> Here what I
>>> did:
>>>
>>>
>>
>> Don't use that patch when streaming from two separate webcams. The
>> patch is only meant to support cameras that have multiple streaming
>> interfaces.
>>
>> Best regards,
>>
>>
>>
>> Laurent Pinchart
>>
>>
>>
>>
>
>
>




From barsnick at gmx.net  Sat Jul  4 15:02:15 2009
From: barsnick at gmx.net (Moritz Barsnick)
Date: Sat, 4 Jul 2009 15:02:15 +0200
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
 interfaces support
In-Reply-To: <40537.194.3.40.246.1246611920.squirrel@mail2.esiee.fr>
References: <200907020130.10001.laurent.pinchart@skynet.be>
	<200907020131.34726.laurent.pinchart@skynet.be>
	<57789.194.3.40.246.1246548844.squirrel@mail2.esiee.fr>
	<200907021741.03673.laurent.pinchart@skynet.be>
	<45549.194.3.40.246.1246608046.squirrel@mail2.esiee.fr>
	<40537.194.3.40.246.1246611920.squirrel@mail2.esiee.fr>
Message-ID: <20090704130215.GA29230@sunshine.barsnick.net>

On Fri, Jul 03, 2009 at 11:05:20 +0200, lescopc at esiee.fr wrote:
> I'll try to change my mencoder command to make it use MJPG (if someone
> know let me know).

The -tv option has an outfmt argument which can try to force mjpeg. I
think this should work:

mplayer tv:// -tv driver=v4l:outfmt=mjpeg:device=/dev/video0 -fps 5

(My MJPEG capable cam isn't connected right now, so I can't test.)

Give that a try with mencoder.

HTH,
Moritz


From andrej at podzimek.org  Mon Jul  6 18:24:43 2009
From: andrej at podzimek.org (Andrej Podzimek)
Date: Mon, 06 Jul 2009 18:24:43 +0200
Subject: [Linux-uvc-devel] Sirius webcam (0ac8:3330) malfunction
Message-ID: <4A52254B.5060509@podzimek.org>

Hello,

I bought this $2 webcam just for fun, so this is not a serious issue. The problem is really simple:

* The webcam works perfectly with my Asus M2N laptop (Intel USB 2.0 controller).
* The webcam fails with my IBM xSeries 330 server (NEC USB 2.0 controller).

Both machines use a similar kernel configuration and other USB devices seem to work normally with both of them.

When used with the server, the webcam either sends about 1 frame in 10 seconds (with 2.6.29.4 and below), or gets stuck at the first frame (2.6.29.6, 2.6.30.1).

I tried various combinations of the quirks (especially 0x10), but it didn't help at all. There was nothing new in dmesg. The only message was:
	uvcvideo: Failed to query (130) UVC control 3 (unit 2) : -32 (exp. 2).
But his only appeared twice in about 20 module reloads and video experiments.

This is weird. Those two machines must differ in some important aspect, as far as their USB interfaces are concerned. Is there a way to find out more about this?

Andrej



From denis-pechkovsky at yandex.ru  Tue Jul  7 11:06:46 2009
From: denis-pechkovsky at yandex.ru (Pechkovsky Denis)
Date: Tue, 07 Jul 2009 13:06:46 +0400
Subject: [Linux-uvc-devel]  Looking for upside down uvc cams
Message-ID: <31941246957606@webmail48.yandex.ru>

Hi!

My webcam is upside down.

-- 
Thanks for support,
 Denis Pechkovsky (denis-pechkovsky at yandex.ru)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: lsusb.log
Type: application/octet-stream
Size: 466 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090707/8d4ce828/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: dmi.log
Type: application/octet-stream
Size: 9659 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090707/8d4ce828/attachment-0001.obj>

From fsulima at gmail.com  Tue Jul  7 15:24:19 2009
From: fsulima at gmail.com (fsulima)
Date: Tue, 07 Jul 2009 17:24:19 +0400
Subject: [Linux-uvc-devel] MediaTek MT6227 on Philips 9@9U is now working
	with uvc
Message-ID: <4A534C83.8010201@gmail.com>

Hi all.

MediaTek MT6227 on Philips 9 at 9U do not work. It looks like this:

$ dmesg | tail
[94425.741948] uvcvideo: Failed to query (135) UVC control 1 (unit 0) :
-110 (exp. 26).
[94425.743941] uvcvideo: Failed to query (129) UVC control 1 (unit 0) :
-71 (exp. 26).
[94425.743946] uvcvideo: Failed to initialize the device (-5).
[94429.128037] usb 7-2: USB disconnect, address 8
[94436.384010] usb 7-2: new full speed USB device using uhci_hcd and
address 9
[94436.849070] usb 7-2: configuration #1 chosen from 7 choices
[94436.859998] uvcvideo: Found UVC 1.00 device 9 at 9U    (0e8d:0004)
[94437.861939] uvcvideo: Failed to query (135) UVC control 1 (unit 0) :
-110 (exp. 26).
[94437.863947] uvcvideo: Failed to query (129) UVC control 1 (unit 0) :
-71 (exp. 26).
[94437.863952] uvcvideo: Failed to initialize the device (-5).

$ lsusb
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 008 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 007 Device 009: ID 0e8d:0004 MediaTek Inc.
Bus 007 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 006 Device 003: ID 046d:c03e Logitech, Inc. Premium Optical Wheel Mouse
Bus 006 Device 002: ID 0430:0005 Sun Microsystems, Inc. Type 6 Keyboard
Bus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub

$ lsusb -d 0e8d:0004 -v
Bus 007 Device 009: ID 0e8d:0004 MediaTek Inc.
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               1.10
  bDeviceClass          239 Miscellaneous Device
  bDeviceSubClass         2 ?
  bDeviceProtocol         1 Interface Association
  bMaxPacketSize0         8
  idVendor           0x0e8d MediaTek Inc.
  idProduct          0x0004
  bcdDevice            1.00
  iManufacturer           6
  iProduct                7
  iSerial                 8
  bNumConfigurations      7
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          269
    bNumInterfaces          2
    bConfigurationValue     1
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower              450mA
    Interface Association:
      bLength                 8
      bDescriptorType        11
      bFirstInterface         0
      bInterfaceCount         2
      bFunctionClass         14 Video
      bFunctionSubClass       3 Video Interface Collection
      bFunctionProtocol       0
      iFunction               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      1 Video Control
      bInterfaceProtocol      0
      iInterface              1
      VideoControl Interface Descriptor:
        bLength                13
        bDescriptorType        36
        bDescriptorSubtype      1 (HEADER)
        bcdUVC               1.00
        wTotalLength           50
        dwClockFrequency        0.001000MHz
        bInCollection           1
        baInterfaceNr( 0)       1
      VideoControl Interface Descriptor:
        bLength                17
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               2
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  2
        bmControls           0x00000000
      VideoControl Interface Descriptor:
        bLength                 9
        bDescriptorType        36
        bDescriptorSubtype      3 (OUTPUT_TERMINAL)
        bTerminalID             2
        wTerminalType      0x0101 USB Streaming
        bAssocTerminal          0
        bSourceID               3
        iTerminal               3
      VideoControl Interface Descriptor:
        bLength                11
        bDescriptorType        36
        bDescriptorSubtype      5 (PROCESSING_UNIT)
      Warning: Descriptor too short
        bUnitID                 3
        bSourceID               1
        wMaxMultiplier          0
        bControlSize            2
        bmControls     0x0000157b
          Brightness
          Contrast
          Saturation
          Sharpness
          Gamma
          White Balance Temperature
          Backlight Compensation
          Power Line Frequency
          White Balance Temperature, Auto
        iProcessing             4
        bmVideoStandards     0x 0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      2 Video Streaming
      bInterfaceProtocol      0
      iInterface              5
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
        INTERFACE CLASS:  0e 24 01 01 a5 00 81 00 02 02 00 00 01 00
        INTERFACE CLASS:  0b 24 06 01 03 01 01 00 00 00 00
        INTERFACE CLASS:  26 24 07 01 00 a0 00 78 00 7c 94 00 00 fe eb
0d 00 00 c0 00 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 02 00 40 01 f0 00 80 94 00 00 00 ec
0d 00 f7 60 01 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 03 00 80 02 e0 01 80 94 00 00 00 ec
0d 00 12 f3 02 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  14 24 03 00 03 a0 00 78 00 40 01 f0 00 80 02
e0 01 02 00 01
        INTERFACE CLASS:  06 24 0d 00 00 00
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          269
    bNumInterfaces          2
    bConfigurationValue     2
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower              300mA
    Interface Association:
      bLength                 8
      bDescriptorType        11
      bFirstInterface         0
      bInterfaceCount         2
      bFunctionClass         14 Video
      bFunctionSubClass       3 Video Interface Collection
      bFunctionProtocol       0
      iFunction               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      1 Video Control
      bInterfaceProtocol      0
      iInterface              1
      VideoControl Interface Descriptor:
        bLength                13
        bDescriptorType        36
        bDescriptorSubtype      1 (HEADER)
        bcdUVC               1.00
        wTotalLength           50
        dwClockFrequency        0.001000MHz
        bInCollection           1
        baInterfaceNr( 0)       1
      VideoControl Interface Descriptor:
        bLength                17
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               2
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  2
        bmControls           0x00000000
      VideoControl Interface Descriptor:
        bLength                 9
        bDescriptorType        36
        bDescriptorSubtype      3 (OUTPUT_TERMINAL)
        bTerminalID             2
        wTerminalType      0x0101 USB Streaming
        bAssocTerminal          0
        bSourceID               3
        iTerminal               3
      VideoControl Interface Descriptor:
        bLength                11
        bDescriptorType        36
        bDescriptorSubtype      5 (PROCESSING_UNIT)
      Warning: Descriptor too short
        bUnitID                 3
        bSourceID               1
        wMaxMultiplier          0
        bControlSize            2
        bmControls     0x0000157b
          Brightness
          Contrast
          Saturation
          Sharpness
          Gamma
          White Balance Temperature
          Backlight Compensation
          Power Line Frequency
          White Balance Temperature, Auto
        iProcessing             4
        bmVideoStandards     0x 0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      2 Video Streaming
      bInterfaceProtocol      0
      iInterface              5
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
        INTERFACE CLASS:  0e 24 01 01 a5 00 81 00 02 02 00 00 01 00
        INTERFACE CLASS:  0b 24 06 01 03 01 01 00 00 00 00
        INTERFACE CLASS:  26 24 07 01 00 a0 00 78 00 7c 94 00 00 fe eb
0d 00 00 c0 00 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 02 00 40 01 f0 00 80 94 00 00 00 ec
0d 00 f7 60 01 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 03 00 80 02 e0 01 80 94 00 00 00 ec
0d 00 12 f3 02 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  14 24 03 00 03 a0 00 78 00 40 01 f0 00 80 02
e0 01 02 00 01
        INTERFACE CLASS:  06 24 0d 00 00 00
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          269
    bNumInterfaces          2
    bConfigurationValue     3
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower              224mA
    Interface Association:
      bLength                 8
      bDescriptorType        11
      bFirstInterface         0
      bInterfaceCount         2
      bFunctionClass         14 Video
      bFunctionSubClass       3 Video Interface Collection
      bFunctionProtocol       0
      iFunction               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      1 Video Control
      bInterfaceProtocol      0
      iInterface              1
      VideoControl Interface Descriptor:
        bLength                13
        bDescriptorType        36
        bDescriptorSubtype      1 (HEADER)
        bcdUVC               1.00
        wTotalLength           50
        dwClockFrequency        0.001000MHz
        bInCollection           1
        baInterfaceNr( 0)       1
      VideoControl Interface Descriptor:
        bLength                17
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               2
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  2
        bmControls           0x00000000
      VideoControl Interface Descriptor:
        bLength                 9
        bDescriptorType        36
        bDescriptorSubtype      3 (OUTPUT_TERMINAL)
        bTerminalID             2
        wTerminalType      0x0101 USB Streaming
        bAssocTerminal          0
        bSourceID               3
        iTerminal               3
      VideoControl Interface Descriptor:
        bLength                11
        bDescriptorType        36
        bDescriptorSubtype      5 (PROCESSING_UNIT)
      Warning: Descriptor too short
        bUnitID                 3
        bSourceID               1
        wMaxMultiplier          0
        bControlSize            2
        bmControls     0x0000157b
          Brightness
          Contrast
          Saturation
          Sharpness
          Gamma
          White Balance Temperature
          Backlight Compensation
          Power Line Frequency
          White Balance Temperature, Auto
        iProcessing             4
        bmVideoStandards     0x 0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      2 Video Streaming
      bInterfaceProtocol      0
      iInterface              5
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
        INTERFACE CLASS:  0e 24 01 01 a5 00 81 00 02 02 00 00 01 00
        INTERFACE CLASS:  0b 24 06 01 03 01 01 00 00 00 00
        INTERFACE CLASS:  26 24 07 01 00 a0 00 78 00 7c 94 00 00 fe eb
0d 00 00 c0 00 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 02 00 40 01 f0 00 80 94 00 00 00 ec
0d 00 f7 60 01 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 03 00 80 02 e0 01 80 94 00 00 00 ec
0d 00 12 f3 02 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  14 24 03 00 03 a0 00 78 00 40 01 f0 00 80 02
e0 01 02 00 01
        INTERFACE CLASS:  06 24 0d 00 00 00
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          269
    bNumInterfaces          2
    bConfigurationValue     4
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower              150mA
    Interface Association:
      bLength                 8
      bDescriptorType        11
      bFirstInterface         0
      bInterfaceCount         2
      bFunctionClass         14 Video
      bFunctionSubClass       3 Video Interface Collection
      bFunctionProtocol       0
      iFunction               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      1 Video Control
      bInterfaceProtocol      0
      iInterface              1
      VideoControl Interface Descriptor:
        bLength                13
        bDescriptorType        36
        bDescriptorSubtype      1 (HEADER)
        bcdUVC               1.00
        wTotalLength           50
        dwClockFrequency        0.001000MHz
        bInCollection           1
        baInterfaceNr( 0)       1
      VideoControl Interface Descriptor:
        bLength                17
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               2
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  2
        bmControls           0x00000000
      VideoControl Interface Descriptor:
        bLength                 9
        bDescriptorType        36
        bDescriptorSubtype      3 (OUTPUT_TERMINAL)
        bTerminalID             2
        wTerminalType      0x0101 USB Streaming
        bAssocTerminal          0
        bSourceID               3
        iTerminal               3
      VideoControl Interface Descriptor:
        bLength                11
        bDescriptorType        36
        bDescriptorSubtype      5 (PROCESSING_UNIT)
      Warning: Descriptor too short
        bUnitID                 3
        bSourceID               1
        wMaxMultiplier          0
        bControlSize            2
        bmControls     0x0000157b
          Brightness
          Contrast
          Saturation
          Sharpness
          Gamma
          White Balance Temperature
          Backlight Compensation
          Power Line Frequency
          White Balance Temperature, Auto
        iProcessing             4
        bmVideoStandards     0x 0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      2 Video Streaming
      bInterfaceProtocol      0
      iInterface              5
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
        INTERFACE CLASS:  0e 24 01 01 a5 00 81 00 02 02 00 00 01 00
        INTERFACE CLASS:  0b 24 06 01 03 01 01 00 00 00 00
        INTERFACE CLASS:  26 24 07 01 00 a0 00 78 00 7c 94 00 00 fe eb
0d 00 00 c0 00 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 02 00 40 01 f0 00 80 94 00 00 00 ec
0d 00 f7 60 01 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 03 00 80 02 e0 01 80 94 00 00 00 ec
0d 00 12 f3 02 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  14 24 03 00 03 a0 00 78 00 40 01 f0 00 80 02
e0 01 02 00 01
        INTERFACE CLASS:  06 24 0d 00 00 00
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          269
    bNumInterfaces          2
    bConfigurationValue     5
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower               90mA
    Interface Association:
      bLength                 8
      bDescriptorType        11
      bFirstInterface         0
      bInterfaceCount         2
      bFunctionClass         14 Video
      bFunctionSubClass       3 Video Interface Collection
      bFunctionProtocol       0
      iFunction               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      1 Video Control
      bInterfaceProtocol      0
      iInterface              1
      VideoControl Interface Descriptor:
        bLength                13
        bDescriptorType        36
        bDescriptorSubtype      1 (HEADER)
        bcdUVC               1.00
        wTotalLength           50
        dwClockFrequency        0.001000MHz
        bInCollection           1
        baInterfaceNr( 0)       1
      VideoControl Interface Descriptor:
        bLength                17
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               2
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  2
        bmControls           0x00000000
      VideoControl Interface Descriptor:
        bLength                 9
        bDescriptorType        36
        bDescriptorSubtype      3 (OUTPUT_TERMINAL)
        bTerminalID             2
        wTerminalType      0x0101 USB Streaming
        bAssocTerminal          0
        bSourceID               3
        iTerminal               3
      VideoControl Interface Descriptor:
        bLength                11
        bDescriptorType        36
        bDescriptorSubtype      5 (PROCESSING_UNIT)
      Warning: Descriptor too short
        bUnitID                 3
        bSourceID               1
        wMaxMultiplier          0
        bControlSize            2
        bmControls     0x0000157b
          Brightness
          Contrast
          Saturation
          Sharpness
          Gamma
          White Balance Temperature
          Backlight Compensation
          Power Line Frequency
          White Balance Temperature, Auto
        iProcessing             4
        bmVideoStandards     0x 0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      2 Video Streaming
      bInterfaceProtocol      0
      iInterface              5
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
        INTERFACE CLASS:  0e 24 01 01 a5 00 81 00 02 02 00 00 01 00
        INTERFACE CLASS:  0b 24 06 01 03 01 01 00 00 00 00
        INTERFACE CLASS:  26 24 07 01 00 a0 00 78 00 7c 94 00 00 fe eb
0d 00 00 c0 00 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 02 00 40 01 f0 00 80 94 00 00 00 ec
0d 00 f7 60 01 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 03 00 80 02 e0 01 80 94 00 00 00 ec
0d 00 12 f3 02 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  14 24 03 00 03 a0 00 78 00 40 01 f0 00 80 02
e0 01 02 00 01
        INTERFACE CLASS:  06 24 0d 00 00 00
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          269
    bNumInterfaces          2
    bConfigurationValue     6
    iConfiguration          0
    bmAttributes         0x80
      (Bus Powered)
    MaxPower               50mA
    Interface Association:
      bLength                 8
      bDescriptorType        11
      bFirstInterface         0
      bInterfaceCount         2
      bFunctionClass         14 Video
      bFunctionSubClass       3 Video Interface Collection
      bFunctionProtocol       0
      iFunction               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      1 Video Control
      bInterfaceProtocol      0
      iInterface              1
      VideoControl Interface Descriptor:
        bLength                13
        bDescriptorType        36
        bDescriptorSubtype      1 (HEADER)
        bcdUVC               1.00
        wTotalLength           50
        dwClockFrequency        0.001000MHz
        bInCollection           1
        baInterfaceNr( 0)       1
      VideoControl Interface Descriptor:
        bLength                17
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               2
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  2
        bmControls           0x00000000
      VideoControl Interface Descriptor:
        bLength                 9
        bDescriptorType        36
        bDescriptorSubtype      3 (OUTPUT_TERMINAL)
        bTerminalID             2
        wTerminalType      0x0101 USB Streaming
        bAssocTerminal          0
        bSourceID               3
        iTerminal               3
      VideoControl Interface Descriptor:
        bLength                11
        bDescriptorType        36
        bDescriptorSubtype      5 (PROCESSING_UNIT)
      Warning: Descriptor too short
        bUnitID                 3
        bSourceID               1
        wMaxMultiplier          0
        bControlSize            2
        bmControls     0x0000157b
          Brightness
          Contrast
          Saturation
          Sharpness
          Gamma
          White Balance Temperature
          Backlight Compensation
          Power Line Frequency
          White Balance Temperature, Auto
        iProcessing             4
        bmVideoStandards     0x 0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      2 Video Streaming
      bInterfaceProtocol      0
      iInterface              5
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
        INTERFACE CLASS:  0e 24 01 01 a5 00 81 00 02 02 00 00 01 00
        INTERFACE CLASS:  0b 24 06 01 03 01 01 00 00 00 00
        INTERFACE CLASS:  26 24 07 01 00 a0 00 78 00 7c 94 00 00 fe eb
0d 00 00 c0 00 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 02 00 40 01 f0 00 80 94 00 00 00 ec
0d 00 f7 60 01 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 03 00 80 02 e0 01 80 94 00 00 00 ec
0d 00 12 f3 02 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  14 24 03 00 03 a0 00 78 00 40 01 f0 00 80 02
e0 01 02 00 01
        INTERFACE CLASS:  06 24 0d 00 00 00
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength          269
    bNumInterfaces          2
    bConfigurationValue     7
    iConfiguration          0
    bmAttributes         0xc0
      Self Powered
    MaxPower                0mA
    Interface Association:
      bLength                 8
      bDescriptorType        11
      bFirstInterface         0
      bInterfaceCount         2
      bFunctionClass         14 Video
      bFunctionSubClass       3 Video Interface Collection
      bFunctionProtocol       0
      iFunction               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      1 Video Control
      bInterfaceProtocol      0
      iInterface              1
      VideoControl Interface Descriptor:
        bLength                13
        bDescriptorType        36
        bDescriptorSubtype      1 (HEADER)
        bcdUVC               1.00
        wTotalLength           50
        dwClockFrequency        0.001000MHz
        bInCollection           1
        baInterfaceNr( 0)       1
      VideoControl Interface Descriptor:
        bLength                17
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               2
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  2
        bmControls           0x00000000
      VideoControl Interface Descriptor:
        bLength                 9
        bDescriptorType        36
        bDescriptorSubtype      3 (OUTPUT_TERMINAL)
        bTerminalID             2
        wTerminalType      0x0101 USB Streaming
        bAssocTerminal          0
        bSourceID               3
        iTerminal               3
      VideoControl Interface Descriptor:
        bLength                11
        bDescriptorType        36
        bDescriptorSubtype      5 (PROCESSING_UNIT)
      Warning: Descriptor too short
        bUnitID                 3
        bSourceID               1
        wMaxMultiplier          0
        bControlSize            2
        bmControls     0x0000157b
          Brightness
          Contrast
          Saturation
          Sharpness
          Gamma
          White Balance Temperature
          Backlight Compensation
          Power Line Frequency
          White Balance Temperature, Auto
        iProcessing             4
        bmVideoStandards     0x 0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            3
          Transfer Type            Interrupt
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0008  1x 8 bytes
        bInterval               1
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        1
      bAlternateSetting       0
      bNumEndpoints           1
      bInterfaceClass        14 Video
      bInterfaceSubClass      2 Video Streaming
      bInterfaceProtocol      0
      iInterface              5
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0040  1x 64 bytes
        bInterval               0
        INTERFACE CLASS:  0e 24 01 01 a5 00 81 00 02 02 00 00 01 00
        INTERFACE CLASS:  0b 24 06 01 03 01 01 00 00 00 00
        INTERFACE CLASS:  26 24 07 01 00 a0 00 78 00 7c 94 00 00 fe eb
0d 00 00 c0 00 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 02 00 40 01 f0 00 80 94 00 00 00 ec
0d 00 f7 60 01 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  26 24 07 03 00 80 02 e0 01 80 94 00 00 00 ec
0d 00 12 f3 02 00 20 a1 07 00 00 20 a1 07 00 20 a1 07 00 00 00 00 00
        INTERFACE CLASS:  14 24 03 00 03 a0 00 78 00 40 01 f0 00 80 02
e0 01 02 00 01
        INTERFACE CLASS:  06 24 0d 00 00 00
cannot read device status, Operation not permitted (1)

It looks I'm not the only one having this problem:
http://ubuntuforums.org/showthread.php?t=1164520

Is there any remedy for this?

Regards,
Felix.



From laurent.pinchart at skynet.be  Tue Jul  7 23:48:38 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Tue, 7 Jul 2009 23:48:38 +0200
Subject: [Linux-uvc-devel] Sirius webcam (0ac8:3330) malfunction
In-Reply-To: <4A52254B.5060509@podzimek.org>
References: <4A52254B.5060509@podzimek.org>
Message-ID: <200907072348.38805.laurent.pinchart@skynet.be>

Hi Andrej,

On Monday 06 July 2009 18:24:43 Andrej Podzimek wrote:
> Hello,
>
> I bought this $2 webcam just for fun, so this is not a serious issue. The
> problem is really simple:
>
> * The webcam works perfectly with my Asus M2N laptop (Intel USB 2.0
> controller).
> * The webcam fails with my IBM xSeries 330 server (NEC USB 2.0 controller).
>
> Both machines use a similar kernel configuration and other USB devices seem
> to work normally with both of them.
>
> When used with the server, the webcam either sends about 1 frame in 10
> seconds (with 2.6.29.4 and below), or gets stuck at the first frame
> (2.6.29.6, 2.6.30.1).
>
> I tried various combinations of the quirks (especially 0x10), but it didn't
> help at all. There was nothing new in dmesg. The only message was:
> uvcvideo: Failed to query (130) UVC control 3 (unit 2) : -32 (exp. 2). But
> his only appeared twice in about 20 module reloads and video experiments.
>
> This is weird. Those two machines must differ in some important aspect, as
> far as their USB interfaces are concerned. Is there a way to find out more
> about this?

From what I've heard, NEC USB controllers are pretty buggy.

You can try to push the uvcvideo trace level to 255. The driver will then 
print a lot of messages to the kernel log, which might help to debug the 
issue.

Best regards,

Laurent Pinchart



From bardia.vivek at gmail.com  Thu Jul  9 09:19:39 2009
From: bardia.vivek at gmail.com (Vivek Bardia)
Date: Thu, 9 Jul 2009 12:49:39 +0530
Subject: [Linux-uvc-devel] Multiple streaming interface and MPEG2-TS
	support?
In-Reply-To: <200907020133.50926.laurent.pinchart@skynet.be>
References: <E54E921FAAA9494485999DFF27C90C95@vivek>
	<200906252156.31126.laurent.pinchart@skynet.be>
	<779226550906260126x644f6e28lb222e5e1fc169196@mail.gmail.com>
	<200907020133.50926.laurent.pinchart@skynet.be>
Message-ID: <779226550907090019r64fd8d42g6f33f41eb8d7c1a3@mail.gmail.com>

Hi Laurent,

On Thu, Jul 2, 2009 at 5:03 AM, Laurent
Pinchart<laurent.pinchart at skynet.be> wrote:
> Hi Vivek,
>
> On Friday 26 June 2009 10:26:07 Vivek Bardia wrote:
>> On Fri, Jun 26, 2009 at 1:26 AM, Laurent Pinchart wrote
>> > On Monday 22 June 2009 14:23:21 Vivek Bardia wrote:
>> > > Hello Laurent,
>> > >
>> > > With respect to the mail chain below,
>> > > Would you be able to help me with regards to Multiple streaming
>> > > interfaces.
>> > >
>> > > Firstly how much effort could be required to bring up the UVC driver to
>> > > support multiple streaming interfaces and MPEG2-TS support ? In case it
>> > > is simple and already available, will you be able to provide that patch
>> > > so that I am able to test it with the hardware and get back about the
>> > > same ?
>> >
>> > Multiple streaming interfaces and MPEG2-TS are different requirements.
>> > Supporting multiple interfaces will require restructuring a good deal of
>> > the driver. I started working on that a week or two ago but had to stop
>> > for a moment (if you can send me a few hours of free time by e-mail I'll
>> > appreciate that). I should have some time this weekend or early next week
>> > to prepare a patch.
>>
>> Although I cannot send you free time by email, but can help you in
>> this regard in case you need help. I do not want to add more overhead
>> and confusion in case you are already working on it.
>>
>> > I haven't really looked into what needs to be changed for MPEG2-TS
>> > support. I don't expect it to be very difficult. I'll probably work on
>> > that over the weekend.
>>
>> Just one more thing, With regards to MPEG2-TS its just adding the
>> parsing support, if I am not wrong?
>
> Some changes might be required on the video streaming code as well. Streaming
> parameters negotiation will have to be modified too to support MPEG2-specific.
> parameters.

Thank you for the quick response from your end for adding support for
Multiple streaming interfaces.
Due to some unexpected delay at my end in getting the device, I have
not been able to test the patch you had sent.

Meanwhile I am trying to emulate such a device by duplicating
descriptors of a available normal UVC device. I will share the details
once I am done.

Meanwhile I am also trying to add support for MPEG2 - TS, Here are the
few places which I thought would require update in the UVC driver code

a.) uvc_driver.c - Format parsing support for Stream based payloads,
MPEG2-TS payload
b.) uvc_video.c - parameters negotiation, VS Interface Control
Selectors support.
c.) video streaming code to handle MaxVideoFrameSize, BmFramingInfo ?
this is the part I am bit jittery about.

Please do let me know if there is something I am missing out on else
would go ahead updating them.

Regards,
Vivek
>
> Best regards,
>
> Laurent Pinchart
>
>


From laurent.pinchart at skynet.be  Sat Jul 11 00:14:21 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Sat, 11 Jul 2009 00:14:21 +0200
Subject: [Linux-uvc-devel] Multiple streaming interface and MPEG2-TS
	support?
In-Reply-To: <779226550907090019r64fd8d42g6f33f41eb8d7c1a3@mail.gmail.com>
References: <E54E921FAAA9494485999DFF27C90C95@vivek>
	<200907020133.50926.laurent.pinchart@skynet.be>
	<779226550907090019r64fd8d42g6f33f41eb8d7c1a3@mail.gmail.com>
Message-ID: <200907110014.21974.laurent.pinchart@skynet.be>

Hi Vivek,

On Thursday 09 July 2009 09:19:39 Vivek Bardia wrote:
> Hi Laurent,
>
> On Thu, Jul 2, 2009 at 5:03 AM, Laurent
>
> Pinchart<laurent.pinchart at skynet.be> wrote:
> > Hi Vivek,
> >
> > On Friday 26 June 2009 10:26:07 Vivek Bardia wrote:
> >> On Fri, Jun 26, 2009 at 1:26 AM, Laurent Pinchart wrote
> >>
> >> > On Monday 22 June 2009 14:23:21 Vivek Bardia wrote:
> >> > > Hello Laurent,
> >> > >
> >> > > With respect to the mail chain below,
> >> > > Would you be able to help me with regards to Multiple streaming
> >> > > interfaces.
> >> > >
> >> > > Firstly how much effort could be required to bring up the UVC driver
> >> > > to support multiple streaming interfaces and MPEG2-TS support ? In
> >> > > case it is simple and already available, will you be able to provide
> >> > > that patch so that I am able to test it with the hardware and get
> >> > > back about the same ?
> >> >
> >> > Multiple streaming interfaces and MPEG2-TS are different requirements.
> >> > Supporting multiple interfaces will require restructuring a good deal
> >> > of the driver. I started working on that a week or two ago but had to
> >> > stop for a moment (if you can send me a few hours of free time by
> >> > e-mail I'll appreciate that). I should have some time this weekend or
> >> > early next week to prepare a patch.
> >>
> >> Although I cannot send you free time by email, but can help you in
> >> this regard in case you need help. I do not want to add more overhead
> >> and confusion in case you are already working on it.
> >>
> >> > I haven't really looked into what needs to be changed for MPEG2-TS
> >> > support. I don't expect it to be very difficult. I'll probably work on
> >> > that over the weekend.
> >>
> >> Just one more thing, With regards to MPEG2-TS its just adding the
> >> parsing support, if I am not wrong?
> >
> > Some changes might be required on the video streaming code as well.
> > Streaming parameters negotiation will have to be modified too to support
> > MPEG2-specific. parameters.
>
> Thank you for the quick response from your end for adding support for
> Multiple streaming interfaces.

You're welcome.

> Due to some unexpected delay at my end in getting the device, I have
> not been able to test the patch you had sent.
>
> Meanwhile I am trying to emulate such a device by duplicating
> descriptors of a available normal UVC device. I will share the details
> once I am done.

Ok.

> Meanwhile I am also trying to add support for MPEG2 - TS, Here are the
> few places which I thought would require update in the UVC driver code
>
> a.) uvc_driver.c - Format parsing support for Stream based payloads,
> MPEG2-TS payload

That should be easy. You will have to modify the uvc_format structure to add 
MPEG2-TS specific fields (rearrange the existing fields using unions like in 
uvc_entity).

As stream-based formats don't have frame descriptors, you will also have to 
walk through the driver and modify code that assumes each format has at least 
one frame descriptor. You could work around that by creating a dummy frame 
descriptor, like for the DV format, but I think it's now time to get rid of 
the "at least one frame per format" requirement.

> b.) uvc_video.c - parameters negotiation, VS Interface Control
> Selectors support.

VS controls (I suppose you're talking about the "generate key frame" and 
"update frame segment" controls) should be easy to support. They might require 
new V4L2 controls though. Parameters negotiation will be handled through V4L2 
controls, so that might require a rework of the current control handling code.

> c.) video streaming code to handle MaxVideoFrameSize, BmFramingInfo ?
> this is the part I am bit jittery about.

I don't think that will be too difficult. Or maybe I don't see the difficulty 
yet :-)

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Sat Jul 11 01:55:34 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Sat, 11 Jul 2009 01:55:34 +0200
Subject: [Linux-uvc-devel] MediaTek MT6227 on Philips 9@9U is now
	working with uvc
In-Reply-To: <4A534C83.8010201@gmail.com>
References: <4A534C83.8010201@gmail.com>
Message-ID: <200907110155.34900.laurent.pinchart@skynet.be>

Hi,

On Tuesday 07 July 2009 15:24:19 fsulima wrote:
> Hi all.
>
> MediaTek MT6227 on Philips 9 at 9U do not work. It looks like this:
>
> $ dmesg | tail
> [94425.741948] uvcvideo: Failed to query (135) UVC control 1 (unit 0) :
> -110 (exp. 26).
> [94425.743941] uvcvideo: Failed to query (129) UVC control 1 (unit 0) :
> -71 (exp. 26).
> [94425.743946] uvcvideo: Failed to initialize the device (-5).
> [94429.128037] usb 7-2: USB disconnect, address 8
> [94436.384010] usb 7-2: new full speed USB device using uhci_hcd and
> address 9
> [94436.849070] usb 7-2: configuration #1 chosen from 7 choices
> [94436.859998] uvcvideo: Found UVC 1.00 device 9 at 9U    (0e8d:0004)
> [94437.861939] uvcvideo: Failed to query (135) UVC control 1 (unit 0) :
> -110 (exp. 26).
> [94437.863947] uvcvideo: Failed to query (129) UVC control 1 (unit 0) :
> -71 (exp. 26).
> [94437.863952] uvcvideo: Failed to initialize the device (-5).

That's weird. The camera seem to crash when queried with GET_DEF. Could you 
please try the attached patch ? It might require some tweaking if you don't 
apply it on top of the latest driver version.

> $ lsusb -d 0e8d:0004 -v

[snip]

The device descriptors look *really* weird. The device exposes 7 
configurations, and the only difference between them is the power consumption. 
Are you sure you haven't received a development prototype ? :-)

> It looks I'm not the only one having this problem:
> http://ubuntuforums.org/showthread.php?t=1164520
>
> Is there any remedy for this?

Try the attached patch and let me know if it helps.

Best regards,

Laurent Pinchart


-------------- next part --------------
A non-text attachment was scrubbed...
Name: probe-def.diff
Type: text/x-patch
Size: 1613 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090711/c4ad336a/attachment.bin>

From daniel.crews at gmail.com  Mon Jul 13 12:34:04 2009
From: daniel.crews at gmail.com (Daniel Crews)
Date: Mon, 13 Jul 2009 06:34:04 -0400
Subject: [Linux-uvc-devel] Camera Selection\Settings Options
Message-ID: <efe228540907130334t504793dcl88c726ae11bb4009@mail.gmail.com>

Background:
I have been trying to find a good value low cost webcam for computer vision
on linux. My basic plan is to set the exposure high enough to max the
framerate, and use gain to make the markers I'm tracking visible. The
ugliness resulting from this shouldn't matter. Unfortunately, there seems to
be no list of what webcams allow you to set the exposure manually, and the
grab bag of various models I have now all seem to not let you do that. I'm
looking at trying the Philips SPC 900NC which is said to work with the PWC
controller, but seems discontinuedish and more expensive than I'd like to
pay... I'm willing to pay for the quality if I need it(and the product has
it!), but I'm making a system where I'll want to add as many cameras as
possible, so cheap is good (that's why I'm not going for firewire cameras,
as much as I would like to).

Specific questions:
1.)Is there anything wrong with using  "# v4lctl -c /dev/videoX list" to
check for manual exposure settings? Or could this command miss a camera that
can do it with just the stock UVC driver? (It'd be helpful to see an example
of what a camera that can do that would look like as well, eg. what to look
for.)
2.) Is there a list with what cameras do manual exposure? (And what frame
rates they can actually reach...)
3.) If not, should we try to extend the current UVC linux cam list with this
kind of extra data? Or at least bring this scattered data together in a
single, if separate, repository? (Perhaps on the wiki...)
4.) In the meantime, does anyone have any suggestions? Particularly so if
you know of a camera that does infra-red out of box or is easy to mod with
the exposed film trick, as I'd prefer to make the markers subtle to the
human eye.
5.) Some of these questions pertain to this mailing list, let me know if
some of them don't and where I should take them elsewhere....?


-- 
Fin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090713/e0a9a11c/attachment.html>

From fsulima at gmail.com  Mon Jul 13 15:02:15 2009
From: fsulima at gmail.com (Felix Sulima)
Date: Mon, 13 Jul 2009 17:02:15 +0400
Subject: [Linux-uvc-devel] Fwd: MediaTek MT6227 on Philips 9@9U is now
	working with uvc
In-Reply-To: <114d3bca0907130601s11ae89e4kcadfbe614700b2ba@mail.gmail.com>
References: <4A534C83.8010201@gmail.com>
	<200907110155.34900.laurent.pinchart@skynet.be>
	<114d3bca0907130601s11ae89e4kcadfbe614700b2ba@mail.gmail.com>
Message-ID: <114d3bca0907130602x59a6b69fo2ec70165b6fbf661@mail.gmail.com>

---------- Forwarded message ----------
From: Felix Sulima <fsulima at gmail.com>
Date: 2009/7/13
Subject: Re: [Linux-uvc-devel] MediaTek MT6227 on Philips 9 at 9U is now
working with uvc
To: Laurent Pinchart <laurent.pinchart at skynet.be>


Hi, Laurent.

This is to inform you that your patch is working.
Thank you very much!

Some more details just in case they may be important.
I'm using Jaunty with ppa kernel built on 10-Jun-2009:
http://kernel.ubuntu.com/~kernel-ppa/mainline/v2.6.30/<http://kernel.ubuntu.com/%7Ekernel-ppa/mainline/v2.6.30/>
$ uname -a
Linux eel 2.6.30-020630-generic #020630 SMP Wed Jun 10 09:04:38 UTC 2009
x86_64 GNU/Linux

Here is the id of sources I used:
http://linuxtv.org/hg/~pinchartl/uvcvideo/<http://linuxtv.org/hg/%7Epinchartl/uvcvideo/>
$ hg identify
1af5233017e6 tip

dmesg shows on unpatched build:
[19849.225014] usb 7-2: new full speed USB device using uhci_hcd and address
4
[19849.688583] usb 7-2: configuration #1 chosen from 7 choices
[19849.701499] uvcvideo: Found UVC 1.00 device 9 at 9U    (0e8d:0004)
[19850.702430] uvcvideo: UVC non compliance - GET_DEF(PROBE) not supported.
Enabling workaround.
[19850.704435] uvcvideo: Failed to query (129) UVC probe control : -71 (exp.
26).
[19850.704440] uvcvideo: Failed to initialize the device (-5).

and here is dmesg output on patched build:
[20621.336014] usb 7-2: new full speed USB device using uhci_hcd and address
5
[20621.802072] usb 7-2: configuration #1 chosen from 7 choices
[20621.813997] uvcvideo: Found UVC 1.00 device 9 at 9U    (0e8d:0004)
[20621.816089] input: 9 at 9U    as
/devices/pci0000:00/0000:00:1d.1/usb7/7-2/7-2:1.0/input/input7

Please let me know if there is anything I can help with.

Best regards,
Felix.

2009/7/11 Laurent Pinchart <laurent.pinchart at skynet.be>

Hi,
>
> On Tuesday 07 July 2009 15:24:19 fsulima wrote:
> > Hi all.
> >
> > MediaTek MT6227 on Philips 9 at 9U do not work. It looks like this:
> >
> > $ dmesg | tail
> > [94425.741948] uvcvideo: Failed to query (135) UVC control 1 (unit 0) :
> > -110 (exp. 26).
> > [94425.743941] uvcvideo: Failed to query (129) UVC control 1 (unit 0) :
> > -71 (exp. 26).
> > [94425.743946] uvcvideo: Failed to initialize the device (-5).
> > [94429.128037] usb 7-2: USB disconnect, address 8
> > [94436.384010] usb 7-2: new full speed USB device using uhci_hcd and
> > address 9
> > [94436.849070] usb 7-2: configuration #1 chosen from 7 choices
> > [94436.859998] uvcvideo: Found UVC 1.00 device 9 at 9U    (0e8d:0004)
> > [94437.861939] uvcvideo: Failed to query (135) UVC control 1 (unit 0) :
> > -110 (exp. 26).
> > [94437.863947] uvcvideo: Failed to query (129) UVC control 1 (unit 0) :
> > -71 (exp. 26).
> > [94437.863952] uvcvideo: Failed to initialize the device (-5).
>
> That's weird. The camera seem to crash when queried with GET_DEF. Could you
> please try the attached patch ? It might require some tweaking if you don't
> apply it on top of the latest driver version.
>
> > $ lsusb -d 0e8d:0004 -v
>
> [snip]
>
> The device descriptors look *really* weird. The device exposes 7
> configurations, and the only difference between them is the power
> consumption.
> Are you sure you haven't received a development prototype ? :-)
>
> > It looks I'm not the only one having this problem:
> > http://ubuntuforums.org/showthread.php?t=1164520
> >
> > Is there any remedy for this?
>
> Try the attached patch and let me know if it helps.
>
> Best regards,
>
> Laurent Pinchart
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090713/283c080b/attachment.html>

From pj.assis at gmail.com  Mon Jul 13 15:47:29 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Mon, 13 Jul 2009 14:47:29 +0100
Subject: [Linux-uvc-devel] Camera Selection\Settings Options
In-Reply-To: <efe228540907130334t504793dcl88c726ae11bb4009@mail.gmail.com>
References: <efe228540907130334t504793dcl88c726ae11bb4009@mail.gmail.com>
Message-ID: <59cf47a80907130647k1929e8b1k6fdb451f52e58faa@mail.gmail.com>

Hi,
On manual exposure I believe all logitech UVC cameras support it.
They have a wide range of uvc cameras from the very cheap to the very
expensive, price is very dependent on the quality of the sensor and of the
lens, also if the camera has motorized controls like pan/tilt or focus.
Creative and some other well known brands also have some nice UVC cameras
with exposure control. Actually from what I've encountered in terms of
hardware most uvc cameras support manual exposure, with the exception of
some builtin laptop cameras and a couple of other very cheap cameras :-).

Usually setting exposure control, means selecting the exposure setting from
a menu type control and also in some cases (logitetch at least) disabling
"Exposure, Auto Priority" control.

For IR, just remove the lens ;-), all CCD and cmos sensors are IR sensitive,
the lens usually has a IR filter that blocks it, producing a much better
image. Personally I wouldn't recommend using any camera without at least
some IR filtering, or the image noise can get very high.

Best regards,
Paulo

2009/7/13 Daniel Crews <daniel.crews at gmail.com>

> Background:
> I have been trying to find a good value low cost webcam for computer vision
> on linux. My basic plan is to set the exposure high enough to max the
> framerate, and use gain to make the markers I'm tracking visible. The
> ugliness resulting from this shouldn't matter. Unfortunately, there seems to
> be no list of what webcams allow you to set the exposure manually, and the
> grab bag of various models I have now all seem to not let you do that. I'm
> looking at trying the Philips SPC 900NC which is said to work with the PWC
> controller, but seems discontinuedish and more expensive than I'd like to
> pay... I'm willing to pay for the quality if I need it(and the product has
> it!), but I'm making a system where I'll want to add as many cameras as
> possible, so cheap is good (that's why I'm not going for firewire cameras,
> as much as I would like to).
>
> Specific questions:
> 1.)Is there anything wrong with using  "# v4lctl -c /dev/videoX list" to
> check for manual exposure settings? Or could this command miss a camera that
> can do it with just the stock UVC driver? (It'd be helpful to see an example
> of what a camera that can do that would look like as well, eg. what to look
> for.)
> 2.) Is there a list with what cameras do manual exposure? (And what frame
> rates they can actually reach...)
> 3.) If not, should we try to extend the current UVC linux cam list with
> this kind of extra data? Or at least bring this scattered data together in a
> single, if separate, repository? (Perhaps on the wiki...)
> 4.) In the meantime, does anyone have any suggestions? Particularly so if
> you know of a camera that does infra-red out of box or is easy to mod with
> the exposed film trick, as I'd prefer to make the markers subtle to the
> human eye.
> 5.) Some of these questions pertain to this mailing list, let me know if
> some of them don't and where I should take them elsewhere....?
>
>
> --
> Fin
>
> _______________________________________________
> Linux-uvc-devel mailing list
> Linux-uvc-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090713/807c0f33/attachment.html>

From laurent.pinchart at skynet.be  Tue Jul 14 00:12:30 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Tue, 14 Jul 2009 00:12:30 +0200
Subject: [Linux-uvc-devel] Camera Selection\Settings Options
In-Reply-To: <efe228540907130334t504793dcl88c726ae11bb4009@mail.gmail.com>
References: <efe228540907130334t504793dcl88c726ae11bb4009@mail.gmail.com>
Message-ID: <200907140012.31206.laurent.pinchart@skynet.be>

Hi Daniel,

On Monday 13 July 2009 12:34:04 Daniel Crews wrote:
> Background:
> I have been trying to find a good value low cost webcam for computer vision
> on linux. My basic plan is to set the exposure high enough to max the
> framerate, and use gain to make the markers I'm tracking visible. The
> ugliness resulting from this shouldn't matter. Unfortunately, there seems
> to be no list of what webcams allow you to set the exposure manually, and
> the grab bag of various models I have now all seem to not let you do that.
> I'm looking at trying the Philips SPC 900NC which is said to work with the
> PWC controller, but seems discontinuedish and more expensive than I'd like
> to pay... I'm willing to pay for the quality if I need it(and the product
> has it!), but I'm making a system where I'll want to add as many cameras as
> possible, so cheap is good (that's why I'm not going for firewire cameras,
> as much as I would like to).
>
> Specific questions:
> 1.)Is there anything wrong with using  "# v4lctl -c /dev/videoX list" to
> check for manual exposure settings? Or could this command miss a camera
> that can do it with just the stock UVC driver? (It'd be helpful to see an
> example of what a camera that can do that would look like as well, eg. what
> to look for.)

It might in theory miss cameras that can do manual exposure, but in practice I 
don't think it would. UVC allows for vendor-specific extensions through so-
called extension units. While a camera could implement manual exposure through 
an extension unit, it would make little sense as the UVC standard describes 
how to handle manual exposure through the Camera Terminal.

You can also use lsusb to list controls supported by a camera. Here's a 
snippet of the output with a camera that supports manual exposure:

      VideoControl Interface Descriptor:
        bLength                18
        bDescriptorType        36
        bDescriptorSubtype      2 (INPUT_TERMINAL)
        bTerminalID             1
        wTerminalType      0x0201 Camera Sensor
        bAssocTerminal          0
        iTerminal               0
        wObjectiveFocalLengthMin      0
        wObjectiveFocalLengthMax      0
        wOcularFocalLength            0
        bControlSize                  3
        bmControls           0x0000000a
          Auto-Exposure Mode
          Exposure Time (Absolute)

Lokk for an Input Terminal with wTerminalType set to 0x0201 (Camera Sensor), 
and check the bmControls field. It's a bit field that lists the supported 
controls. lsusb decodes it for you and will print the meaning of each set bit.

> 2.) Is there a list with what cameras do manual exposure? (And what frame
> rates they can actually reach...)

None that I'm aware of.

> 3.) If not, should we try to extend the current UVC linux cam list with
> this kind of extra data? Or at least bring this scattered data together in
> a single, if separate, repository? (Perhaps on the wiki...)

I've been thinking of adding lsusb output's for all cameras listed on the 
website. It would also be nice to have a wiki-like page for each camera where 
users could put comments. I unfortunately don't have time to work on that 
right now.

> 4.) In the meantime, does anyone have any suggestions? Particularly so if
> you know of a camera that does infra-red out of box or is easy to mod with
> the exposed film trick, as I'd prefer to make the markers subtle to the
> human eye.
> 5.) Some of these questions pertain to this mailing list, let me know if
> some of them don't and where I should take them elsewhere....?

Best regards,

Laurent Pinchart



From xavier.bestel at free.fr  Tue Jul 14 00:17:26 2009
From: xavier.bestel at free.fr (Xavier Bestel)
Date: Tue, 14 Jul 2009 00:17:26 +0200
Subject: [Linux-uvc-devel] creative webcam
Message-ID: <1247523446.6912.1.camel@badjo>

Hi,

just a short mail to say that, after a kernel update, I saw my webcam
working perfectly well (all resolutions, image upside-up).

Thanks a lot to all involved.

	Xav






From daniel.crews at gmail.com  Tue Jul 14 10:53:33 2009
From: daniel.crews at gmail.com (Daniel Crews)
Date: Tue, 14 Jul 2009 04:53:33 -0400
Subject: [Linux-uvc-devel] Camera Selection\Settings Options
In-Reply-To: <200907140012.31206.laurent.pinchart@skynet.be>
References: <efe228540907130334t504793dcl88c726ae11bb4009@mail.gmail.com>
	<200907140012.31206.laurent.pinchart@skynet.be>
Message-ID: <efe228540907140153l1dcd2573kd832d8c72c9383be@mail.gmail.com>

Thank you for your assistance. As for the wiki, I was thinking of this one
http://openfacts.berlios.de/index-en.phtml?title=Linux+UVC . I'll ask them
if I should put in the info for the cameras I have on there, but I'm not
really sure if it belongs. If I get something started somewhere I'll post
back to this mailing list with a link, but I'm not really in a position to
host it myself right now so we'll see who I can find to do that for us.

On Mon, Jul 13, 2009 at 6:12 PM, Laurent Pinchart <
laurent.pinchart at skynet.be> wrote:

> Hi Daniel,
>
> On Monday 13 July 2009 12:34:04 Daniel Crews wrote:
> > Background:
> > I have been trying to find a good value low cost webcam for computer
> vision
> > on linux. My basic plan is to set the exposure high enough to max the
> > framerate, and use gain to make the markers I'm tracking visible. The
> > ugliness resulting from this shouldn't matter. Unfortunately, there seems
> > to be no list of what webcams allow you to set the exposure manually, and
> > the grab bag of various models I have now all seem to not let you do
> that.
> > I'm looking at trying the Philips SPC 900NC which is said to work with
> the
> > PWC controller, but seems discontinuedish and more expensive than I'd
> like
> > to pay... I'm willing to pay for the quality if I need it(and the product
> > has it!), but I'm making a system where I'll want to add as many cameras
> as
> > possible, so cheap is good (that's why I'm not going for firewire
> cameras,
> > as much as I would like to).
> >
> > Specific questions:
> > 1.)Is there anything wrong with using  "# v4lctl -c /dev/videoX list" to
> > check for manual exposure settings? Or could this command miss a camera
> > that can do it with just the stock UVC driver? (It'd be helpful to see an
> > example of what a camera that can do that would look like as well, eg.
> what
> > to look for.)
>
> It might in theory miss cameras that can do manual exposure, but in
> practice I
> don't think it would. UVC allows for vendor-specific extensions through so-
> called extension units. While a camera could implement manual exposure
> through
> an extension unit, it would make little sense as the UVC standard describes
> how to handle manual exposure through the Camera Terminal.
>
> You can also use lsusb to list controls supported by a camera. Here's a
> snippet of the output with a camera that supports manual exposure:
>
>      VideoControl Interface Descriptor:
>        bLength                18
>        bDescriptorType        36
>        bDescriptorSubtype      2 (INPUT_TERMINAL)
>        bTerminalID             1
>        wTerminalType      0x0201 Camera Sensor
>        bAssocTerminal          0
>        iTerminal               0
>        wObjectiveFocalLengthMin      0
>        wObjectiveFocalLengthMax      0
>        wOcularFocalLength            0
>        bControlSize                  3
>        bmControls           0x0000000a
>          Auto-Exposure Mode
>          Exposure Time (Absolute)
>
> Lokk for an Input Terminal with wTerminalType set to 0x0201 (Camera
> Sensor),
> and check the bmControls field. It's a bit field that lists the supported
> controls. lsusb decodes it for you and will print the meaning of each set
> bit.
>
> > 2.) Is there a list with what cameras do manual exposure? (And what frame
> > rates they can actually reach...)
>
> None that I'm aware of.
>
> > 3.) If not, should we try to extend the current UVC linux cam list with
> > this kind of extra data? Or at least bring this scattered data together
> in
> > a single, if separate, repository? (Perhaps on the wiki...)
>
> I've been thinking of adding lsusb output's for all cameras listed on the
> website. It would also be nice to have a wiki-like page for each camera
> where
> users could put comments. I unfortunately don't have time to work on that
> right now.
>
> > 4.) In the meantime, does anyone have any suggestions? Particularly so if
> > you know of a camera that does infra-red out of box or is easy to mod
> with
> > the exposed film trick, as I'd prefer to make the markers subtle to the
> > human eye.
> > 5.) Some of these questions pertain to this mailing list, let me know if
> > some of them don't and where I should take them elsewhere....?
>
> Best regards,
>
> Laurent Pinchart
>
>


-- 
Fin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090714/b887949e/attachment.html>

From alex at seewald.at  Tue Jul 14 13:00:20 2009
From: alex at seewald.at (Dr. Alexander K. Seewald)
Date: Tue, 14 Jul 2009 13:00:20 +0200
Subject: [Linux-uvc-devel] Camera Selection\Settings Options
Message-ID: <20090714110020.GA17919@sdg.at>

>4.) In the meantime, does anyone have any suggestions? Particularly
>so if you know of a camera that does infra-red out of box or is easy to
>mod with the exposed film trick, as I'd prefer to make the markers subtle to
>the human eye.
If you want to mod the camera, take out the internal filter (which
block IR), get the specs of your IR LEDs and get an IR filter which
leaves only through exactly this frequency - putting this in the
camera. This will get best results.

Incidentially, did you take a look at the Wii controllers? They work
via bluetooth and have a 100Hz IR camera inside which tracks up to
four IR points. They can be used via appropriate drivers under Linux
and have been used e.g. for whiteboard applications. The high
frame-rate allows for very interactive applications, whereas most USB
webcams can only output the highest resolution at measly framerates
(5-10fps...). You are severely limited in marker design and need
specific IR LEDs, though.   http://johnnylee.net/projects/wii/

I agree that the UVC cameras by Logitech are quite good. I've used
the QC 9000 in a few projects and the image quality is very good for
image processing, face recognition works out of the box, etc.. So
using that and using visible-light markers would also be an option.

Best,
  Alex
-- 
Dr. Alexander K. Seewald

Seewald Solutions
www.seewald.at
Tel. +43(664)1106886
Fax. +43(1)2533033/2764


From malte.gell at gmx.de  Wed Jul 15 09:18:50 2009
From: malte.gell at gmx.de (Malte Gell)
Date: Wed, 15 Jul 2009 09:18:50 +0200
Subject: [Linux-uvc-devel] voice recorded with webcam too fast, too high
Message-ID: <200907150918.51285.malte.gell@gmx.de>

Hello there!

Finally I can record voice with my Philips SPC620NC, after being so clever to 
first load snd-usb-audio......

Now, the problem is when recording sound, e.g. using ALSA with arecord -vvv -D 
plughw:1 test.wav it sounds like Mickey Mouse... I do not know whether it is 
too fast, but definitely it is too high my voice...

I know, this is not a uvc issue, but a webcam issue and ALSA folks could not 
help either, so maybe someone here has a hint....

The same happens with Skype, when I use the webcam as input device, my voice 
sounds like Mickey Mouse...

Thanx
Malte


From malte.gell at gmx.de  Wed Jul 15 21:11:09 2009
From: malte.gell at gmx.de (Malte Gell)
Date: Wed, 15 Jul 2009 21:11:09 +0200
Subject: [Linux-uvc-devel] voice recorded with webcam too fast, too high
In-Reply-To: <200907150918.51285.malte.gell@gmx.de>
References: <200907150918.51285.malte.gell@gmx.de>
Message-ID: <200907152111.09633.malte.gell@gmx.de>


Malte Gell <malte.gell at gmx.de> wrote

> Finally I can record voice with my Philips SPC620NC, after being so clever
> to first load snd-usb-audio......
>
> Now, the problem is when recording sound, e.g. using ALSA with arecord -vvv
> -D plughw:1 test.wav it sounds like Mickey Mouse... I do not know whether
> it is too fast, but definitely it is too high my voice...

Ok, I found the problem, need to set sample rate to 18ooo HZ, this command 
does the job:

arecord -vv -D hw:1,0 -c 1 -f S16_LE --rate=18000-v test.wav

Now I only need to find out where to write it down so ALSA always talks at 
18000 Hz to that device...



From pj.assis at gmail.com  Wed Jul 15 23:15:38 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Wed, 15 Jul 2009 22:15:38 +0100
Subject: [Linux-uvc-devel] voice recorded with webcam too fast, too high
In-Reply-To: <200907152111.09633.malte.gell@gmx.de>
References: <200907150918.51285.malte.gell@gmx.de>
	<200907152111.09633.malte.gell@gmx.de>
Message-ID: <59cf47a80907151415y5e043bddg418c3eed2774c3ba@mail.gmail.com>

Hi,
I think unless you are using a sound server, the sample rate must be set
from the application side, even if you set a default in ALSA it would be
overridden by the application value.
In the case you want to record from a sound server, then (at least for
pulse) you can use any sample rate and the server will adjust it internally
to the maximum device sample rate, there is absolutely no gain in quality by
setting it higher than the maximum supported, but it is allowed.

Best regards,
Paulo

2009/7/15 Malte Gell <malte.gell at gmx.de>

>
> Malte Gell <malte.gell at gmx.de> wrote
>
> > Finally I can record voice with my Philips SPC620NC, after being so
> clever
> > to first load snd-usb-audio......
> >
> > Now, the problem is when recording sound, e.g. using ALSA with arecord
> -vvv
> > -D plughw:1 test.wav it sounds like Mickey Mouse... I do not know whether
> > it is too fast, but definitely it is too high my voice...
>
> Ok, I found the problem, need to set sample rate to 18ooo HZ, this command
> does the job:
>
> arecord -vv -D hw:1,0 -c 1 -f S16_LE --rate=18000-v test.wav
>
> Now I only need to find out where to write it down so ALSA always talks at
> 18000 Hz to that device...
>
> _______________________________________________
> Linux-uvc-devel mailing list
> Linux-uvc-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090715/f0a2bce2/attachment.html>

From malte.gell at gmx.de  Thu Jul 16 06:56:58 2009
From: malte.gell at gmx.de (Malte Gell)
Date: Thu, 16 Jul 2009 06:56:58 +0200
Subject: [Linux-uvc-devel] voice recorded with webcam too fast, too high
In-Reply-To: <59cf47a80907151415y5e043bddg418c3eed2774c3ba@mail.gmail.com>
References: <200907150918.51285.malte.gell@gmx.de>
	<200907152111.09633.malte.gell@gmx.de>
	<59cf47a80907151415y5e043bddg418c3eed2774c3ba@mail.gmail.com>
Message-ID: <200907160656.59095.malte.gell@gmx.de>

Hi !

Paulo Assis <pj.assis at gmail.com> wrote

> Hi,
> I think unless you are using a sound server, the sample rate must be set
> from the application side, even if you set a default in ALSA it would be
> overridden by the application value.
> In the case you want to record from a sound server, then (at least for
> pulse) you can use any sample rate and the server will adjust it internally
> to the maximum device sample rate, there is absolutely no gain in quality
> by setting it higher than the maximum supported, but it is allowed.

Ok, I've set the sample rate with ALSA and it seems to work using arecord and 
Skype. How do I achieve the same with pulseaudio? How do I set the sample rate 
with pulse? The device is hw:1,0 the webcam. Then I have to set the webcam the 
primary input device and use pulse in the app, right?

Malte


From pj.assis at gmail.com  Fri Jul 17 01:24:04 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Fri, 17 Jul 2009 00:24:04 +0100
Subject: [Linux-uvc-devel] voice recorded with webcam too fast, too high
In-Reply-To: <200907160656.59095.malte.gell@gmx.de>
References: <200907150918.51285.malte.gell@gmx.de>
	<200907152111.09633.malte.gell@gmx.de>
	<59cf47a80907151415y5e043bddg418c3eed2774c3ba@mail.gmail.com>
	<200907160656.59095.malte.gell@gmx.de>
Message-ID: <59cf47a80907161624n2f8bfe65o8f09727e00f8adc9@mail.gmail.com>

Hi,

> How do I set the sample rate
> with pulse? The device is hw:1,0 the webcam. Then I have to set the webcam
> the
> primary input device and use pulse in the app, right?
>
> Malte
>

Yes, you must set the webcam mic has the default input device and then use
the pulse virtual device (alsa) or a pulse client instead.
You should now be able to set any sample rate you want with arecord,
audacity, or any other app.
You can check/set your input devices with pavucontrol, check the recording
tab (while recording) for the volume meter.

Best regards,
Paulo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090717/ab8cc3c6/attachment.html>

From j.kapitza at schwarze-allianz.de  Tue Jul 21 01:17:37 2009
From: j.kapitza at schwarze-allianz.de (Jens Kapitza)
Date: Tue, 21 Jul 2009 01:17:37 +0200
Subject: [Linux-uvc-devel] searching a way to get an image from webcam
Message-ID: <4A64FB11.7050301@schwarze-allianz.de>

hi,

i'm trying to get an image from my webcam
(eeepc 1000H - Bus 001 Device 002: ID 04f2:b071 Chicony Electronics Co., 
Ltd 2.0M UVC WebCam / CNF7129)

i'm searching a way to enable the webcam but i can't find the right 
order for a call (ioctl)

i've tried to debug the luvcview programm and i'm reading throught V4L2 
API and docu

I have not found a way to enabled the cam, and i found no doku (example)
Is this a V4L2 problem or a driver problem? can someone give me a hint 
where i should go next?


---
Jens Kapitza


From shaohuang at gmail.com  Tue Jul 21 08:53:42 2009
From: shaohuang at gmail.com (Brian Pin)
Date: Mon, 20 Jul 2009 23:53:42 -0700
Subject: [Linux-uvc-devel] How to avoid negotiation loop..
Message-ID: <a81f87bb0907202353i1cc59d3and2c9c9154b9e4293@mail.gmail.com>

Dear developers...
I am recently building a UVC webcam and have encountered a problem with
streaming negotiation. The host is M$ Windows. UVC firmware is using my own
Linux-based firmware.
I get the following PROBE_GET -> PROBE_SET loop, and it never get finished.

   0h00m33s606: (T) Pb_GET: fmt:1 frame:1 Int:333333 F_SZ:276480 PayL:1024
   0h00m33s607: (T) Pb_SET: fmt:1 frame:1 Int:333333 F_SZ:276480 PayL:0
   0h00m33s608: (T) Pb_GET: fmt:1 frame:1 Int:333333 F_SZ:276480 PayL:992
   0h00m33s610: (T) Pb_GET: fmt:1 frame:1 Int:333333 F_SZ:276480 PayL:992
   0h00m33s611: (T) Pb_SET: fmt:1 frame:1 Int:333333 F_SZ:276480 PayL:0
   0h00m33s611: (T) Pb_GET: fmt:1 frame:1 Int:333333 F_SZ:276480 PayL:960
   0h00m33s612: (T) Pb_GET: fmt:1 frame:1 Int:333333 F_SZ:276480 PayL:960
   0h00m33s613: (T) Pb_SET: fmt:1 frame:2 Int:333333 F_SZ:276480 PayL:0
   0h00m33s613: (T) Pb_GET: fmt:1 frame:2 Int:333333 F_SZ:144000 PayL:1024
   0h00m33s614: (T) Pb_GET: fmt:1 frame:2 Int:333333 F_SZ:144000 PayL:1024
   0h00m33s615: (T) Pb_SET: fmt:1 frame:2 Int:333333 F_SZ:144000 PayL:0
   0h00m33s616: (T) Pb_GET: fmt:1 frame:2 Int:333333 F_SZ:144000 PayL:992
   :
   :
frame 1 is a MJPEG frame with
resolution 1280x720. frame 2 is a smaller frame with resolution 800x600(I
have more frame descriptor, I am not including them because of simplicity)
F_SZ is the maximum possible frame size for this frame index chosen.
PayL is the maximum payload size for the corresponding streaming parameter
field.
All the other field: quality, key/p-framerate are considered unrelated
because it is set to 0 by device.
Pb_GET/Pb_SET is to represent PROBE_GET and PROBE_SET.
The decreasing of PayL is by my negotiation code. I originally hope
negotiation can be done by decrease PayL by 32 everytime.
I am using only one kind of alternate interface. That is 1 ISOC packet every
micro frame and maxpacketsize is 1024.
Don't have a clue on how to make it done.
Thanks for helping me or giving me some comments.




-- 
Best Regards
Brian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090720/4206274d/attachment.html>

From phil at sanslogic.co.uk  Tue Jul 21 09:07:07 2009
From: phil at sanslogic.co.uk (Philip Heron)
Date: Tue, 21 Jul 2009 08:07:07 +0100
Subject: [Linux-uvc-devel] searching a way to get an image from webcam
In-Reply-To: <4A64FB11.7050301@schwarze-allianz.de>
References: <4A64FB11.7050301@schwarze-allianz.de>
Message-ID: <4A65691B.8040404@sanslogic.co.uk>

Hi Jens,

Jens Kapitza wrote:
> I have not found a way to enabled the cam, and i found no doku (example)
> Is this a V4L2 problem or a driver problem? can someone give me a hint 
> where i should go next?

Check the BIOS, there is an option to disable/enable it there.

-Phil


From jon.fairbairn at cl.cam.ac.uk  Tue Jul 21 11:03:58 2009
From: jon.fairbairn at cl.cam.ac.uk (Jon Fairbairn)
Date: Tue, 21 Jul 2009 10:03:58 +0100
Subject: [Linux-uvc-devel] searching a way to get an image from webcam
References: <4A64FB11.7050301@schwarze-allianz.de>
Message-ID: <wfk5228l1d.fsf@calligramme.charmers>

Jens Kapitza <j.kapitza at schwarze-allianz.de> writes:

> hi,
>
> i'm trying to get an image from my webcam
> (eeepc 1000H - Bus 001 Device 002: ID 04f2:b071 Chicony Electronics Co., 
> Ltd 2.0M UVC WebCam / CNF7129)
>
> i'm searching a way to enable the webcam but i can't find the right 
> order for a call (ioctl)
>
> i've tried to debug the luvcview programm and i'm reading throught V4L2 
> API and docu
>
> I have not found a way to enabled the cam, and i found no doku (example)
> Is this a V4L2 problem or a driver problem? can someone give me a hint 
> where i should go next?

Did you try here: <http://wiki.eeeuser.com/howto:controlcamera>?

I think I put the cat mentioned there in my rc.local

--
J?n Fairbairn                                 Jon.Fairbairn at cl.cam.ac.uk




From laurent.pinchart at skynet.be  Tue Jul 21 11:20:20 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Tue, 21 Jul 2009 11:20:20 +0200
Subject: [Linux-uvc-devel] searching a way to get an image from webcam
In-Reply-To: <4A64FB11.7050301@schwarze-allianz.de>
References: <4A64FB11.7050301@schwarze-allianz.de>
Message-ID: <200907211120.20900.laurent.pinchart@skynet.be>

Hi Jens,

On Tuesday 21 July 2009 01:17:37 Jens Kapitza wrote:
> hi,
>
> i'm trying to get an image from my webcam
> (eeepc 1000H - Bus 001 Device 002: ID 04f2:b071 Chicony Electronics Co.,
> Ltd 2.0M UVC WebCam / CNF7129)
>
> i'm searching a way to enable the webcam but i can't find the right
> order for a call (ioctl)
>
> i've tried to debug the luvcview programm and i'm reading throught V4L2
> API and docu
>
> I have not found a way to enabled the cam, and i found no doku (example)
> Is this a V4L2 problem or a driver problem? can someone give me a hint
> where i should go next?

What do you mean exactly be "enable the webcam" ? If you're looking for a 
simple example of how to capture images from the camera, have a look at 
http://v4l2spec.bytesex.org/spec/capture-example.html. You might want to use 
the userspace libv4l2 library (http://people.atrpms.net/~hdegoede/).

Regards,

Laurent Pinchart



From j.kapitza at schwarze-allianz.de  Tue Jul 21 11:55:09 2009
From: j.kapitza at schwarze-allianz.de (Jens Kapitza)
Date: Tue, 21 Jul 2009 11:55:09 +0200
Subject: [Linux-uvc-devel] searching a way to get an image from webcam
In-Reply-To: <wfk5228l1d.fsf@calligramme.charmers>
References: <4A64FB11.7050301@schwarze-allianz.de>
	<wfk5228l1d.fsf@calligramme.charmers>
Message-ID: <4A65907D.8060603@schwarze-allianz.de>



> Did you try here: <http://wiki.eeeuser.com/howto:controlcamera>?

The camera is enabled - skype or luvcview is working. But i can't get it 
work in my app.

I'm able to open the dev but if i tries to request the buffer i get -1 
from ioctl

i see a green led if an application is reading from cam.
I thought i've forget to do an ioctl to make the cam ready.

---
Jens Kapitza
now reading throught the links.


From laurent.pinchart at skynet.be  Tue Jul 21 12:26:40 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Tue, 21 Jul 2009 12:26:40 +0200
Subject: [Linux-uvc-devel] searching a way to get an image from webcam
In-Reply-To: <4A65907D.8060603@schwarze-allianz.de>
References: <4A64FB11.7050301@schwarze-allianz.de>
	<wfk5228l1d.fsf@calligramme.charmers>
	<4A65907D.8060603@schwarze-allianz.de>
Message-ID: <200907211226.40970.laurent.pinchart@skynet.be>

On Tuesday 21 July 2009 11:55:09 Jens Kapitza wrote:
> > Did you try here: <http://wiki.eeeuser.com/howto:controlcamera>?
>
> The camera is enabled - skype or luvcview is working. But i can't get it
> work in my app.
>
> I'm able to open the dev but if i tries to request the buffer i get -1
> from ioctl
>
> i see a green led if an application is reading from cam.
> I thought i've forget to do an ioctl to make the cam ready.

In a nutshell,

open()
VIDIOC_S_FMT
VIDIOC_REQBUFS
VIDIOC_QUERYBUF
mmap()
VIDIOC_QBUF
VIDIOC_STREAMON

If you get an error from any of those check errno and look up the meaning in 
the V4L2 spec. The driver might also print useful messages to the kernel log 
from times to times.

Regards,

Laurent Pinchart



From j.kapitza at schwarze-allianz.de  Tue Jul 21 12:42:31 2009
From: j.kapitza at schwarze-allianz.de (Jens Kapitza)
Date: Tue, 21 Jul 2009 12:42:31 +0200
Subject: [Linux-uvc-devel] [SOLVED] searching a way to get an image from
 webcam
In-Reply-To: <4A65907D.8060603@schwarze-allianz.de>
References: <4A64FB11.7050301@schwarze-allianz.de>	<wfk5228l1d.fsf@calligramme.charmers>
	<4A65907D.8060603@schwarze-allianz.de>
Message-ID: <4A659B97.9070209@schwarze-allianz.de>

http://v4l2spec.bytesex.org/spec/capture-example.html

thx, for the link, know it works (the cam. led turns on)

- just need to change the device_name

i'll evaluate the source now, i think i've forget to copy one line

---
Jens Kapitza

thanks @all




From tommaso.gardumi at gmail.com  Tue Jul 21 14:53:00 2009
From: tommaso.gardumi at gmail.com (Tommaso)
Date: Tue, 21 Jul 2009 14:53:00 +0200
Subject: [Linux-uvc-devel]  settings for Device 002: ID 0402:5606 ALi Corp
Message-ID: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>

Hello, I've been trying to solve this problem by myself for a long
time without success, so here I am looking for some help.
My laptop has a webcam that was working perfectly before some kernel
update, i guess it happened after upgrading to ubuntu 8.04.
lsusb gives me this device:
Bus 001 Device 002: ID 0402:5606 ALi Corp.
That is listed as a uvc working webcam.
Basically the webcam is detected and recognized, but there are some
problems with the resolution, colors and brightness.
I have to put a strong light in front of me, and even like that the
image is dark and blue, and i have to move a bit to the right in order
to be in the center of the camera.
I'm running ubuntu 9.04 with kernel 2.6.28-13 and i have downloaded
and compiled the uvcvideo-1af5233017e6 driver.
And if somebody can guide me on fixing this I would be grateful


From pj.assis at gmail.com  Tue Jul 21 15:29:57 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Tue, 21 Jul 2009 14:29:57 +0100
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
Message-ID: <59cf47a80907210629x6d5dad53w1f911c8c923ecede@mail.gmail.com>

Hi,
Could you post the output of "guvcview --verbose" and dmesg,

also could you try different resolutions and fps values?

Best regards,
Paulo



2009/7/21 Tommaso <tommaso.gardumi at gmail.com>

> Hello, I've been trying to solve this problem by myself for a long
> time without success, so here I am looking for some help.
> My laptop has a webcam that was working perfectly before some kernel
> update, i guess it happened after upgrading to ubuntu 8.04.
> lsusb gives me this device:
> Bus 001 Device 002: ID 0402:5606 ALi Corp.
> That is listed as a uvc working webcam.
> Basically the webcam is detected and recognized, but there are some
> problems with the resolution, colors and brightness.
> I have to put a strong light in front of me, and even like that the
> image is dark and blue, and i have to move a bit to the right in order
> to be in the center of the camera.
> I'm running ubuntu 9.04 with kernel 2.6.28-13 and i have downloaded
> and compiled the uvcvideo-1af5233017e6 driver.
> And if somebody can guide me on fixing this I would be grateful
> _______________________________________________
> Linux-uvc-devel mailing list
> Linux-uvc-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090721/f65b6004/attachment.html>

From pj.assis at gmail.com  Tue Jul 21 16:58:31 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Tue, 21 Jul 2009 15:58:31 +0100
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <1248185563.3825.10.camel@tobarello-laptop>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
	<59cf47a80907210629x6d5dad53w1f911c8c923ecede@mail.gmail.com>
	<1248185563.3825.10.camel@tobarello-laptop>
Message-ID: <59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>

Tommaso,

guvcview presents a standard output, as for dmesg:

uvcvideo: Failed to query (129) UVC control 3 (unit 1) : -32 (exp. 1).
uvcvideo: device USB2.0 Camera requested null bandwidth, defaulting to lowest.

I'm not sure if this could be the cause for the problems you are experiencing.
If you change the output format between MJPEG and YUV does it make any
difference (make sure to experiment with several resolutions and fps)?

You could also increase uvcvideo trace level, if you didn't already.

Best regards,
Paulo




2009/7/21 Tommaso Gardumi <tommaso.gardumi at gmail.com>
>
> Hi Paul, thanks for the quick response,
> I've tried changing resolution and fps values, but no big changes.
> I see that switching to different resolutions and trying to
> resize/maximize the window, the images from the webcam doesn't resize
> accordingly (maybe it's the normal behaviour)
> I've attached the output of the two commands you suggested me.
>
>
> Il giorno mar, 21/07/2009 alle 14.29 +0100, Paulo Assis ha scritto:
> > guvcview --verbose


From pj.assis at gmail.com  Tue Jul 21 17:02:37 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Tue, 21 Jul 2009 16:02:37 +0100
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
	<59cf47a80907210629x6d5dad53w1f911c8c923ecede@mail.gmail.com>
	<1248185563.3825.10.camel@tobarello-laptop>
	<59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>
Message-ID: <59cf47a80907210802u7cac0a17q5bcedccaf087bac0@mail.gmail.com>

Also make sure to set an appropriate  value to exposure and white balance.
hue also seems to be set at an invalid value!!!

guvcview output:
Hue, -4:1:4, default 0

Best regards,
Paulo

2009/7/21 Paulo Assis <pj.assis at gmail.com>:
> Tommaso,
>
> guvcview presents a standard output, as for dmesg:
>
> uvcvideo: Failed to query (129) UVC control 3 (unit 1) : -32 (exp. 1).
> uvcvideo: device USB2.0 Camera requested null bandwidth, defaulting to lowest.
>
> I'm not sure if this could be the cause for the problems you are experiencing.
> If you change the output format between MJPEG and YUV does it make any
> difference (make sure to experiment with several resolutions and fps)?
>
> You could also increase uvcvideo trace level, if you didn't already.
>
> Best regards,
> Paulo
>
>
>
>
> 2009/7/21 Tommaso Gardumi <tommaso.gardumi at gmail.com>
>>
>> Hi Paul, thanks for the quick response,
>> I've tried changing resolution and fps values, but no big changes.
>> I see that switching to different resolutions and trying to
>> resize/maximize the window, the images from the webcam doesn't resize
>> accordingly (maybe it's the normal behaviour)
>> I've attached the output of the two commands you suggested me.
>>
>>
>> Il giorno mar, 21/07/2009 alle 14.29 +0100, Paulo Assis ha scritto:
>> > guvcview --verbose
>


From laurent.pinchart at skynet.be  Tue Jul 21 17:05:39 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Tue, 21 Jul 2009 17:05:39 +0200
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <59cf47a80907210802u7cac0a17q5bcedccaf087bac0@mail.gmail.com>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
	<59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>
	<59cf47a80907210802u7cac0a17q5bcedccaf087bac0@mail.gmail.com>
Message-ID: <200907211705.40248.laurent.pinchart@skynet.be>

On Tuesday 21 July 2009 17:02:37 Paulo Assis wrote:
> Also make sure to set an appropriate  value to exposure and white balance.
> hue also seems to be set at an invalid value!!!
>
> guvcview output:
> Hue, -4:1:4, default 0

As this is consecutive to an Ubuntu upgrade, my guess is that libv4l2 might 
not set proper default values.

Regards,

Laurent Pinchart



From pj.assis at gmail.com  Tue Jul 21 17:18:40 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Tue, 21 Jul 2009 16:18:40 +0100
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <200907211705.40248.laurent.pinchart@skynet.be>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
	<59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>
	<59cf47a80907210802u7cac0a17q5bcedccaf087bac0@mail.gmail.com>
	<200907211705.40248.laurent.pinchart@skynet.be>
Message-ID: <59cf47a80907210818j2fb5f7dcn28e76b0b72e32e81@mail.gmail.com>

No, my mistake sorry, it is an unusual value but still it should be valid.
guvcview doesn't use any libv4l2 stuff it gets is values directly from the
the driver (at least it should):
ioctl (fd, VIDIOC_QUERYCTRL, &queryctrl)

In this case Hue only has 8 possible values, in my cameras I believe I have
a bigger range.

Best regards,
Paulo


2009/7/21 Laurent Pinchart <laurent.pinchart at skynet.be>:
> On Tuesday 21 July 2009 17:02:37 Paulo Assis wrote:
>> Also make sure to set an appropriate  value to exposure and white
balance.
>> hue also seems to be set at an invalid value!!!
>>
>> guvcview output:
>> Hue, -4:1:4, default 0
>
> As this is consecutive to an Ubuntu upgrade, my guess is that libv4l2
might
> not set proper default values.
>
> Regards,
>
> Laurent Pinchart
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090721/d0aa2fa9/attachment.html>

From pj.assis at gmail.com  Tue Jul 21 18:42:56 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Tue, 21 Jul 2009 17:42:56 +0100
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <1248191912.3825.26.camel@tobarello-laptop>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
	<59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>
	<59cf47a80907210802u7cac0a17q5bcedccaf087bac0@mail.gmail.com>
	<200907211705.40248.laurent.pinchart@skynet.be>
	<1248191912.3825.26.camel@tobarello-laptop>
Message-ID: <59cf47a80907210942i757c7b20k80368d142a9a7733@mail.gmail.com>

Hi,
The colors are completly wrong it looks like a color channel is missing or
maybe switched.
Are you sure this is not a graphic card issue ? Could you try disabling
hardware acceleration:
guvcview --hwd_acel=0
This prevents the use of hardware overlays, it decreases performance but
could if the colors are OK it may signal a problem with you graphic card.

best regards,
Paulo

2009/7/21 Tommaso Gardumi <tommaso.gardumi at gmail.com>

> Sorry the strange values was an attempt to correct the default broken
> visualisation.
>
> I've set everithing back to default but what i get is always the same.
> I've noticed that when i try to switch to Auto exposure i get this
> error:
> VIDIOC_S_CTRL - Unable to set control: Errore di I/O
> Exposure, Auto Priority change to 1 failed
> VIDIOC_G_CTRL - Unable to get control: Errore di I/O
> hardware get failed
>
> And if i set to manual exposure and try to change the value nothing
> happens.
>  Even switching between MJPG and YUYV and changing resolution and fps to
> any possible combination leave me with this quality (.jpg attached)
>
>
> Il giorno mar, 21/07/2009 alle 17.05 +0200, Laurent Pinchart ha scritto:
> > On Tuesday 21 July 2009 17:02:37 Paulo Assis wrote:
> > > Also make sure to set an appropriate  value to exposure and white
> balance.
> > > hue also seems to be set at an invalid value!!!
> > >
> > > guvcview output:
> > > Hue, -4:1:4, default 0
> >
> > As this is consecutive to an Ubuntu upgrade, my guess is that libv4l2
> might
> > not set proper default values.
> >
> > Regards,
> >
> > Laurent Pinchart
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090721/4780662d/attachment.html>

From R.E.Wolff at BitWizard.nl  Wed Jul 22 13:34:06 2009
From: R.E.Wolff at BitWizard.nl (Rogier Wolff)
Date: Wed, 22 Jul 2009 13:34:06 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
Message-ID: <20090722113406.GF1662@bitwizard.nl>




Hi, 

I bought a 5 mpixel webcam. And as a reviewer mentioned "better than
1.3 mpixel", I expected about 1.3Mpixels.

It seems to be 0.3 mpixels: 640x480. However I can't seem to be able to
change resolutions in wxcam. 

Anyway, wxcam sees a 640x480 image, but every other program that
I've been trying gives errors: 
gqcam 
lucview
xine
codeine
mplayer

gqcam is the most "informative": It shows:
  Error reading image...
at a rate similar to the refresh rate. 


It currently shows on my USB bus: 

Bus 008 Device 002: ID 058f:3820 Alcor Micro Corp. 

I'm running a standard Ubuntu Jaunty system with 

Linux version 2.6.28-13-generic (buildd at vernadsky) (gcc version 4.3.3 (Ubuntu 4.3.3-5ubuntu4) ) #45-Ubuntu SMP Tue Jun 30 19:49:51 UTC 2009

Any suggestions to get this to work "across the line"?

(I'm not on the list. please keep me CC-ed. Hope this goes through. )


	Roger. 

P.S. It doesn't. 

P.P.S. Mailman stinks. The standard says Email addresses are case
insensitive. I subscribe in all-lowercase, it doesn't go through if I
send from my "normal" spelling email address, e.g. as in my signature.

-- 
** R.E.Wolff at BitWizard.nl ** http://www.BitWizard.nl/ ** +31-15-2600998 **
**    Delftechpark 26 2628 XH  Delft, The Netherlands. KVK: 27239233    **
*-- BitWizard writes Linux device drivers for any device you may have! --*
Q: It doesn't work. A: Look buddy, doesn't work is an ambiguous statement. 
Does it sit on the couch all day? Is it unemployed? Please be specific! 
Define 'it' and what it isn't doing. --------- Adapted from lxrbot FAQ


From laurent.pinchart at skynet.be  Wed Jul 22 13:57:39 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Wed, 22 Jul 2009 13:57:39 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <20090722113406.GF1662@bitwizard.nl>
References: <20090722113406.GF1662@bitwizard.nl>
Message-ID: <200907221357.39763.laurent.pinchart@skynet.be>

On Wednesday 22 July 2009 13:34:06 Rogier Wolff wrote:
> Hi,
>
> I bought a 5 mpixel webcam. And as a reviewer mentioned "better than
> 1.3 mpixel", I expected about 1.3Mpixels.
>
> It seems to be 0.3 mpixels: 640x480. However I can't seem to be able to
> change resolutions in wxcam.

Based on the USB VID:PID, your camera supports the following resolutions:

160x120
176x144
320x240
352x288
640x480

'lsusb -v -d 058f:3820' can help you quickly verify this.

> Anyway, wxcam sees a 640x480 image, but every other program that
> I've been trying gives errors:
> gqcam
> lucview
> xine
> codeine
> mplayer
>
> gqcam is the most "informative": It shows:
>   Error reading image...
> at a rate similar to the refresh rate.

Does the driver print any error message to the kernel log ? What error 
messages does luvcview print ?

> P.P.S. Mailman stinks. The standard says Email addresses are case
> insensitive. I subscribe in all-lowercase, it doesn't go through if I
> send from my "normal" spelling email address, e.g. as in my signature.

Really ? RFC281, page 13

"The local-part of a mailbox MUST BE treated as case sensitive."

Best regards,

Laurent Pinchart



From pj.assis at gmail.com  Wed Jul 22 15:01:16 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Wed, 22 Jul 2009 14:01:16 +0100
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <1248254198.4409.14.camel@tobarello-laptop>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
	<59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>
	<59cf47a80907210802u7cac0a17q5bcedccaf087bac0@mail.gmail.com>
	<200907211705.40248.laurent.pinchart@skynet.be>
	<1248191912.3825.26.camel@tobarello-laptop>
	<59cf47a80907210942i757c7b20k80368d142a9a7733@mail.gmail.com>
	<1248254198.4409.14.camel@tobarello-laptop>
Message-ID: <59cf47a80907220601x455d2449w179d4e16f43ce8ee@mail.gmail.com>

Tommaso,

I find it strange that you cannot change the exposure setting, please
set the trace parameter to 255,
edit /etc/modprobe.d/uvcvideo.conf and add:
options uvcvideo trace=255

now reload the uvcvideo module, and check dmesg after tweaking the
exposure control (set it to manual, disable "Exposure, Auto Priority"
and change the "Exposure (Absolute)" value).

Best regards,
Paulo


2009/7/22 Tommaso Gardumi <tommaso.gardumi at gmail.com>
>
> Hi Paul,
> no good news in the direction you suggested me.
> Just to be more specfic this my graphic card:
> dmesg | grep intel
> [?? 10.484033] agpgart-intel 0000:00:00.0: Intel 965GM Chipset
> [?? 10.484804] agpgart-intel 0000:00:00.0: detected 7676K stolen memory
> [?? 10.487429] agpgart-intel 0000:00:00.0: AGP aperture is 256M @ 0xd0000000
>
> And again, don't know if it's normal but look at this output:
> dmesg | grep video
> [??? 1.239259] pci 0000:00:02.0: Boot video device
> [?? 10.842081] Linux video capture interface: v2.00
> [?? 10.919121] uvcvideo: Found UVC 1.00 device USB2.0 Camera (0402:5606)
> [?? 10.935215] usbcore: registered new interface driver uvcvideo
> [? 109.687343] uvcvideo: UVC non compliance - GET_MIN/MAX(PROBE) incorrectly supported. Enabling workaround.
> [? 171.749878] uvcvideo: Failed to query (129) UVC control 3 (unit 1) : -32 (exp. 1).
> [? 171.750501] uvcvideo: Failed to query (129) UVC control 3 (unit 1) : -32 (exp. 1).
> [? 173.143512] uvcvideo: device USB2.0 Camera requested null bandwidth, defaulting to lowest.
>
> Thanks
>
>
>
>
> Il giorno mar, 21/07/2009 alle 17.42 +0100, Paulo Assis ha scritto:
>
> Hi,
> The colors are completly wrong it looks like a color channel is missing or maybe switched.
> Are you sure this is not a graphic card issue ? Could you try disabling hardware acceleration:
> guvcview --hwd_acel=0
> This prevents the use of hardware overlays, it decreases performance but could if the colors are OK it may signal a problem with you graphic card.
>
> best regards,
> Paulo
>
> 2009/7/21 Tommaso Gardumi <tommaso.gardumi at gmail.com>
>
> Sorry the strange values was an attempt to correct the default broken
> visualisation.
>
> I've set everithing back to default but what i get is always the same.
> I've noticed that when i try to switch to Auto exposure i get this
> error:
> VIDIOC_S_CTRL - Unable to set control: Errore di I/O
> Exposure, Auto Priority change to 1 failed
> VIDIOC_G_CTRL - Unable to get control: Errore di I/O
> hardware get failed
>
> And if i set to manual exposure and try to change the value nothing
> happens.
> ?Even switching between MJPG and YUYV and changing resolution and fps to
> any possible combination leave me with this quality (.jpg attached)
>
>
> Il giorno mar, 21/07/2009 alle 17.05 +0200, Laurent Pinchart ha scritto:
>
> > On Tuesday 21 July 2009 17:02:37 Paulo Assis wrote:
> > > Also make sure to set an appropriate ?value to exposure and white balance.
> > > hue also seems to be set at an invalid value!!!
> > >
> > > guvcview output:
> > > Hue, -4:1:4, default 0
> >
> > As this is consecutive to an Ubuntu upgrade, my guess is that libv4l2 might
> > not set proper default values.
> >
> > Regards,
> >
> > Laurent Pinchart
> >
>
>


From laurent.pinchart at skynet.be  Wed Jul 22 19:58:11 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Wed, 22 Jul 2009 19:58:11 +0200
Subject: [Linux-uvc-devel] [PATCH 0/2] uvcvideo: Multiple streaming
	interfaces support
Message-ID: <200907221958.12027.laurent.pinchart@skynet.be>

Hi everybody,

this patch series introduces support for multiple streaming interfaces in a 
single UVC device. This will mainly be used by devices that can stream 
compressed and preview video concurrently (think about MPEG2-TS and MJPEG), 
but could also accommodate USB-to-USB devices such as hardware codecs.

I've tested the patches here and haven't noticed any issue (otherwise I 
wouldn't be sending them :-)). However, testing with devices exposing multiple 
streaming interfaces was limited as I don't own any such device.

Before sending them to mainline, I would like to make sure the patches don't 
introduce any regression for the single streaming interface case. Please patch 
your V4L tree (you might need the uvcvideo tree until Mauro pulls the two last 
changesets I've submitted) and report bugs and other issues.

Mauro, I'd like this to go to 2.6.32. If nobody reports any blocking issue, 
can you apply the patches before submitting your 2.6.32 pull request to Linus 
? Depending on the timing I might apply them to my tree and ask you to pull if 
I get enough positive feedback before the merge window opens.

Regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Wed Jul 22 20:00:06 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Wed, 22 Jul 2009 20:00:06 +0200
Subject: [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming
	interfaces support
In-Reply-To: <200907221958.12027.laurent.pinchart@skynet.be>
References: <200907221958.12027.laurent.pinchart@skynet.be>
Message-ID: <200907222000.06959.laurent.pinchart@skynet.be>

Restructure the UVC descriptors parsing code to handle multiple streaming
interfaces. The driver now creates a uvc_video_chain instance for each chain
detected in the UVC control interface descriptors, and tries to register one
video device per streaming endpoint.

Priority: normal

Signed-off-by: Laurent Pinchart <laurent.pinchart at skynet.be>

diff -r ecc9128d8b6f linux/drivers/media/video/uvc/uvc_ctrl.c
--- a/linux/drivers/media/video/uvc/uvc_ctrl.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_ctrl.c	Wed Jul 22 19:40:03 2009 +0200
@@ -731,7 +731,7 @@
 	}
 }
 
-struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 	__u32 v4l2_id, struct uvc_control_mapping **mapping)
 {
 	struct uvc_control *ctrl = NULL;
@@ -744,17 +744,17 @@
 	v4l2_id &= V4L2_CTRL_ID_MASK;
 
 	/* Find the control. */
-	__uvc_find_control(video->processing, v4l2_id, mapping, &ctrl, next);
+	__uvc_find_control(chain->processing, v4l2_id, mapping, &ctrl, next);
 	if (ctrl && !next)
 		return ctrl;
 
-	list_for_each_entry(entity, &video->iterms, chain) {
+	list_for_each_entry(entity, &chain->iterms, chain) {
 		__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
 		if (ctrl && !next)
 			return ctrl;
 	}
 
-	list_for_each_entry(entity, &video->extensions, chain) {
+	list_for_each_entry(entity, &chain->extensions, chain) {
 		__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
 		if (ctrl && !next)
 			return ctrl;
@@ -767,7 +767,7 @@
 	return ctrl;
 }
 
-int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 	struct v4l2_queryctrl *v4l2_ctrl)
 {
 	struct uvc_control *ctrl;
@@ -777,7 +777,7 @@
 	__u8 *data;
 	int ret;
 
-	ctrl = uvc_find_control(video, v4l2_ctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, v4l2_ctrl->id, &mapping);
 	if (ctrl == NULL)
 		return -EINVAL;
 
@@ -795,9 +795,9 @@
 		v4l2_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
 	if (ctrl->info->flags & UVC_CONTROL_GET_DEF) {
-		ret = uvc_query_ctrl(video->dev, UVC_GET_DEF, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector, data,
-				ctrl->info->size);
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_DEF, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
 		if (ret < 0)
 			goto out;
 		v4l2_ctrl->default_value =
@@ -833,25 +833,25 @@
 	}
 
 	if (ctrl->info->flags & UVC_CONTROL_GET_MIN) {
-		ret = uvc_query_ctrl(video->dev, UVC_GET_MIN, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector, data,
-				ctrl->info->size);
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_MIN, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
 		if (ret < 0)
 			goto out;
 		v4l2_ctrl->minimum = mapping->get(mapping, UVC_GET_MIN, data);
 	}
 	if (ctrl->info->flags & UVC_CONTROL_GET_MAX) {
-		ret = uvc_query_ctrl(video->dev, UVC_GET_MAX, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector, data,
-				ctrl->info->size);
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_MAX, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
 		if (ret < 0)
 			goto out;
 		v4l2_ctrl->maximum = mapping->get(mapping, UVC_GET_MAX, data);
 	}
 	if (ctrl->info->flags & UVC_CONTROL_GET_RES) {
-		ret = uvc_query_ctrl(video->dev, UVC_GET_RES, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector, data,
-				ctrl->info->size);
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_RES, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     data, ctrl->info->size);
 		if (ret < 0)
 			goto out;
 		v4l2_ctrl->step = mapping->get(mapping, UVC_GET_RES, data);
@@ -888,9 +888,9 @@
  * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release the
  * control lock.
  */
-int uvc_ctrl_begin(struct uvc_video_device *video)
+int uvc_ctrl_begin(struct uvc_video_chain *chain)
 {
-	return mutex_lock_interruptible(&video->ctrl_mutex) ? -ERESTARTSYS : 0;
+	return mutex_lock_interruptible(&chain->ctrl_mutex) ? -ERESTARTSYS : 0;
 }
 
 static int uvc_ctrl_commit_entity(struct uvc_device *dev,
@@ -940,34 +940,34 @@
 	return 0;
 }
 
-int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
+int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
 {
 	struct uvc_entity *entity;
 	int ret = 0;
 
 	/* Find the control. */
-	ret = uvc_ctrl_commit_entity(video->dev, video->processing, rollback);
+	ret = uvc_ctrl_commit_entity(chain->dev, chain->processing, rollback);
 	if (ret < 0)
 		goto done;
 
-	list_for_each_entry(entity, &video->iterms, chain) {
-		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
+	list_for_each_entry(entity, &chain->iterms, chain) {
+		ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
 		if (ret < 0)
 			goto done;
 	}
 
-	list_for_each_entry(entity, &video->extensions, chain) {
-		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
+	list_for_each_entry(entity, &chain->extensions, chain) {
+		ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
 		if (ret < 0)
 			goto done;
 	}
 
 done:
-	mutex_unlock(&video->ctrl_mutex);
+	mutex_unlock(&chain->ctrl_mutex);
 	return ret;
 }
 
-int uvc_ctrl_get(struct uvc_video_device *video,
+int uvc_ctrl_get(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
@@ -976,13 +976,13 @@
 	unsigned int i;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
 	if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_GET_CUR) == 0)
 		return -EINVAL;
 
 	if (!ctrl->loaded) {
-		ret = uvc_query_ctrl(video->dev, UVC_GET_CUR, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR, ctrl->entity->id,
+				chain->dev->intfnum, ctrl->info->selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl->info->size);
 		if (ret < 0)
@@ -1007,7 +1007,7 @@
 	return 0;
 }
 
-int uvc_ctrl_set(struct uvc_video_device *video,
+int uvc_ctrl_set(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
@@ -1015,7 +1015,7 @@
 	s32 value = xctrl->value;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
 	if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_SET_CUR) == 0)
 		return -EINVAL;
 
@@ -1030,8 +1030,8 @@
 			memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				0, ctrl->info->size);
 		} else {
-			ret = uvc_query_ctrl(video->dev, UVC_GET_CUR,
-				ctrl->entity->id, video->dev->intfnum,
+			ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,
+				ctrl->entity->id, chain->dev->intfnum,
 				ctrl->info->selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl->info->size);
@@ -1060,7 +1060,7 @@
  * Dynamic controls
  */
 
-int uvc_xu_ctrl_query(struct uvc_video_device *video,
+int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 	struct uvc_xu_control *xctrl, int set)
 {
 	struct uvc_entity *entity;
@@ -1070,7 +1070,7 @@
 	int ret;
 
 	/* Find the extension unit. */
-	list_for_each_entry(entity, &video->extensions, chain) {
+	list_for_each_entry(entity, &chain->extensions, chain) {
 		if (entity->id == xctrl->unit)
 			break;
 	}
@@ -1109,7 +1109,7 @@
 	    (!set && !(ctrl->info->flags & UVC_CONTROL_GET_CUR)))
 		return -EINVAL;
 
-	if (mutex_lock_interruptible(&video->ctrl_mutex))
+	if (mutex_lock_interruptible(&chain->ctrl_mutex))
 		return -ERESTARTSYS;
 
 	memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
@@ -1122,8 +1122,8 @@
 		goto out;
 	}
 
-	ret = uvc_query_ctrl(video->dev, set ? UVC_SET_CUR : UVC_GET_CUR,
-			     xctrl->unit, video->dev->intfnum, xctrl->selector,
+	ret = uvc_query_ctrl(chain->dev, set ? UVC_SET_CUR : UVC_GET_CUR,
+			     xctrl->unit, chain->dev->intfnum, xctrl->selector,
 			     data, xctrl->size);
 	if (ret < 0)
 		goto out;
@@ -1139,7 +1139,7 @@
 		       uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
 		       xctrl->size);
 
-	mutex_unlock(&video->ctrl_mutex);
+	mutex_unlock(&chain->ctrl_mutex);
 	return ret;
 }
 
diff -r ecc9128d8b6f linux/drivers/media/video/uvc/uvc_driver.c
--- a/linux/drivers/media/video/uvc/uvc_driver.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_driver.c	Wed Jul 22 19:40:03 2009 +0200
@@ -276,8 +276,20 @@
 	return NULL;
 }
 
+static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev, int id)
+{
+	struct uvc_streaming *stream;
+
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->header.bTerminalLink == id)
+			return stream;
+	}
+
+	return NULL;
+}
+
 /* ------------------------------------------------------------------------
- * Descriptors handling
+ * Descriptors parsing
  */
 
 static int uvc_parse_format(struct uvc_device *dev,
@@ -1160,101 +1172,36 @@
 }
 
 /* ------------------------------------------------------------------------
- * USB probe and disconnect
+ * UVC device scan
  */
 
 /*
- * Unregister the video devices.
- */
-static void uvc_unregister_video(struct uvc_device *dev)
-{
-	struct uvc_streaming *streaming;
-
-	list_for_each_entry(streaming, &dev->streams, list) {
-		if (streaming->vdev == NULL)
-			continue;
-
-		if (streaming->vdev->minor == -1)
-			video_device_release(streaming->vdev);
-		else
-			video_unregister_device(streaming->vdev);
-		streaming->vdev = NULL;
-	}
-}
-
-static int uvc_register_video(struct uvc_device *dev,
-		struct uvc_streaming *stream)
-{
-	struct video_device *vdev;
-	struct uvc_entity *term;
-	int ret;
-
-	if (uvc_trace_param & UVC_TRACE_PROBE) {
-		uvc_printk(KERN_INFO, "Found a valid video chain (");
-		list_for_each_entry(term, &dev->video.iterms, chain) {
-			printk("%d", term->id);
-			if (term->chain.next != &dev->video.iterms)
-				printk(",");
-		}
-		printk(" -> %d).\n", dev->video.oterm->id);
-	}
-
-	/* Initialize the streaming interface with default streaming
-	 * parameters.
-	 */
-	ret = uvc_video_init(stream);
-	if (ret < 0) {
-		uvc_printk(KERN_ERR, "Failed to initialize the device "
-			"(%d).\n", ret);
-		return ret;
-	}
-
-	/* Register the device with V4L. */
-	vdev = video_device_alloc();
-	if (vdev == NULL)
-		return -1;
-
-	/* We already hold a reference to dev->udev. The video device will be
-	 * unregistered before the reference is released, so we don't need to
-	 * get another one.
-	 */
-	vdev->parent = &dev->intf->dev;
-	vdev->minor = -1;
-	vdev->fops = &uvc_fops;
-	vdev->release = video_device_release;
-	strlcpy(vdev->name, dev->name, sizeof vdev->name);
-
-	/* Set the driver data before calling video_register_device, otherwise
-	 * uvc_v4l2_open might race us.
-	 */
-	stream->vdev = vdev;
-	video_set_drvdata(vdev, stream);
-
-	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
-		stream->vdev = NULL;
-		video_device_release(vdev);
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
  * Scan the UVC descriptors to locate a chain starting at an Output Terminal
  * and containing the following units:
  *
- * - one Output Terminal (USB Streaming or Display)
+ * - one or more Output Terminals (USB Streaming or Display)
  * - zero or one Processing Unit
- * - zero, one or mode single-input Selector Units
+ * - zero, one or more single-input Selector Units
  * - zero or one multiple-input Selector Units, provided all inputs are
  *   connected to input terminals
  * - zero, one or mode single-input Extension Units
  * - one or more Input Terminals (Camera, External or USB Streaming)
  *
- * A side forward scan is made on each detected entity to check for additional
- * extension units.
+ * The terminal and units must match on of the following structures:
+ *
+ * ITT_*(0) -> +---------+    +---------+    +---------+ -> TT_STREAMING(0)
+ * ...         | SU{0,1} | -> | PU{0,1} | -> | XU{0,n} |    ...
+ * ITT_*(n) -> +---------+    +---------+    +---------+ -> TT_STREAMING(n)
+ *
+ *                 +---------+    +---------+ -> OTT_*(0)
+ * TT_STREAMING -> | PU{0,1} | -> | XU{0,n} |    ...
+ *                 +---------+    +---------+ -> OTT_*(n)
+ *
+ * The Processing Unit and Extension Units can be in any order. Additional
+ * Extension Units connected to the main chain as single-unit branches are
+ * also supported. Single-input Selector Units are ignored.
  */
-static int uvc_scan_chain_entity(struct uvc_video_device *video,
+static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
 {
 	switch (UVC_ENTITY_TYPE(entity)) {
@@ -1268,20 +1215,20 @@
 			return -1;
 		}
 
-		list_add_tail(&entity->chain, &video->extensions);
+		list_add_tail(&entity->chain, &chain->extensions);
 		break;
 
 	case UVC_VC_PROCESSING_UNIT:
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- PU %d", entity->id);
 
-		if (video->processing != NULL) {
+		if (chain->processing != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found multiple "
 				"Processing Units in chain.\n");
 			return -1;
 		}
 
-		video->processing = entity;
+		chain->processing = entity;
 		break;
 
 	case UVC_VC_SELECTOR_UNIT:
@@ -1292,13 +1239,13 @@
 		if (entity->selector.bNrInPins == 1)
 			break;
 
-		if (video->selector != NULL) {
+		if (chain->selector != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found multiple Selector "
 				"Units in chain.\n");
 			return -1;
 		}
 
-		video->selector = entity;
+		chain->selector = entity;
 		break;
 
 	case UVC_ITT_VENDOR_SPECIFIC:
@@ -1307,7 +1254,7 @@
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- IT %d\n", entity->id);
 
-		list_add_tail(&entity->chain, &video->iterms);
+		list_add_tail(&entity->chain, &chain->iterms);
 		break;
 
 	case UVC_TT_STREAMING:
@@ -1320,14 +1267,7 @@
 			return -1;
 		}
 
-		if (video->sterm != NULL) {
-			uvc_trace(UVC_TRACE_DESCR, "Found multiple streaming "
-				"entities in chain.\n");
-			return -1;
-		}
-
-		list_add_tail(&entity->chain, &video->iterms);
-		video->sterm = entity;
+		list_add_tail(&entity->chain, &chain->iterms);
 		break;
 
 	default:
@@ -1339,7 +1279,7 @@
 	return 0;
 }
 
-static int uvc_scan_chain_forward(struct uvc_video_device *video,
+static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
 	struct uvc_entity *entity, struct uvc_entity *prev)
 {
 	struct uvc_entity *forward;
@@ -1350,28 +1290,51 @@
 	found = 0;
 
 	while (1) {
-		forward = uvc_entity_by_reference(video->dev, entity->id,
+		forward = uvc_entity_by_reference(chain->dev, entity->id,
 			forward);
 		if (forward == NULL)
 			break;
-
-		if (UVC_ENTITY_TYPE(forward) != UVC_VC_EXTENSION_UNIT ||
-		    forward == prev)
+		if (forward == prev)
 			continue;
 
-		if (forward->extension.bNrInPins != 1) {
-			uvc_trace(UVC_TRACE_DESCR, "Extension unit %d has "
-				"more than 1 input pin.\n", entity->id);
-			return -1;
-		}
+		switch (UVC_ENTITY_TYPE(forward)) {
+		case UVC_VC_EXTENSION_UNIT:
+			if (forward->extension.bNrInPins != 1) {
+				uvc_trace(UVC_TRACE_DESCR, "Extension unit %d "
+					  "has more than 1 input pin.\n",
+					  entity->id);
+				return -EINVAL;
+			}
 
-		list_add_tail(&forward->chain, &video->extensions);
-		if (uvc_trace_param & UVC_TRACE_PROBE) {
-			if (!found)
-				printk(" (-> XU");
+			list_add_tail(&forward->chain, &chain->extensions);
+			if (uvc_trace_param & UVC_TRACE_PROBE) {
+				if (!found)
+					printk(" (->");
 
-			printk(" %d", forward->id);
-			found = 1;
+				printk(" XU %d", forward->id);
+				found = 1;
+			}
+			break;
+
+		case UVC_OTT_VENDOR_SPECIFIC:
+		case UVC_OTT_DISPLAY:
+		case UVC_OTT_MEDIA_TRANSPORT_OUTPUT:
+		case UVC_TT_STREAMING:
+			if (UVC_ENTITY_IS_ITERM(forward)) {
+				uvc_trace(UVC_TRACE_DESCR, "Unsupported input "
+					"terminal %u.\n", forward->id);
+				return -EINVAL;
+			}
+
+			list_add_tail(&forward->chain, &chain->oterms);
+			if (uvc_trace_param & UVC_TRACE_PROBE) {
+				if (!found)
+					printk(" (->");
+
+				printk(" OT %d", forward->id);
+				found = 1;
+			}
+			break;
 		}
 	}
 	if (found)
@@ -1380,7 +1343,7 @@
 	return 0;
 }
 
-static int uvc_scan_chain_backward(struct uvc_video_device *video,
+static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
 {
 	struct uvc_entity *term;
@@ -1405,10 +1368,10 @@
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- IT");
 
-		video->selector = entity;
+		chain->selector = entity;
 		for (i = 0; i < entity->selector.bNrInPins; ++i) {
 			id = entity->selector.baSourceID[i];
-			term = uvc_entity_by_id(video->dev, id);
+			term = uvc_entity_by_id(chain->dev, id);
 			if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
 				uvc_trace(UVC_TRACE_DESCR, "Selector unit %d "
 					"input %d isn't connected to an "
@@ -1419,8 +1382,8 @@
 			if (uvc_trace_param & UVC_TRACE_PROBE)
 				printk(" %d", term->id);
 
-			list_add_tail(&term->chain, &video->iterms);
-			uvc_scan_chain_forward(video, term, entity);
+			list_add_tail(&term->chain, &chain->iterms);
+			uvc_scan_chain_forward(chain, term, entity);
 		}
 
 		if (uvc_trace_param & UVC_TRACE_PROBE)
@@ -1433,108 +1396,264 @@
 	return id;
 }
 
-static int uvc_scan_chain(struct uvc_video_device *video)
+static int uvc_scan_chain(struct uvc_video_chain *chain,
+			  struct uvc_entity *oterm)
 {
 	struct uvc_entity *entity, *prev;
 	int id;
 
-	entity = video->oterm;
+	entity = oterm;
+	list_add_tail(&entity->chain, &chain->oterms);
 	uvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain: OT %d", entity->id);
 
-	if (UVC_ENTITY_TYPE(entity) == UVC_TT_STREAMING)
-		video->sterm = entity;
-
 	id = entity->output.bSourceID;
 	while (id != 0) {
 		prev = entity;
-		entity = uvc_entity_by_id(video->dev, id);
+		entity = uvc_entity_by_id(chain->dev, id);
 		if (entity == NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
 				"unknown entity %d.\n", id);
-			return -1;
+			return -EINVAL;
+		}
+
+		if (entity->chain.next || entity->chain.prev) {
+			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
+				"entity %d already in chain.\n", id);
+			return -EINVAL;
 		}
 
 		/* Process entity */
-		if (uvc_scan_chain_entity(video, entity) < 0)
-			return -1;
+		if (uvc_scan_chain_entity(chain, entity) < 0)
+			return -EINVAL;
 
 		/* Forward scan */
-		if (uvc_scan_chain_forward(video, entity, prev) < 0)
-			return -1;
+		if (uvc_scan_chain_forward(chain, entity, prev) < 0)
+			return -EINVAL;
 
 		/* Stop when a terminal is found. */
-		if (!UVC_ENTITY_IS_UNIT(entity))
+		if (UVC_ENTITY_IS_TERM(entity))
 			break;
 
 		/* Backward scan */
-		id = uvc_scan_chain_backward(video, entity);
+		id = uvc_scan_chain_backward(chain, entity);
 		if (id < 0)
 			return id;
 	}
 
-	if (video->sterm == NULL) {
-		uvc_trace(UVC_TRACE_DESCR, "No streaming entity found in "
-			"chain.\n");
+	return 0;
+}
+
+static unsigned int uvc_print_terms(struct list_head *terms, char *buffer)
+{
+	struct uvc_entity *term;
+	unsigned int nterms = 0;
+	char *p = buffer;
+
+	list_for_each_entry(term, terms, chain) {
+		p += sprintf(p, "%u", term->id);
+		if (term->chain.next != terms) {
+			p += sprintf(p, ",");
+			if (++nterms >= 4) {
+				p += sprintf(p, "...");
+				break;
+			}
+		}
+	}
+
+	return p - buffer;
+}
+
+static const char *uvc_print_chain(struct uvc_video_chain *chain)
+{
+	static char buffer[43];
+	char *p = buffer;
+
+	p += uvc_print_terms(&chain->iterms, p);
+	p += sprintf(p, " -> ");
+	uvc_print_terms(&chain->oterms, p);
+
+	return buffer;
+}
+
+/*
+ * Scan the device for video chains and register video devices.
+ *
+ * Chains are scanned starting at their output terminals and walked backwards.
+ */
+static int uvc_scan_device(struct uvc_device *dev)
+{
+	struct uvc_video_chain *chain;
+	struct uvc_entity *term;
+
+	list_for_each_entry(term, &dev->entities, list) {
+		if (!UVC_ENTITY_IS_OTERM(term))
+			continue;
+
+		/* If the terminal is already included in a chain, skip it.
+		 * This can happen for chains that have multiple output
+		 * terminals, where all output terminals beside the first one
+		 * will be inserted in the chain in forward scans.
+		 */
+		if (term->chain.next || term->chain.prev)
+			continue;
+
+		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
+		if (chain == NULL)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&chain->iterms);
+		INIT_LIST_HEAD(&chain->oterms);
+		INIT_LIST_HEAD(&chain->extensions);
+		mutex_init(&chain->ctrl_mutex);
+		chain->dev = dev;
+
+		if (uvc_scan_chain(chain, term) < 0) {
+			kfree(chain);
+			continue;
+		}
+
+		uvc_trace(UVC_TRACE_PROBE, "Found a valid video chain (%s).\n",
+			  uvc_print_chain(chain));
+
+		list_add_tail(&chain->list, &dev->chains);
+	}
+
+	if (list_empty(&dev->chains)) {
+		uvc_printk(KERN_INFO, "No valid video chain found.\n");
 		return -1;
 	}
 
 	return 0;
 }
 
+/* ------------------------------------------------------------------------
+ * Video device registration and unregistration
+ */
+
 /*
- * Scan the device for video chains and register video devices.
- *
- * The driver currently supports a single video device per control interface
- * only. The terminal and units must match the following structure:
- *
- * ITT_* -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> TT_STREAMING
- * TT_STREAMING -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> OTT_*
- *
- * The Extension Units, if present, must have a single input pin. The
- * Processing Unit and Extension Units can be in any order. Additional
- * Extension Units connected to the main chain as single-unit branches are
- * also supported.
+ * Unregister the video devices.
  */
-static int uvc_scan_device(struct uvc_device *dev)
+static void uvc_unregister_video(struct uvc_device *dev)
 {
-	struct uvc_entity *term;
-	int found = 0;
+	struct uvc_streaming *stream;
 
-	/* Check if the control interface matches the structure we expect. */
-	list_for_each_entry(term, &dev->entities, list) {
-		struct uvc_streaming *stream;
-
-		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->vdev == NULL)
 			continue;
 
-		memset(&dev->video, 0, sizeof dev->video);
-		mutex_init(&dev->video.ctrl_mutex);
-		INIT_LIST_HEAD(&dev->video.iterms);
-		INIT_LIST_HEAD(&dev->video.extensions);
-		dev->video.oterm = term;
-		dev->video.dev = dev;
-		if (uvc_scan_chain(&dev->video) < 0)
-			continue;
+		if (stream->vdev->minor == -1)
+			video_device_release(stream->vdev);
+		else
+			video_unregister_device(stream->vdev);
+		stream->vdev = NULL;
+	}
+}
 
-		list_for_each_entry(stream, &dev->streams, list) {
-			if (stream->header.bTerminalLink ==
-			    dev->video.sterm->id) {
-				uvc_register_video(dev, stream);
-				found = 1;
-				break;
-			}
-		}
+static int uvc_register_video(struct uvc_device *dev,
+		struct uvc_streaming *stream)
+{
+	struct video_device *vdev;
+	int ret;
+
+	/* Initialize the streaming interface with default streaming
+	 * parameters.
+	 */
+	ret = uvc_video_init(stream);
+	if (ret < 0) {
+		uvc_printk(KERN_ERR, "Failed to initialize the device "
+			"(%d).\n", ret);
+		return ret;
 	}
 
-	if (!found) {
-		uvc_printk(KERN_INFO, "No valid video chain found.\n");
-		return -1;
+	/* Register the device with V4L. */
+	vdev = video_device_alloc();
+	if (vdev == NULL) {
+		uvc_printk(KERN_ERR, "Failed to allocate video device (%d).\n",
+			   ret);
+		return -ENOMEM;
+	}
+
+	/* We already hold a reference to dev->udev. The video device will be
+	 * unregistered before the reference is released, so we don't need to
+	 * get another one.
+	 */
+	vdev->parent = &dev->intf->dev;
+	vdev->minor = -1;
+	vdev->fops = &uvc_fops;
+	vdev->release = video_device_release;
+	strlcpy(vdev->name, dev->name, sizeof vdev->name);
+
+	/* Set the driver data before calling video_register_device, otherwise
+	 * uvc_v4l2_open might race us.
+	 */
+	stream->vdev = vdev;
+	video_set_drvdata(vdev, stream);
+
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret < 0) {
+		uvc_printk(KERN_ERR, "Failed to register video device (%d).\n",
+			   ret);
+		stream->vdev = NULL;
+		video_device_release(vdev);
+		return ret;
 	}
 
 	return 0;
 }
 
 /*
+ * Register all video devices in all chains.
+ */
+static int uvc_register_terms(struct uvc_device *dev,
+	struct uvc_video_chain *chain, struct list_head *terms)
+{
+	struct uvc_streaming *stream;
+	struct uvc_entity *term;
+	int ret;
+
+	list_for_each_entry(term, terms, chain) {
+		if (UVC_ENTITY_TYPE(term) != UVC_TT_STREAMING)
+			continue;
+
+		stream = uvc_stream_by_id(dev, term->id);
+		if (stream == NULL) {
+			uvc_printk(KERN_INFO, "No streaming interface found "
+				   "for terminal %u.", term->id);
+			continue;
+		}
+
+		stream->chain = chain;
+		ret = uvc_register_video(dev, stream);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int uvc_register_chains(struct uvc_device *dev)
+{
+	struct uvc_video_chain *chain;
+	int ret;
+
+	list_for_each_entry(chain, &dev->chains, list) {
+		ret = uvc_register_terms(dev, chain, &chain->iterms);
+		if (ret < 0)
+			return ret;
+
+		ret = uvc_register_terms(dev, chain, &chain->oterms);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------
+ * USB probe, disconnect, suspend and resume
+ */
+
+/*
  * Delete the UVC device.
  *
  * Called by the kernel when the last reference to the uvc_device structure
@@ -1555,7 +1674,7 @@
 	struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
 	struct list_head *p, *n;
 
-	/* Unregister the video device. */
+	/* Unregister the video devices. */
 	uvc_unregister_video(dev);
 	usb_put_intf(dev->intf);
 	usb_put_dev(dev->udev);
@@ -1563,6 +1682,12 @@
 	uvc_status_cleanup(dev);
 	uvc_ctrl_cleanup_device(dev);
 
+	list_for_each_safe(p, n, &dev->chains) {
+		struct uvc_video_chain *chain;
+		chain = list_entry(p, struct uvc_video_chain, list);
+		kfree(chain);
+	}
+
 	list_for_each_safe(p, n, &dev->entities) {
 		struct uvc_entity *entity;
 		entity = list_entry(p, struct uvc_entity, list);
@@ -1603,6 +1728,7 @@
 		return -ENOMEM;
 
 	INIT_LIST_HEAD(&dev->entities);
+	INIT_LIST_HEAD(&dev->chains);
 	INIT_LIST_HEAD(&dev->streams);
 	kref_init(&dev->kref);
 	atomic_set(&dev->users, 0);
@@ -1644,10 +1770,14 @@
 	if (uvc_ctrl_init_device(dev) < 0)
 		goto error;
 
-	/* Scan the device for video chains and register video devices. */
+	/* Scan the device for video chains. */
 	if (uvc_scan_device(dev) < 0)
 		goto error;
 
+	/* Register video devices. */
+	if (uvc_register_chains(dev) < 0)
+		goto error;
+
 	/* Save our data pointer in the interface data. */
 	usb_set_intfdata(intf, dev);
 
diff -r ecc9128d8b6f linux/drivers/media/video/uvc/uvc_v4l2.c
--- a/linux/drivers/media/video/uvc/uvc_v4l2.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_v4l2.c	Wed Jul 22 19:40:03 2009 +0200
@@ -40,7 +40,7 @@
  * table for the controls that can be mapped directly, and handle the others
  * manually.
  */
-static int uvc_v4l2_query_menu(struct uvc_video_device *video,
+static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
 	struct v4l2_querymenu *query_menu)
 {
 	struct uvc_menu_info *menu_info;
@@ -49,7 +49,7 @@
 	u32 index = query_menu->index;
 	u32 id = query_menu->id;
 
-	ctrl = uvc_find_control(video, query_menu->id, &mapping);
+	ctrl = uvc_find_control(chain, query_menu->id, &mapping);
 	if (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU)
 		return -EINVAL;
 
@@ -457,7 +457,7 @@
 		}
 	}
 
-	handle->video = &stream->dev->video;
+	handle->chain = stream->chain;
 	handle->stream = stream;
 	handle->state = UVC_HANDLE_PASSIVE;
 	file->private_data = handle;
@@ -506,7 +506,7 @@
 {
 	struct video_device *vdev = video_devdata(file);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
-	struct uvc_video_device *video = handle->video;
+	struct uvc_video_chain *chain = handle->chain;
 	struct uvc_streaming *stream = handle->stream;
 	long ret = 0;
 
@@ -533,7 +533,7 @@
 
 	/* Get, Set & Query control */
 	case VIDIOC_QUERYCTRL:
-		return uvc_query_v4l2_ctrl(video, arg);
+		return uvc_query_v4l2_ctrl(chain, arg);
 
 	case VIDIOC_G_CTRL:
 	{
@@ -543,12 +543,12 @@
 		memset(&xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl->id;
 
-	       ret = uvc_ctrl_begin(video);
-	       if (ret < 0)
+		ret = uvc_ctrl_begin(chain);
+		if (ret < 0)
 			return ret;
 
-		ret = uvc_ctrl_get(video, &xctrl);
-		uvc_ctrl_rollback(video);
+		ret = uvc_ctrl_get(chain, &xctrl);
+		uvc_ctrl_rollback(chain);
 		if (ret >= 0)
 			ctrl->value = xctrl.value;
 		break;
@@ -563,21 +563,21 @@
 		xctrl.id = ctrl->id;
 		xctrl.value = ctrl->value;
 
-	       ret = uvc_ctrl_begin(video);
-	       if (ret < 0)
+		uvc_ctrl_begin(chain);
+		if (ret < 0)
 			return ret;
 
-		ret = uvc_ctrl_set(video, &xctrl);
+		ret = uvc_ctrl_set(chain, &xctrl);
 		if (ret < 0) {
-			uvc_ctrl_rollback(video);
+			uvc_ctrl_rollback(chain);
 			return ret;
 		}
-		ret = uvc_ctrl_commit(video);
+		ret = uvc_ctrl_commit(chain);
 		break;
 	}
 
 	case VIDIOC_QUERYMENU:
-		return uvc_v4l2_query_menu(video, arg);
+		return uvc_v4l2_query_menu(chain, arg);
 
 	case VIDIOC_G_EXT_CTRLS:
 	{
@@ -585,20 +585,20 @@
 		struct v4l2_ext_control *ctrl = ctrls->controls;
 		unsigned int i;
 
-	       ret = uvc_ctrl_begin(video);
-	       if (ret < 0)
+		ret = uvc_ctrl_begin(chain);
+		if (ret < 0)
 			return ret;
 
 		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
-			ret = uvc_ctrl_get(video, ctrl);
+			ret = uvc_ctrl_get(chain, ctrl);
 			if (ret < 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls->error_idx = i;
 				return ret;
 			}
 		}
 		ctrls->error_idx = 0;
-		ret = uvc_ctrl_rollback(video);
+		ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
@@ -609,14 +609,14 @@
 		struct v4l2_ext_control *ctrl = ctrls->controls;
 		unsigned int i;
 
-		ret = uvc_ctrl_begin(video);
+		ret = uvc_ctrl_begin(chain);
 		if (ret < 0)
 			return ret;
 
 		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
-			ret = uvc_ctrl_set(video, ctrl);
+			ret = uvc_ctrl_set(chain, ctrl);
 			if (ret < 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls->error_idx = i;
 				return ret;
 			}
@@ -625,31 +625,31 @@
 		ctrls->error_idx = 0;
 
 		if (cmd == VIDIOC_S_EXT_CTRLS)
-			ret = uvc_ctrl_commit(video);
+			ret = uvc_ctrl_commit(chain);
 		else
-			ret = uvc_ctrl_rollback(video);
+			ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
 	/* Get, Set & Enum input */
 	case VIDIOC_ENUMINPUT:
 	{
-		const struct uvc_entity *selector = video->selector;
+		const struct uvc_entity *selector = chain->selector;
 		struct v4l2_input *input = arg;
 		struct uvc_entity *iterm = NULL;
 		u32 index = input->index;
 		int pin = 0;
 
 		if (selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (index != 0)
 				return -EINVAL;
-			iterm = list_first_entry(&video->iterms,
+			iterm = list_first_entry(&chain->iterms,
 					struct uvc_entity, chain);
 			pin = iterm->id;
 		} else if (pin < selector->selector.bNrInPins) {
 			pin = selector->selector.baSourceID[index];
-			list_for_each_entry(iterm, video->iterms.next, chain) {
+			list_for_each_entry(iterm, chain->iterms.next, chain) {
 				if (iterm->id == pin)
 					break;
 			}
@@ -670,14 +670,14 @@
 	{
 		u8 input;
 
-		if (video->selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain->selector == NULL ||
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			*(int *)arg = 0;
 			break;
 		}
 
-		ret = uvc_query_ctrl(video->dev, UVC_GET_CUR,
-			video->selector->id, video->dev->intfnum,
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,
+			chain->selector->id, chain->dev->intfnum,
 			UVC_SU_INPUT_SELECT_CONTROL, &input, 1);
 		if (ret < 0)
 			return ret;
@@ -693,18 +693,18 @@
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		if (video->selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain->selector == NULL ||
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (input != 1)
 				return -EINVAL;
 			break;
 		}
 
-		if (input == 0 || input > video->selector->selector.bNrInPins)
+		if (input == 0 || input > chain->selector->selector.bNrInPins)
 			return -EINVAL;
 
-		return uvc_query_ctrl(video->dev, UVC_SET_CUR,
-			video->selector->id, video->dev->intfnum,
+		return uvc_query_ctrl(chain->dev, UVC_SET_CUR,
+			chain->selector->id, chain->dev->intfnum,
 			UVC_SU_INPUT_SELECT_CONTROL, &input, 1);
 	}
 
@@ -1027,10 +1027,10 @@
 	}
 
 	case UVCIOC_CTRL_GET:
-		return uvc_xu_ctrl_query(video, arg, 0);
+		return uvc_xu_ctrl_query(chain, arg, 0);
 
 	case UVCIOC_CTRL_SET:
-		return uvc_xu_ctrl_query(video, arg, 1);
+		return uvc_xu_ctrl_query(chain, arg, 1);
 
 	default:
 		if ((ret = v4l_compat_translate_ioctl(file, cmd, arg,
diff -r ecc9128d8b6f linux/drivers/media/video/uvc/uvc_video.c
--- a/linux/drivers/media/video/uvc/uvc_video.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_video.c	Wed Jul 22 19:40:03 2009 +0200
@@ -128,7 +128,7 @@
 	if (data == NULL)
 		return -ENOMEM;
 
-	if ((video->dev->quirks & UVC_QUIRK_PROBE_DEF) && query == UVC_GET_DEF)
+	if ((stream->dev->quirks & UVC_QUIRK_PROBE_DEF) && query == UVC_GET_DEF)
 		return -EIO;
 
 	ret = __uvc_query_ctrl(stream->dev, query, 0, stream->intfnum,
diff -r ecc9128d8b6f linux/drivers/media/video/uvc/uvcvideo.h
--- a/linux/drivers/media/video/uvc/uvcvideo.h	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvcvideo.h	Wed Jul 22 19:40:03 2009 +0200
@@ -81,9 +81,11 @@
 #define UVC_ENTITY_IS_UNIT(entity)	(((entity)->type & 0xff00) == 0)
 #define UVC_ENTITY_IS_TERM(entity)	(((entity)->type & 0xff00) != 0)
 #define UVC_ENTITY_IS_ITERM(entity) \
-	(((entity)->type & 0x8000) == UVC_TERM_INPUT)
+	(UVC_ENTITY_IS_TERM(entity) && \
+	((entity)->type & 0x8000) == UVC_TERM_INPUT)
 #define UVC_ENTITY_IS_OTERM(entity) \
-	(((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
+	(UVC_ENTITY_IS_TERM(entity) && \
+	((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
 
 
 /* ------------------------------------------------------------------------
@@ -403,10 +405,24 @@
 	struct list_head irqqueue;
 };
 
+struct uvc_video_chain {
+	struct uvc_device *dev;
+	struct list_head list;
+
+	struct list_head iterms;		/* Input terminals */
+	struct list_head oterms;		/* Output terminals */
+	struct uvc_entity *processing;		/* Processing unit */
+	struct uvc_entity *selector;		/* Selector unit */
+	struct list_head extensions;		/* Extension units */
+
+	struct mutex ctrl_mutex;
+};
+
 struct uvc_streaming {
 	struct list_head list;
 	struct uvc_device *dev;
 	struct video_device *vdev;
+	struct uvc_video_chain *chain;
 	atomic_t active;
 
 	struct usb_interface *intf;
@@ -447,18 +463,6 @@
 	__u8 last_fid;
 };
 
-struct uvc_video_device {
-	struct uvc_device *dev;
-
-	struct list_head iterms;		/* Input terminals */
-	struct uvc_entity *oterm;		/* Output terminal */
-	struct uvc_entity *sterm;		/* USB streaming terminal */
-	struct uvc_entity *processing;
-	struct uvc_entity *selector;
-	struct list_head extensions;
-	struct mutex ctrl_mutex;
-};
-
 enum uvc_device_state {
 	UVC_DEV_DISCONNECTED = 1,
 };
@@ -481,8 +485,7 @@
 	__u32 clock_frequency;
 
 	struct list_head entities;
-
-	struct uvc_video_device video;
+	struct list_head chains;
 
 	/* Video Streaming interfaces */
 	struct list_head streams;
@@ -501,7 +504,7 @@
 };
 
 struct uvc_fh {
-	struct uvc_video_device *video;
+	struct uvc_video_chain *chain;
 	struct uvc_streaming *stream;
 	enum uvc_handle_state state;
 };
@@ -619,9 +622,9 @@
 extern int uvc_status_resume(struct uvc_device *dev);
 
 /* Controls */
-extern struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+extern struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 		__u32 v4l2_id, struct uvc_control_mapping **mapping);
-extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 		struct v4l2_queryctrl *v4l2_ctrl);
 
 extern int uvc_ctrl_add_info(struct uvc_control_info *info);
@@ -631,23 +634,23 @@
 extern int uvc_ctrl_resume_device(struct uvc_device *dev);
 extern void uvc_ctrl_init(void);
 
-extern int uvc_ctrl_begin(struct uvc_video_device *video);
-extern int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback);
-static inline int uvc_ctrl_commit(struct uvc_video_device *video)
+extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
+extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback);
+static inline int uvc_ctrl_commit(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 0);
+	return __uvc_ctrl_commit(chain, 0);
 }
-static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
+static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 1);
+	return __uvc_ctrl_commit(chain, 1);
 }
 
-extern int uvc_ctrl_get(struct uvc_video_device *video,
+extern int uvc_ctrl_get(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
-extern int uvc_ctrl_set(struct uvc_video_device *video,
+extern int uvc_ctrl_set(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
 
-extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
+extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 		struct uvc_xu_control *ctrl, int set);
 
 /* Utility functions */



From laurent.pinchart at skynet.be  Wed Jul 22 19:59:14 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Wed, 22 Jul 2009 19:59:14 +0200
Subject: [Linux-uvc-devel] [PATCH 1/2] uvcvideo: Restructure the driver to
	support multiple simultaneous streams.
In-Reply-To: <200907221958.12027.laurent.pinchart@skynet.be>
References: <200907221958.12027.laurent.pinchart@skynet.be>
Message-ID: <200907221959.14669.laurent.pinchart@skynet.be>

As a first step towards multiple streaming interfaces support, reorganize the
driver's data structures to cleanly separate video control and video streaming
data.

Priority: normal

Signed-off-by: Laurent Pinchart <laurent.pinchart at skynet.be>

diff -r da81aafb9c5d linux/drivers/media/video/uvc/uvc_driver.c
--- a/linux/drivers/media/video/uvc/uvc_driver.c	Mon Jul 20 00:16:05 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_driver.c	Tue Jul 21 23:54:32 2009 +0200
@@ -551,6 +551,7 @@
 	}
 
 	mutex_init(&streaming->mutex);
+	streaming->dev = dev;
 	streaming->intf = usb_get_intf(intf);
 	streaming->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;
 
@@ -751,7 +752,7 @@
 			streaming->maxpsize = psize;
 	}
 
-	list_add_tail(&streaming->list, &dev->streaming);
+	list_add_tail(&streaming->list, &dev->streams);
 	return 0;
 
 error:
@@ -1167,15 +1168,77 @@
  */
 static void uvc_unregister_video(struct uvc_device *dev)
 {
-	if (dev->video.vdev) {
-		if (dev->video.vdev->minor == -1)
-			video_device_release(dev->video.vdev);
+	struct uvc_streaming *streaming;
+
+	list_for_each_entry(streaming, &dev->streams, list) {
+		if (streaming->vdev == NULL)
+			continue;
+
+		if (streaming->vdev->minor == -1)
+			video_device_release(streaming->vdev);
 		else
-			video_unregister_device(dev->video.vdev);
-		dev->video.vdev = NULL;
+			video_unregister_device(streaming->vdev);
+		streaming->vdev = NULL;
 	}
 }
 
+static int uvc_register_video(struct uvc_device *dev,
+		struct uvc_streaming *stream)
+{
+	struct video_device *vdev;
+	struct uvc_entity *term;
+	int ret;
+
+	if (uvc_trace_param & UVC_TRACE_PROBE) {
+		uvc_printk(KERN_INFO, "Found a valid video chain (");
+		list_for_each_entry(term, &dev->video.iterms, chain) {
+			printk("%d", term->id);
+			if (term->chain.next != &dev->video.iterms)
+				printk(",");
+		}
+		printk(" -> %d).\n", dev->video.oterm->id);
+	}
+
+	/* Initialize the streaming interface with default streaming
+	 * parameters.
+	 */
+	ret = uvc_video_init(stream);
+	if (ret < 0) {
+		uvc_printk(KERN_ERR, "Failed to initialize the device "
+			"(%d).\n", ret);
+		return ret;
+	}
+
+	/* Register the device with V4L. */
+	vdev = video_device_alloc();
+	if (vdev == NULL)
+		return -1;
+
+	/* We already hold a reference to dev->udev. The video device will be
+	 * unregistered before the reference is released, so we don't need to
+	 * get another one.
+	 */
+	vdev->parent = &dev->intf->dev;
+	vdev->minor = -1;
+	vdev->fops = &uvc_fops;
+	vdev->release = video_device_release;
+	strlcpy(vdev->name, dev->name, sizeof vdev->name);
+
+	/* Set the driver data before calling video_register_device, otherwise
+	 * uvc_v4l2_open might race us.
+	 */
+	stream->vdev = vdev;
+	video_set_drvdata(vdev, stream);
+
+	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
+		stream->vdev = NULL;
+		video_device_release(vdev);
+		return -1;
+	}
+
+	return 0;
+}
+
 /*
  * Scan the UVC descriptors to locate a chain starting at an Output Terminal
  * and containing the following units:
@@ -1419,7 +1482,7 @@
 }
 
 /*
- * Register the video devices.
+ * Scan the device for video chains and register video devices.
  *
  * The driver currently supports a single video device per control interface
  * only. The terminal and units must match the following structure:
@@ -1432,15 +1495,14 @@
  * Extension Units connected to the main chain as single-unit branches are
  * also supported.
  */
-static int uvc_register_video(struct uvc_device *dev)
+static int uvc_scan_device(struct uvc_device *dev)
 {
-	struct video_device *vdev;
 	struct uvc_entity *term;
-	int found = 0, ret;
+	int found = 0;
 
 	/* Check if the control interface matches the structure we expect. */
 	list_for_each_entry(term, &dev->entities, list) {
-		struct uvc_streaming *streaming;
+		struct uvc_streaming *stream;
 
 		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
 			continue;
@@ -1454,17 +1516,14 @@
 		if (uvc_scan_chain(&dev->video) < 0)
 			continue;
 
-		list_for_each_entry(streaming, &dev->streaming, list) {
-			if (streaming->header.bTerminalLink ==
+		list_for_each_entry(stream, &dev->streams, list) {
+			if (stream->header.bTerminalLink ==
 			    dev->video.sterm->id) {
-				dev->video.streaming = streaming;
+				uvc_register_video(dev, stream);
 				found = 1;
 				break;
 			}
 		}
-
-		if (found)
-			break;
 	}
 
 	if (!found) {
@@ -1472,55 +1531,6 @@
 		return -1;
 	}
 
-	if (uvc_trace_param & UVC_TRACE_PROBE) {
-		uvc_printk(KERN_INFO, "Found a valid video chain (");
-		list_for_each_entry(term, &dev->video.iterms, chain) {
-			printk("%d", term->id);
-			if (term->chain.next != &dev->video.iterms)
-				printk(",");
-		}
-		printk(" -> %d).\n", dev->video.oterm->id);
-	}
-
-	/* Initialize the video buffers queue. */
-	uvc_queue_init(&dev->video.queue, dev->video.streaming->type);
-
-	/* Initialize the streaming interface with default streaming
-	 * parameters.
-	 */
-	if ((ret = uvc_video_init(&dev->video)) < 0) {
-		uvc_printk(KERN_ERR, "Failed to initialize the device "
-			"(%d).\n", ret);
-		return ret;
-	}
-
-	/* Register the device with V4L. */
-	vdev = video_device_alloc();
-	if (vdev == NULL)
-		return -1;
-
-	/* We already hold a reference to dev->udev. The video device will be
-	 * unregistered before the reference is released, so we don't need to
-	 * get another one.
-	 */
-	vdev->parent = &dev->intf->dev;
-	vdev->minor = -1;
-	vdev->fops = &uvc_fops;
-	vdev->release = video_device_release;
-	strlcpy(vdev->name, dev->name, sizeof vdev->name);
-
-	/* Set the driver data before calling video_register_device, otherwise
-	 * uvc_v4l2_open might race us.
-	 */
-	dev->video.vdev = vdev;
-	video_set_drvdata(vdev, &dev->video);
-
-	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
-		dev->video.vdev = NULL;
-		video_device_release(vdev);
-		return -1;
-	}
-
 	return 0;
 }
 
@@ -1559,7 +1569,7 @@
 		kfree(entity);
 	}
 
-	list_for_each_safe(p, n, &dev->streaming) {
+	list_for_each_safe(p, n, &dev->streams) {
 		struct uvc_streaming *streaming;
 		streaming = list_entry(p, struct uvc_streaming, list);
 		usb_driver_release_interface(&uvc_driver.driver,
@@ -1593,7 +1603,7 @@
 		return -ENOMEM;
 
 	INIT_LIST_HEAD(&dev->entities);
-	INIT_LIST_HEAD(&dev->streaming);
+	INIT_LIST_HEAD(&dev->streams);
 	kref_init(&dev->kref);
 	atomic_set(&dev->users, 0);
 
@@ -1634,8 +1644,8 @@
 	if (uvc_ctrl_init_device(dev) < 0)
 		goto error;
 
-	/* Register the video devices. */
-	if (uvc_register_video(dev) < 0)
+	/* Scan the device for video chains and register video devices. */
+	if (uvc_scan_device(dev) < 0)
 		goto error;
 
 	/* Save our data pointer in the interface data. */
@@ -1689,6 +1699,7 @@
 static int uvc_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct uvc_device *dev = usb_get_intfdata(intf);
+	struct uvc_streaming *stream;
 
 	uvc_trace(UVC_TRACE_SUSPEND, "Suspending interface %u\n",
 		intf->cur_altsetting->desc.bInterfaceNumber);
@@ -1698,18 +1709,20 @@
 	    UVC_SC_VIDEOCONTROL)
 		return uvc_status_suspend(dev);
 
-	if (dev->video.streaming->intf != intf) {
-		uvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB "
-				"interface mismatch.\n");
-		return -EINVAL;
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->intf == intf)
+			return uvc_video_suspend(stream);
 	}
 
-	return uvc_video_suspend(&dev->video);
+	uvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB interface "
+			"mismatch.\n");
+	return -EINVAL;
 }
 
 static int __uvc_resume(struct usb_interface *intf, int reset)
 {
 	struct uvc_device *dev = usb_get_intfdata(intf);
+	struct uvc_streaming *stream;
 
 	uvc_trace(UVC_TRACE_SUSPEND, "Resuming interface %u\n",
 		intf->cur_altsetting->desc.bInterfaceNumber);
@@ -1726,13 +1739,14 @@
 		return uvc_status_resume(dev);
 	}
 
-	if (dev->video.streaming->intf != intf) {
-		uvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB "
-				"interface mismatch.\n");
-		return -EINVAL;
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->intf == intf)
+			return uvc_video_resume(stream);
 	}
 
-	return uvc_video_resume(&dev->video);
+	uvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB interface "
+			"mismatch.\n");
+	return -EINVAL;
 }
 
 static int uvc_resume(struct usb_interface *intf)
diff -r da81aafb9c5d linux/drivers/media/video/uvc/uvc_isight.c
--- a/linux/drivers/media/video/uvc/uvc_isight.c	Mon Jul 20 00:16:05 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_isight.c	Tue Jul 21 23:54:32 2009 +0200
@@ -99,7 +99,7 @@
 	return 0;
 }
 
-void uvc_video_decode_isight(struct urb *urb, struct uvc_video_device *video,
+void uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,
 		struct uvc_buffer *buf)
 {
 	int ret, i;
@@ -120,7 +120,7 @@
 		 * processes the data of the first payload of the new frame.
 		 */
 		do {
-			ret = isight_decode(&video->queue, buf,
+			ret = isight_decode(&stream->queue, buf,
 					urb->transfer_buffer +
 					urb->iso_frame_desc[i].offset,
 					urb->iso_frame_desc[i].actual_length);
@@ -130,7 +130,8 @@
 
 			if (buf->state == UVC_BUF_STATE_DONE ||
 			    buf->state == UVC_BUF_STATE_ERROR)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							buf);
 		} while (ret == -EAGAIN);
 	}
 }
diff -r da81aafb9c5d linux/drivers/media/video/uvc/uvc_v4l2.c
--- a/linux/drivers/media/video/uvc/uvc_v4l2.c	Mon Jul 20 00:16:05 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_v4l2.c	Tue Jul 21 23:54:32 2009 +0200
@@ -103,7 +103,7 @@
 	return interval;
 }
 
-static int uvc_v4l2_try_format(struct uvc_video_device *video,
+static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt, struct uvc_streaming_control *probe,
 	struct uvc_format **uvc_format, struct uvc_frame **uvc_frame)
 {
@@ -116,7 +116,7 @@
 	int ret = 0;
 	__u8 *fcc;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
 	fcc = (__u8 *)&fmt->fmt.pix.pixelformat;
@@ -126,8 +126,8 @@
 			fmt->fmt.pix.width, fmt->fmt.pix.height);
 
 	/* Check if the hardware supports the requested format. */
-	for (i = 0; i < video->streaming->nformats; ++i) {
-		format = &video->streaming->format[i];
+	for (i = 0; i < stream->nformats; ++i) {
+		format = &stream->format[i];
 		if (format->fcc == fmt->fmt.pix.pixelformat)
 			break;
 	}
@@ -191,12 +191,13 @@
 	 * developers test their webcams with the Linux driver as well as with
 	 * the Windows driver).
 	 */
-	if (video->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)
+	if (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)
 		probe->dwMaxVideoFrameSize =
-			video->streaming->ctrl.dwMaxVideoFrameSize;
+			stream->ctrl.dwMaxVideoFrameSize;
 
 	/* Probe the device. */
-	if ((ret = uvc_probe_video(video, probe)) < 0)
+	ret = uvc_probe_video(stream, probe);
+	if (ret < 0)
 		goto done;
 
 	fmt->fmt.pix.width = frame->wWidth;
@@ -216,13 +217,13 @@
 	return ret;
 }
 
-static int uvc_v4l2_get_format(struct uvc_video_device *video,
+static int uvc_v4l2_get_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt)
 {
-	struct uvc_format *format = video->streaming->cur_format;
-	struct uvc_frame *frame = video->streaming->cur_frame;
+	struct uvc_format *format = stream->cur_format;
+	struct uvc_frame *frame = stream->cur_frame;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
 	if (format == NULL || frame == NULL)
@@ -233,14 +234,14 @@
 	fmt->fmt.pix.height = frame->wHeight;
 	fmt->fmt.pix.field = V4L2_FIELD_NONE;
 	fmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;
-	fmt->fmt.pix.sizeimage = video->streaming->ctrl.dwMaxVideoFrameSize;
+	fmt->fmt.pix.sizeimage = stream->ctrl.dwMaxVideoFrameSize;
 	fmt->fmt.pix.colorspace = format->colorspace;
 	fmt->fmt.pix.priv = 0;
 
 	return 0;
 }
 
-static int uvc_v4l2_set_format(struct uvc_video_device *video,
+static int uvc_v4l2_set_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt)
 {
 	struct uvc_streaming_control probe;
@@ -248,39 +249,39 @@
 	struct uvc_frame *frame;
 	int ret;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
-	if (uvc_queue_allocated(&video->queue))
+	if (uvc_queue_allocated(&stream->queue))
 		return -EBUSY;
 
-	ret = uvc_v4l2_try_format(video, fmt, &probe, &format, &frame);
+	ret = uvc_v4l2_try_format(stream, fmt, &probe, &format, &frame);
 	if (ret < 0)
 		return ret;
 
-	memcpy(&video->streaming->ctrl, &probe, sizeof probe);
-	video->streaming->cur_format = format;
-	video->streaming->cur_frame = frame;
+	memcpy(&stream->ctrl, &probe, sizeof probe);
+	stream->cur_format = format;
+	stream->cur_frame = frame;
 
 	return 0;
 }
 
-static int uvc_v4l2_get_streamparm(struct uvc_video_device *video,
+static int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,
 		struct v4l2_streamparm *parm)
 {
 	uint32_t numerator, denominator;
 
-	if (parm->type != video->streaming->type)
+	if (parm->type != stream->type)
 		return -EINVAL;
 
-	numerator = video->streaming->ctrl.dwFrameInterval;
+	numerator = stream->ctrl.dwFrameInterval;
 	denominator = 10000000;
 	uvc_simplify_fraction(&numerator, &denominator, 8, 333);
 
 	memset(parm, 0, sizeof *parm);
-	parm->type = video->streaming->type;
+	parm->type = stream->type;
 
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
 		parm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
 		parm->parm.capture.capturemode = 0;
 		parm->parm.capture.timeperframe.numerator = numerator;
@@ -297,19 +298,19 @@
 	return 0;
 }
 
-static int uvc_v4l2_set_streamparm(struct uvc_video_device *video,
+static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 		struct v4l2_streamparm *parm)
 {
-	struct uvc_frame *frame = video->streaming->cur_frame;
+	struct uvc_frame *frame = stream->cur_frame;
 	struct uvc_streaming_control probe;
 	struct v4l2_fract timeperframe;
 	uint32_t interval;
 	int ret;
 
-	if (parm->type != video->streaming->type)
+	if (parm->type != stream->type)
 		return -EINVAL;
 
-	if (uvc_queue_streaming(&video->queue))
+	if (uvc_queue_streaming(&stream->queue))
 		return -EBUSY;
 
 	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -317,7 +318,7 @@
 	else
 		timeperframe = parm->parm.output.timeperframe;
 
-	memcpy(&probe, &video->streaming->ctrl, sizeof probe);
+	memcpy(&probe, &stream->ctrl, sizeof probe);
 	interval = uvc_fraction_to_interval(timeperframe.numerator,
 		timeperframe.denominator);
 
@@ -326,10 +327,11 @@
 	probe.dwFrameInterval = uvc_try_frame_interval(frame, interval);
 
 	/* Probe the device with the new settings. */
-	if ((ret = uvc_probe_video(video, &probe)) < 0)
+	ret = uvc_probe_video(stream, &probe);
+	if (ret < 0)
 		return ret;
 
-	memcpy(&video->streaming->ctrl, &probe, sizeof probe);
+	memcpy(&stream->ctrl, &probe, sizeof probe);
 
 	/* Return the actual frame period. */
 	timeperframe.numerator = probe.dwFrameInterval;
@@ -382,8 +384,8 @@
 
 	/* Check if the device already has a privileged handle. */
 	mutex_lock(&uvc_driver.open_mutex);
-	if (atomic_inc_return(&handle->device->active) != 1) {
-		atomic_dec(&handle->device->active);
+	if (atomic_inc_return(&handle->stream->active) != 1) {
+		atomic_dec(&handle->stream->active);
 		ret = -EBUSY;
 		goto done;
 	}
@@ -398,7 +400,7 @@
 static void uvc_dismiss_privileges(struct uvc_fh *handle)
 {
 	if (handle->state == UVC_HANDLE_ACTIVE)
-		atomic_dec(&handle->device->active);
+		atomic_dec(&handle->stream->active);
 
 	handle->state = UVC_HANDLE_PASSIVE;
 }
@@ -414,21 +416,21 @@
 
 static int uvc_v4l2_open(struct file *file)
 {
-	struct uvc_video_device *video;
+	struct uvc_streaming *stream;
 	struct uvc_fh *handle;
 	int ret = 0;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_open\n");
 	mutex_lock(&uvc_driver.open_mutex);
-	video = video_drvdata(file);
+	stream = video_drvdata(file);
 
-	if (video->dev->state & UVC_DEV_DISCONNECTED) {
+	if (stream->dev->state & UVC_DEV_DISCONNECTED) {
 		ret = -ENODEV;
 		goto done;
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-	ret = usb_autopm_get_interface(video->dev->intf);
+	ret = usb_autopm_get_interface(stream->dev->intf);
 	if (ret < 0)
 		goto done;
 #endif
@@ -437,28 +439,30 @@
 	handle = kzalloc(sizeof *handle, GFP_KERNEL);
 	if (handle == NULL) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-		usb_autopm_put_interface(video->dev->intf);
+		usb_autopm_put_interface(stream->dev->intf);
 #endif
 		ret = -ENOMEM;
 		goto done;
 	}
 
-	if (atomic_inc_return(&video->dev->users) == 1) {
-		if ((ret = uvc_status_start(video->dev)) < 0) {
+	if (atomic_inc_return(&stream->dev->users) == 1) {
+		ret = uvc_status_start(stream->dev);
+		if (ret < 0) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-			usb_autopm_put_interface(video->dev->intf);
+			usb_autopm_put_interface(stream->dev->intf);
 #endif
-			atomic_dec(&video->dev->users);
+			atomic_dec(&stream->dev->users);
 			kfree(handle);
 			goto done;
 		}
 	}
 
-	handle->device = video;
+	handle->video = &stream->dev->video;
+	handle->stream = stream;
 	handle->state = UVC_HANDLE_PASSIVE;
 	file->private_data = handle;
 
-	kref_get(&video->dev->kref);
+	kref_get(&stream->dev->kref);
 
 done:
 	mutex_unlock(&uvc_driver.open_mutex);
@@ -467,20 +471,20 @@
 
 static int uvc_v4l2_release(struct file *file)
 {
-	struct uvc_video_device *video = video_drvdata(file);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_release\n");
 
 	/* Only free resources if this is a privileged handle. */
 	if (uvc_has_privileges(handle)) {
-		uvc_video_enable(video, 0);
+		uvc_video_enable(stream, 0);
 
-		mutex_lock(&video->queue.mutex);
-		if (uvc_free_buffers(&video->queue) < 0)
+		mutex_lock(&stream->queue.mutex);
+		if (uvc_free_buffers(&stream->queue) < 0)
 			uvc_printk(KERN_ERR, "uvc_v4l2_release: Unable to "
 					"free buffers.\n");
-		mutex_unlock(&video->queue.mutex);
+		mutex_unlock(&stream->queue.mutex);
 	}
 
 	/* Release the file handle. */
@@ -488,21 +492,22 @@
 	kfree(handle);
 	file->private_data = NULL;
 
-	if (atomic_dec_return(&video->dev->users) == 0)
-		uvc_status_stop(video->dev);
+	if (atomic_dec_return(&stream->dev->users) == 0)
+		uvc_status_stop(stream->dev);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-	usb_autopm_put_interface(video->dev->intf);
+	usb_autopm_put_interface(stream->dev->intf);
 #endif
-	kref_put(&video->dev->kref, uvc_delete);
+	kref_put(&stream->dev->kref, uvc_delete);
 	return 0;
 }
 
 static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 {
 	struct video_device *vdev = video_devdata(file);
-	struct uvc_video_device *video = video_get_drvdata(vdev);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_video_device *video = handle->video;
+	struct uvc_streaming *stream = handle->stream;
 	long ret = 0;
 
 	switch (cmd) {
@@ -514,10 +519,10 @@
 		memset(cap, 0, sizeof *cap);
 		strlcpy(cap->driver, "uvcvideo", sizeof cap->driver);
 		strlcpy(cap->card, vdev->name, sizeof cap->card);
-		usb_make_path(video->dev->udev,
+		usb_make_path(stream->dev->udev,
 			      cap->bus_info, sizeof(cap->bus_info));
 		cap->version = DRIVER_VERSION_NUMBER;
-		if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 			cap->capabilities = V4L2_CAP_VIDEO_CAPTURE
 					  | V4L2_CAP_STREAMING;
 		else
@@ -711,15 +716,15 @@
 		enum v4l2_buf_type type = fmt->type;
 		__u32 index = fmt->index;
 
-		if (fmt->type != video->streaming->type ||
-		    fmt->index >= video->streaming->nformats)
+		if (fmt->type != stream->type ||
+		    fmt->index >= stream->nformats)
 			return -EINVAL;
 
 		memset(fmt, 0, sizeof(*fmt));
 		fmt->index = index;
 		fmt->type = type;
 
-		format = &video->streaming->format[fmt->index];
+		format = &stream->format[fmt->index];
 		fmt->flags = 0;
 		if (format->flags & UVC_FMT_FLAG_COMPRESSED)
 			fmt->flags |= V4L2_FMT_FLAG_COMPRESSED;
@@ -737,17 +742,17 @@
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_try_format(video, arg, &probe, NULL, NULL);
+		return uvc_v4l2_try_format(stream, arg, &probe, NULL, NULL);
 	}
 
 	case VIDIOC_S_FMT:
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_set_format(video, arg);
+		return uvc_v4l2_set_format(stream, arg);
 
 	case VIDIOC_G_FMT:
-		return uvc_v4l2_get_format(video, arg);
+		return uvc_v4l2_get_format(stream, arg);
 
 	/* Frame size enumeration */
 	case VIDIOC_ENUM_FRAMESIZES:
@@ -758,10 +763,10 @@
 		int i;
 
 		/* Look for the given pixel format */
-		for (i = 0; i < video->streaming->nformats; i++) {
-			if (video->streaming->format[i].fcc ==
+		for (i = 0; i < stream->nformats; i++) {
+			if (stream->format[i].fcc ==
 					fsize->pixel_format) {
-				format = &video->streaming->format[i];
+				format = &stream->format[i];
 				break;
 			}
 		}
@@ -787,10 +792,10 @@
 		int i;
 
 		/* Look for the given pixel format and frame size */
-		for (i = 0; i < video->streaming->nformats; i++) {
-			if (video->streaming->format[i].fcc ==
+		for (i = 0; i < stream->nformats; i++) {
+			if (stream->format[i].fcc ==
 					fival->pixel_format) {
-				format = &video->streaming->format[i];
+				format = &stream->format[i];
 				break;
 			}
 		}
@@ -840,21 +845,21 @@
 
 	/* Get & Set streaming parameters */
 	case VIDIOC_G_PARM:
-		return uvc_v4l2_get_streamparm(video, arg);
+		return uvc_v4l2_get_streamparm(stream, arg);
 
 	case VIDIOC_S_PARM:
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_set_streamparm(video, arg);
+		return uvc_v4l2_set_streamparm(stream, arg);
 
 	/* Cropping and scaling */
 	case VIDIOC_CROPCAP:
 	{
 		struct v4l2_cropcap *ccap = arg;
-		struct uvc_frame *frame = video->streaming->cur_frame;
+		struct uvc_frame *frame = stream->cur_frame;
 
-		if (ccap->type != video->streaming->type)
+		if (ccap->type != stream->type)
 			return -EINVAL;
 
 		ccap->bounds.left = 0;
@@ -878,16 +883,16 @@
 	{
 		struct v4l2_requestbuffers *rb = arg;
 		unsigned int bufsize =
-			video->streaming->ctrl.dwMaxVideoFrameSize;
+			stream->ctrl.dwMaxVideoFrameSize;
 
-		if (rb->type != video->streaming->type ||
+		if (rb->type != stream->type ||
 		    rb->memory != V4L2_MEMORY_MMAP)
 			return -EINVAL;
 
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		ret = uvc_alloc_buffers(&video->queue, rb->count, bufsize);
+		ret = uvc_alloc_buffers(&stream->queue, rb->count, bufsize);
 		if (ret < 0)
 			return ret;
 
@@ -900,39 +905,40 @@
 	{
 		struct v4l2_buffer *buf = arg;
 
-		if (buf->type != video->streaming->type)
+		if (buf->type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_query_buffer(&video->queue, buf);
+		return uvc_query_buffer(&stream->queue, buf);
 	}
 
 	case VIDIOC_QBUF:
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_queue_buffer(&video->queue, arg);
+		return uvc_queue_buffer(&stream->queue, arg);
 
 	case VIDIOC_DQBUF:
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_dequeue_buffer(&video->queue, arg,
+		return uvc_dequeue_buffer(&stream->queue, arg,
 			file->f_flags & O_NONBLOCK);
 
 	case VIDIOC_STREAMON:
 	{
 		int *type = arg;
 
-		if (*type != video->streaming->type)
+		if (*type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		if ((ret = uvc_video_enable(video, 1)) < 0)
+		ret = uvc_video_enable(stream, 1);
+		if (ret < 0)
 			return ret;
 		break;
 	}
@@ -941,13 +947,13 @@
 	{
 		int *type = arg;
 
-		if (*type != video->streaming->type)
+		if (*type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_video_enable(video, 0);
+		return uvc_video_enable(stream, 0);
 	}
 
 	/* Analog video standards make no sense for digital cameras. */
@@ -1078,7 +1084,9 @@
 
 static int uvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct uvc_video_device *video = video_drvdata(file);
+	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
+	struct uvc_video_queue *queue = &stream->queue;
 	struct uvc_buffer *uninitialized_var(buffer);
 	struct page *page;
 	unsigned long addr, start, size;
@@ -1090,15 +1098,15 @@
 	start = vma->vm_start;
 	size = vma->vm_end - vma->vm_start;
 
-	mutex_lock(&video->queue.mutex);
+	mutex_lock(&queue->mutex);
 
-	for (i = 0; i < video->queue.count; ++i) {
-		buffer = &video->queue.buffer[i];
+	for (i = 0; i < queue->count; ++i) {
+		buffer = &queue->buffer[i];
 		if ((buffer->buf.m.offset >> PAGE_SHIFT) == vma->vm_pgoff)
 			break;
 	}
 
-	if (i == video->queue.count || size != video->queue.buf_size) {
+	if (i == queue->count || size != queue->buf_size) {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -1109,7 +1117,7 @@
 	 */
 	vma->vm_flags |= VM_IO;
 
-	addr = (unsigned long)video->queue.mem + buffer->buf.m.offset;
+	addr = (unsigned long)queue->mem + buffer->buf.m.offset;
 	while (size > 0) {
 		page = vmalloc_to_page((void *)addr);
 		if ((ret = vm_insert_page(vma, start, page)) < 0)
@@ -1125,17 +1133,18 @@
 	uvc_vm_open(vma);
 
 done:
-	mutex_unlock(&video->queue.mutex);
+	mutex_unlock(&queue->mutex);
 	return ret;
 }
 
 static unsigned int uvc_v4l2_poll(struct file *file, poll_table *wait)
 {
-	struct uvc_video_device *video = video_drvdata(file);
+	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_poll\n");
 
-	return uvc_queue_poll(&video->queue, file, wait);
+	return uvc_queue_poll(&stream->queue, file, wait);
 }
 
 const struct v4l2_file_operations uvc_fops = {
diff -r da81aafb9c5d linux/drivers/media/video/uvc/uvc_video.c
--- a/linux/drivers/media/video/uvc/uvc_video.c	Mon Jul 20 00:16:05 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_video.c	Tue Jul 21 23:54:32 2009 +0200
@@ -61,7 +61,7 @@
 	return 0;
 }
 
-static void uvc_fixup_video_ctrl(struct uvc_video_device *video,
+static void uvc_fixup_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl)
 {
 	struct uvc_format *format;
@@ -69,10 +69,10 @@
 	unsigned int i;
 
 	if (ctrl->bFormatIndex <= 0 ||
-	    ctrl->bFormatIndex > video->streaming->nformats)
+	    ctrl->bFormatIndex > stream->nformats)
 		return;
 
-	format = &video->streaming->format[ctrl->bFormatIndex - 1];
+	format = &stream->format[ctrl->bFormatIndex - 1];
 
 	for (i = 0; i < format->nframes; ++i) {
 		if (format->frame[i].bFrameIndex == ctrl->bFrameIndex) {
@@ -86,12 +86,12 @@
 
 	if (!(format->flags & UVC_FMT_FLAG_COMPRESSED) ||
 	     (ctrl->dwMaxVideoFrameSize == 0 &&
-	      video->dev->uvc_version < 0x0110))
+	      stream->dev->uvc_version < 0x0110))
 		ctrl->dwMaxVideoFrameSize =
 			frame->dwMaxVideoFrameBufferSize;
 
-	if (video->dev->quirks & UVC_QUIRK_FIX_BANDWIDTH &&
-	    video->streaming->intf->num_altsetting > 1) {
+	if (stream->dev->quirks & UVC_QUIRK_FIX_BANDWIDTH &&
+	    stream->intf->num_altsetting > 1) {
 		u32 interval;
 		u32 bandwidth;
 
@@ -108,7 +108,7 @@
 		bandwidth = frame->wWidth * frame->wHeight / 8 * format->bpp;
 		bandwidth *= 10000000 / interval + 1;
 		bandwidth /= 1000;
-		if (video->dev->udev->speed == USB_SPEED_HIGH)
+		if (stream->dev->udev->speed == USB_SPEED_HIGH)
 			bandwidth /= 8;
 		bandwidth += 12;
 
@@ -116,14 +116,14 @@
 	}
 }
 
-static int uvc_get_video_ctrl(struct uvc_video_device *video,
+static int uvc_get_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl, int probe, __u8 query)
 {
 	__u8 *data;
 	__u16 size;
 	int ret;
 
-	size = video->dev->uvc_version >= 0x0110 ? 34 : 26;
+	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
 	data = kmalloc(size, GFP_KERNEL);
 	if (data == NULL)
 		return -ENOMEM;
@@ -131,7 +131,7 @@
 	if ((video->dev->quirks & UVC_QUIRK_PROBE_DEF) && query == UVC_GET_DEF)
 		return -EIO;
 
-	ret = __uvc_query_ctrl(video->dev, query, 0, video->streaming->intfnum,
+	ret = __uvc_query_ctrl(stream->dev, query, 0, stream->intfnum,
 		probe ? UVC_VS_PROBE_CONTROL : UVC_VS_COMMIT_CONTROL, data,
 		size, UVC_CTRL_STREAMING_TIMEOUT);
 
@@ -140,7 +140,7 @@
 		 * answer a GET_MIN or GET_MAX request with the wCompQuality
 		 * field only.
 		 */
-		uvc_warn_once(video->dev, UVC_WARN_MINMAX, "UVC non "
+		uvc_warn_once(stream->dev, UVC_WARN_MINMAX, "UVC non "
 			"compliance - GET_MIN/MAX(PROBE) incorrectly "
 			"supported. Enabling workaround.\n");
 		memset(ctrl, 0, sizeof ctrl);
@@ -152,7 +152,7 @@
 		 * video probe control. Warn once and return, the caller will
 		 * fall back to GET_CUR.
 		 */
-		uvc_warn_once(video->dev, UVC_WARN_PROBE_DEF, "UVC non "
+		uvc_warn_once(stream->dev, UVC_WARN_PROBE_DEF, "UVC non "
 			"compliance - GET_DEF(PROBE) not supported. "
 			"Enabling workaround.\n");
 		ret = -EIO;
@@ -184,7 +184,7 @@
 		ctrl->bMinVersion = data[32];
 		ctrl->bMaxVersion = data[33];
 	} else {
-		ctrl->dwClockFrequency = video->dev->clock_frequency;
+		ctrl->dwClockFrequency = stream->dev->clock_frequency;
 		ctrl->bmFramingInfo = 0;
 		ctrl->bPreferedVersion = 0;
 		ctrl->bMinVersion = 0;
@@ -195,7 +195,7 @@
 	 * dwMaxPayloadTransferSize fields. Try to get the value from the
 	 * format and frame descriptors.
 	 */
-	uvc_fixup_video_ctrl(video, ctrl);
+	uvc_fixup_video_ctrl(stream, ctrl);
 	ret = 0;
 
 out:
@@ -203,14 +203,14 @@
 	return ret;
 }
 
-static int uvc_set_video_ctrl(struct uvc_video_device *video,
+static int uvc_set_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl, int probe)
 {
 	__u8 *data;
 	__u16 size;
 	int ret;
 
-	size = video->dev->uvc_version >= 0x0110 ? 34 : 26;
+	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
 	data = kzalloc(size, GFP_KERNEL);
 	if (data == NULL)
 		return -ENOMEM;
@@ -235,8 +235,7 @@
 		data[33] = ctrl->bMaxVersion;
 	}
 
-	ret = __uvc_query_ctrl(video->dev, UVC_SET_CUR, 0,
-		video->streaming->intfnum,
+	ret = __uvc_query_ctrl(stream->dev, UVC_SET_CUR, 0, stream->intfnum,
 		probe ? UVC_VS_PROBE_CONTROL : UVC_VS_COMMIT_CONTROL, data,
 		size, UVC_CTRL_STREAMING_TIMEOUT);
 	if (ret != size) {
@@ -250,7 +249,7 @@
 	return ret;
 }
 
-int uvc_probe_video(struct uvc_video_device *video,
+int uvc_probe_video(struct uvc_streaming *stream,
 	struct uvc_streaming_control *probe)
 {
 	struct uvc_streaming_control probe_min, probe_max;
@@ -258,7 +257,7 @@
 	unsigned int i;
 	int ret;
 
-	mutex_lock(&video->streaming->mutex);
+	mutex_lock(&stream->mutex);
 
 	/* Perform probing. The device should adjust the requested values
 	 * according to its capabilities. However, some devices, namely the
@@ -267,15 +266,16 @@
 	 * that reason, if the needed bandwidth exceeds the maximum available
 	 * bandwidth, try to lower the quality.
 	 */
-	if ((ret = uvc_set_video_ctrl(video, probe, 1)) < 0)
+	ret = uvc_set_video_ctrl(stream, probe, 1);
+	if (ret < 0)
 		goto done;
 
 	/* Get the minimum and maximum values for compression settings. */
-	if (!(video->dev->quirks & UVC_QUIRK_PROBE_MINMAX)) {
-		ret = uvc_get_video_ctrl(video, &probe_min, 1, UVC_GET_MIN);
+	if (!(stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX)) {
+		ret = uvc_get_video_ctrl(stream, &probe_min, 1, UVC_GET_MIN);
 		if (ret < 0)
 			goto done;
-		ret = uvc_get_video_ctrl(video, &probe_max, 1, UVC_GET_MAX);
+		ret = uvc_get_video_ctrl(stream, &probe_max, 1, UVC_GET_MAX);
 		if (ret < 0)
 			goto done;
 
@@ -283,21 +283,21 @@
 	}
 
 	for (i = 0; i < 2; ++i) {
-		ret = uvc_set_video_ctrl(video, probe, 1);
+		ret = uvc_set_video_ctrl(stream, probe, 1);
 		if (ret < 0)
 			goto done;
-		ret = uvc_get_video_ctrl(video, probe, 1, UVC_GET_CUR);
+		ret = uvc_get_video_ctrl(stream, probe, 1, UVC_GET_CUR);
 		if (ret < 0)
 			goto done;
 
-		if (video->streaming->intf->num_altsetting == 1)
+		if (stream->intf->num_altsetting == 1)
 			break;
 
 		bandwidth = probe->dwMaxPayloadTransferSize;
-		if (bandwidth <= video->streaming->maxpsize)
+		if (bandwidth <= stream->maxpsize)
 			break;
 
-		if (video->dev->quirks & UVC_QUIRK_PROBE_MINMAX) {
+		if (stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX) {
 			ret = -ENOSPC;
 			goto done;
 		}
@@ -310,14 +310,14 @@
 	}
 
 done:
-	mutex_unlock(&video->streaming->mutex);
+	mutex_unlock(&stream->mutex);
 	return ret;
 }
 
-int uvc_commit_video(struct uvc_video_device *video,
+int uvc_commit_video(struct uvc_streaming *stream,
 	struct uvc_streaming_control *probe)
 {
-	return uvc_set_video_ctrl(video, probe, 0);
+	return uvc_set_video_ctrl(stream, probe, 0);
 }
 
 /* ------------------------------------------------------------------------
@@ -369,7 +369,7 @@
  * to be called with a NULL buf parameter. uvc_video_decode_data and
  * uvc_video_decode_end will never be called with a NULL buffer.
  */
-static int uvc_video_decode_start(struct uvc_video_device *video,
+static int uvc_video_decode_start(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
 	__u8 fid;
@@ -395,25 +395,25 @@
 	 * NULL.
 	 */
 	if (buf == NULL) {
-		video->last_fid = fid;
+		stream->last_fid = fid;
 		return -ENODATA;
 	}
 
 	/* Synchronize to the input stream by waiting for the FID bit to be
 	 * toggled when the the buffer state is not UVC_BUF_STATE_ACTIVE.
-	 * video->last_fid is initialized to -1, so the first isochronous
+	 * stream->last_fid is initialized to -1, so the first isochronous
 	 * frame will always be in sync.
 	 *
-	 * If the device doesn't toggle the FID bit, invert video->last_fid
+	 * If the device doesn't toggle the FID bit, invert stream->last_fid
 	 * when the EOF bit is set to force synchronisation on the next packet.
 	 */
 	if (buf->state != UVC_BUF_STATE_ACTIVE) {
-		if (fid == video->last_fid) {
+		if (fid == stream->last_fid) {
 			uvc_trace(UVC_TRACE_FRAME, "Dropping payload (out of "
 				"sync).\n");
-			if ((video->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&
+			if ((stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&
 			    (data[1] & UVC_STREAM_EOF))
-				video->last_fid ^= UVC_STREAM_FID;
+				stream->last_fid ^= UVC_STREAM_FID;
 			return -ENODATA;
 		}
 
@@ -428,7 +428,7 @@
 	 * last payload can be lost anyway). We thus must check if the FID has
 	 * been toggled.
 	 *
-	 * video->last_fid is initialized to -1, so the first isochronous
+	 * stream->last_fid is initialized to -1, so the first isochronous
 	 * frame will never trigger an end of frame detection.
 	 *
 	 * Empty buffers (bytesused == 0) don't trigger end of frame detection
@@ -436,22 +436,22 @@
 	 * avoids detecting end of frame conditions at FID toggling if the
 	 * previous payload had the EOF bit set.
 	 */
-	if (fid != video->last_fid && buf->buf.bytesused != 0) {
+	if (fid != stream->last_fid && buf->buf.bytesused != 0) {
 		uvc_trace(UVC_TRACE_FRAME, "Frame complete (FID bit "
 				"toggled).\n");
 		buf->state = UVC_BUF_STATE_DONE;
 		return -EAGAIN;
 	}
 
-	video->last_fid = fid;
+	stream->last_fid = fid;
 
 	return data[0];
 }
 
-static void uvc_video_decode_data(struct uvc_video_device *video,
+static void uvc_video_decode_data(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_video_queue *queue = &stream->queue;
 	unsigned int maxlen, nbytes;
 	void *mem;
 
@@ -472,7 +472,7 @@
 	}
 }
 
-static void uvc_video_decode_end(struct uvc_video_device *video,
+static void uvc_video_decode_end(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
 	/* Mark the buffer as done if the EOF marker is set. */
@@ -481,8 +481,8 @@
 		if (data[0] == len)
 			uvc_trace(UVC_TRACE_FRAME, "EOF in empty payload.\n");
 		buf->state = UVC_BUF_STATE_DONE;
-		if (video->dev->quirks & UVC_QUIRK_STREAM_NO_FID)
-			video->last_fid ^= UVC_STREAM_FID;
+		if (stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID)
+			stream->last_fid ^= UVC_STREAM_FID;
 	}
 }
 
@@ -497,26 +497,26 @@
  * uvc_video_encode_data is called for every URB and copies the data from the
  * video buffer to the transfer buffer.
  */
-static int uvc_video_encode_header(struct uvc_video_device *video,
+static int uvc_video_encode_header(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, __u8 *data, int len)
 {
 	data[0] = 2;	/* Header length */
 	data[1] = UVC_STREAM_EOH | UVC_STREAM_EOF
-		| (video->last_fid & UVC_STREAM_FID);
+		| (stream->last_fid & UVC_STREAM_FID);
 	return 2;
 }
 
-static int uvc_video_encode_data(struct uvc_video_device *video,
+static int uvc_video_encode_data(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, __u8 *data, int len)
 {
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_video_queue *queue = &stream->queue;
 	unsigned int nbytes;
 	void *mem;
 
 	/* Copy video data to the URB buffer. */
 	mem = queue->mem + buf->buf.m.offset + queue->buf_used;
 	nbytes = min((unsigned int)len, buf->buf.bytesused - queue->buf_used);
-	nbytes = min(video->bulk.max_payload_size - video->bulk.payload_size,
+	nbytes = min(stream->bulk.max_payload_size - stream->bulk.payload_size,
 			nbytes);
 	memcpy(data, mem, nbytes);
 
@@ -532,8 +532,8 @@
 /*
  * Completion handler for video URBs.
  */
-static void uvc_video_decode_isoc(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_decode_isoc(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem;
 	int ret, i;
@@ -548,31 +548,32 @@
 		/* Decode the payload header. */
 		mem = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
 		do {
-			ret = uvc_video_decode_start(video, buf, mem,
+			ret = uvc_video_decode_start(stream, buf, mem,
 				urb->iso_frame_desc[i].actual_length);
 			if (ret == -EAGAIN)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		} while (ret == -EAGAIN);
 
 		if (ret < 0)
 			continue;
 
 		/* Decode the payload data. */
-		uvc_video_decode_data(video, buf, mem + ret,
+		uvc_video_decode_data(stream, buf, mem + ret,
 			urb->iso_frame_desc[i].actual_length - ret);
 
 		/* Process the header again. */
-		uvc_video_decode_end(video, buf, mem,
+		uvc_video_decode_end(stream, buf, mem,
 			urb->iso_frame_desc[i].actual_length);
 
 		if (buf->state == UVC_BUF_STATE_DONE ||
 		    buf->state == UVC_BUF_STATE_ERROR)
-			buf = uvc_queue_next_buffer(&video->queue, buf);
+			buf = uvc_queue_next_buffer(&stream->queue, buf);
 	}
 }
 
-static void uvc_video_decode_bulk(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_decode_bulk(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem;
 	int len, ret;
@@ -582,24 +583,25 @@
 
 	mem = urb->transfer_buffer;
 	len = urb->actual_length;
-	video->bulk.payload_size += len;
+	stream->bulk.payload_size += len;
 
 	/* If the URB is the first of its payload, decode and save the
 	 * header.
 	 */
-	if (video->bulk.header_size == 0 && !video->bulk.skip_payload) {
+	if (stream->bulk.header_size == 0 && !stream->bulk.skip_payload) {
 		do {
-			ret = uvc_video_decode_start(video, buf, mem, len);
+			ret = uvc_video_decode_start(stream, buf, mem, len);
 			if (ret == -EAGAIN)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		} while (ret == -EAGAIN);
 
 		/* If an error occured skip the rest of the payload. */
 		if (ret < 0 || buf == NULL) {
-			video->bulk.skip_payload = 1;
+			stream->bulk.skip_payload = 1;
 		} else {
-			memcpy(video->bulk.header, mem, ret);
-			video->bulk.header_size = ret;
+			memcpy(stream->bulk.header, mem, ret);
+			stream->bulk.header_size = ret;
 
 			mem += ret;
 			len -= ret;
@@ -612,33 +614,34 @@
 	 */
 
 	/* Process video data. */
-	if (!video->bulk.skip_payload && buf != NULL)
-		uvc_video_decode_data(video, buf, mem, len);
+	if (!stream->bulk.skip_payload && buf != NULL)
+		uvc_video_decode_data(stream, buf, mem, len);
 
 	/* Detect the payload end by a URB smaller than the maximum size (or
 	 * a payload size equal to the maximum) and process the header again.
 	 */
 	if (urb->actual_length < urb->transfer_buffer_length ||
-	    video->bulk.payload_size >= video->bulk.max_payload_size) {
-		if (!video->bulk.skip_payload && buf != NULL) {
-			uvc_video_decode_end(video, buf, video->bulk.header,
-				video->bulk.payload_size);
+	    stream->bulk.payload_size >= stream->bulk.max_payload_size) {
+		if (!stream->bulk.skip_payload && buf != NULL) {
+			uvc_video_decode_end(stream, buf, stream->bulk.header,
+				stream->bulk.payload_size);
 			if (buf->state == UVC_BUF_STATE_DONE ||
 			    buf->state == UVC_BUF_STATE_ERROR)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		}
 
-		video->bulk.header_size = 0;
-		video->bulk.skip_payload = 0;
-		video->bulk.payload_size = 0;
+		stream->bulk.header_size = 0;
+		stream->bulk.skip_payload = 0;
+		stream->bulk.payload_size = 0;
 	}
 }
 
-static void uvc_video_encode_bulk(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_encode_bulk(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem = urb->transfer_buffer;
-	int len = video->urb_size, ret;
+	int len = stream->urb_size, ret;
 
 	if (buf == NULL) {
 		urb->transfer_buffer_length = 0;
@@ -646,34 +649,34 @@
 	}
 
 	/* If the URB is the first of its payload, add the header. */
-	if (video->bulk.header_size == 0) {
-		ret = uvc_video_encode_header(video, buf, mem, len);
-		video->bulk.header_size = ret;
-		video->bulk.payload_size += ret;
+	if (stream->bulk.header_size == 0) {
+		ret = uvc_video_encode_header(stream, buf, mem, len);
+		stream->bulk.header_size = ret;
+		stream->bulk.payload_size += ret;
 		mem += ret;
 		len -= ret;
 	}
 
 	/* Process video data. */
-	ret = uvc_video_encode_data(video, buf, mem, len);
+	ret = uvc_video_encode_data(stream, buf, mem, len);
 
-	video->bulk.payload_size += ret;
+	stream->bulk.payload_size += ret;
 	len -= ret;
 
-	if (buf->buf.bytesused == video->queue.buf_used ||
-	    video->bulk.payload_size == video->bulk.max_payload_size) {
-		if (buf->buf.bytesused == video->queue.buf_used) {
-			video->queue.buf_used = 0;
+	if (buf->buf.bytesused == stream->queue.buf_used ||
+	    stream->bulk.payload_size == stream->bulk.max_payload_size) {
+		if (buf->buf.bytesused == stream->queue.buf_used) {
+			stream->queue.buf_used = 0;
 			buf->state = UVC_BUF_STATE_DONE;
-			uvc_queue_next_buffer(&video->queue, buf);
-			video->last_fid ^= UVC_STREAM_FID;
+			uvc_queue_next_buffer(&stream->queue, buf);
+			stream->last_fid ^= UVC_STREAM_FID;
 		}
 
-		video->bulk.header_size = 0;
-		video->bulk.payload_size = 0;
+		stream->bulk.header_size = 0;
+		stream->bulk.payload_size = 0;
 	}
 
-	urb->transfer_buffer_length = video->urb_size - len;
+	urb->transfer_buffer_length = stream->urb_size - len;
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
@@ -682,8 +685,8 @@
 static void uvc_video_complete(struct urb *urb)
 #endif
 {
-	struct uvc_video_device *video = urb->context;
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_streaming *stream = urb->context;
+	struct uvc_video_queue *queue = &stream->queue;
 	struct uvc_buffer *buf = NULL;
 	unsigned long flags;
 	int ret;
@@ -697,7 +700,7 @@
 			"completion handler.\n", urb->status);
 
 	case -ENOENT:		/* usb_kill_urb() called. */
-		if (video->frozen)
+		if (stream->frozen)
 			return;
 
 	case -ECONNRESET:	/* usb_unlink_urb() called. */
@@ -712,7 +715,7 @@
 				       queue);
 	spin_unlock_irqrestore(&queue->irqlock, flags);
 
-	video->decode(urb, video, buf);
+	stream->decode(urb, stream, buf);
 
 	if ((ret = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
 		uvc_printk(KERN_ERR, "Failed to resubmit video URB (%d).\n",
@@ -723,19 +726,19 @@
 /*
  * Free transfer buffers.
  */
-static void uvc_free_urb_buffers(struct uvc_video_device *video)
+static void uvc_free_urb_buffers(struct uvc_streaming *stream)
 {
 	unsigned int i;
 
 	for (i = 0; i < UVC_URBS; ++i) {
-		if (video->urb_buffer[i]) {
-			usb_buffer_free(video->dev->udev, video->urb_size,
-				video->urb_buffer[i], video->urb_dma[i]);
-			video->urb_buffer[i] = NULL;
+		if (stream->urb_buffer[i]) {
+			usb_buffer_free(stream->dev->udev, stream->urb_size,
+				stream->urb_buffer[i], stream->urb_dma[i]);
+			stream->urb_buffer[i] = NULL;
 		}
 	}
 
-	video->urb_size = 0;
+	stream->urb_size = 0;
 }
 
 /*
@@ -749,15 +752,15 @@
  *
  * Return the number of allocated packets on success or 0 when out of memory.
  */
-static int uvc_alloc_urb_buffers(struct uvc_video_device *video,
+static int uvc_alloc_urb_buffers(struct uvc_streaming *stream,
 	unsigned int size, unsigned int psize, gfp_t gfp_flags)
 {
 	unsigned int npackets;
 	unsigned int i;
 
 	/* Buffers are already allocated, bail out. */
-	if (video->urb_size)
-		return video->urb_size / psize;
+	if (stream->urb_size)
+		return stream->urb_size / psize;
 
 	/* Compute the number of packets. Bulk endpoints might transfer UVC
 	 * payloads accross multiple URBs.
@@ -769,17 +772,17 @@
 	/* Retry allocations until one succeed. */
 	for (; npackets > 1; npackets /= 2) {
 		for (i = 0; i < UVC_URBS; ++i) {
-			video->urb_buffer[i] = usb_buffer_alloc(
-				video->dev->udev, psize * npackets,
-				gfp_flags | __GFP_NOWARN, &video->urb_dma[i]);
-			if (!video->urb_buffer[i]) {
-				uvc_free_urb_buffers(video);
+			stream->urb_buffer[i] = usb_buffer_alloc(
+				stream->dev->udev, psize * npackets,
+				gfp_flags | __GFP_NOWARN, &stream->urb_dma[i]);
+			if (!stream->urb_buffer[i]) {
+				uvc_free_urb_buffers(stream);
 				break;
 			}
 		}
 
 		if (i == UVC_URBS) {
-			video->urb_size = psize * npackets;
+			stream->urb_size = psize * npackets;
 			return npackets;
 		}
 	}
@@ -790,29 +793,30 @@
 /*
  * Uninitialize isochronous/bulk URBs and free transfer buffers.
  */
-static void uvc_uninit_video(struct uvc_video_device *video, int free_buffers)
+static void uvc_uninit_video(struct uvc_streaming *stream, int free_buffers)
 {
 	struct urb *urb;
 	unsigned int i;
 
 	for (i = 0; i < UVC_URBS; ++i) {
-		if ((urb = video->urb[i]) == NULL)
+		urb = stream->urb[i];
+		if (urb == NULL)
 			continue;
 
 		usb_kill_urb(urb);
 		usb_free_urb(urb);
-		video->urb[i] = NULL;
+		stream->urb[i] = NULL;
 	}
 
 	if (free_buffers)
-		uvc_free_urb_buffers(video);
+		uvc_free_urb_buffers(stream);
 }
 
 /*
  * Initialize isochronous URBs and allocate transfer buffers. The packet size
  * is given by the endpoint.
  */
-static int uvc_init_video_isoc(struct uvc_video_device *video,
+static int uvc_init_video_isoc(struct uvc_streaming *stream,
 	struct usb_host_endpoint *ep, gfp_t gfp_flags)
 {
 	struct urb *urb;
@@ -822,9 +826,9 @@
 
 	psize = le16_to_cpu(ep->desc.wMaxPacketSize);
 	psize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));
-	size = video->streaming->ctrl.dwMaxVideoFrameSize;
+	size = stream->ctrl.dwMaxVideoFrameSize;
 
-	npackets = uvc_alloc_urb_buffers(video, size, psize, gfp_flags);
+	npackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);
 	if (npackets == 0)
 		return -ENOMEM;
 
@@ -833,18 +837,18 @@
 	for (i = 0; i < UVC_URBS; ++i) {
 		urb = usb_alloc_urb(npackets, gfp_flags);
 		if (urb == NULL) {
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return -ENOMEM;
 		}
 
-		urb->dev = video->dev->udev;
-		urb->context = video;
-		urb->pipe = usb_rcvisocpipe(video->dev->udev,
+		urb->dev = stream->dev->udev;
+		urb->context = stream;
+		urb->pipe = usb_rcvisocpipe(stream->dev->udev,
 				ep->desc.bEndpointAddress);
 		urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
 		urb->interval = ep->desc.bInterval;
-		urb->transfer_buffer = video->urb_buffer[i];
-		urb->transfer_dma = video->urb_dma[i];
+		urb->transfer_buffer = stream->urb_buffer[i];
+		urb->transfer_dma = stream->urb_dma[i];
 		urb->complete = uvc_video_complete;
 		urb->number_of_packets = npackets;
 		urb->transfer_buffer_length = size;
@@ -854,7 +858,7 @@
 			urb->iso_frame_desc[j].length = psize;
 		}
 
-		video->urb[i] = urb;
+		stream->urb[i] = urb;
 	}
 
 	return 0;
@@ -864,7 +868,7 @@
  * Initialize bulk URBs and allocate transfer buffers. The packet size is
  * given by the endpoint.
  */
-static int uvc_init_video_bulk(struct uvc_video_device *video,
+static int uvc_init_video_bulk(struct uvc_streaming *stream,
 	struct usb_host_endpoint *ep, gfp_t gfp_flags)
 {
 	struct urb *urb;
@@ -873,39 +877,39 @@
 	u32 size;
 
 	psize = le16_to_cpu(ep->desc.wMaxPacketSize) & 0x07ff;
-	size = video->streaming->ctrl.dwMaxPayloadTransferSize;
-	video->bulk.max_payload_size = size;
+	size = stream->ctrl.dwMaxPayloadTransferSize;
+	stream->bulk.max_payload_size = size;
 
-	npackets = uvc_alloc_urb_buffers(video, size, psize, gfp_flags);
+	npackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);
 	if (npackets == 0)
 		return -ENOMEM;
 
 	size = npackets * psize;
 
 	if (usb_endpoint_dir_in(&ep->desc))
-		pipe = usb_rcvbulkpipe(video->dev->udev,
+		pipe = usb_rcvbulkpipe(stream->dev->udev,
 				       ep->desc.bEndpointAddress);
 	else
-		pipe = usb_sndbulkpipe(video->dev->udev,
+		pipe = usb_sndbulkpipe(stream->dev->udev,
 				       ep->desc.bEndpointAddress);
 
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
 		size = 0;
 
 	for (i = 0; i < UVC_URBS; ++i) {
 		urb = usb_alloc_urb(0, gfp_flags);
 		if (urb == NULL) {
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return -ENOMEM;
 		}
 
-		usb_fill_bulk_urb(urb, video->dev->udev, pipe,
-			video->urb_buffer[i], size, uvc_video_complete,
-			video);
+		usb_fill_bulk_urb(urb, stream->dev->udev, pipe,
+			stream->urb_buffer[i], size, uvc_video_complete,
+			stream);
 		urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
-		urb->transfer_dma = video->urb_dma[i];
+		urb->transfer_dma = stream->urb_dma[i];
 
-		video->urb[i] = urb;
+		stream->urb[i] = urb;
 	}
 
 	return 0;
@@ -914,35 +918,35 @@
 /*
  * Initialize isochronous/bulk URBs and allocate transfer buffers.
  */
-static int uvc_init_video(struct uvc_video_device *video, gfp_t gfp_flags)
+static int uvc_init_video(struct uvc_streaming *stream, gfp_t gfp_flags)
 {
-	struct usb_interface *intf = video->streaming->intf;
+	struct usb_interface *intf = stream->intf;
 	struct usb_host_interface *alts;
 	struct usb_host_endpoint *ep = NULL;
-	int intfnum = video->streaming->intfnum;
+	int intfnum = stream->intfnum;
 	unsigned int bandwidth, psize, i;
 	int ret;
 
-	video->last_fid = -1;
-	video->bulk.header_size = 0;
-	video->bulk.skip_payload = 0;
-	video->bulk.payload_size = 0;
+	stream->last_fid = -1;
+	stream->bulk.header_size = 0;
+	stream->bulk.skip_payload = 0;
+	stream->bulk.payload_size = 0;
 
 	if (intf->num_altsetting > 1) {
 		/* Isochronous endpoint, select the alternate setting. */
-		bandwidth = video->streaming->ctrl.dwMaxPayloadTransferSize;
+		bandwidth = stream->ctrl.dwMaxPayloadTransferSize;
 
 		if (bandwidth == 0) {
 			uvc_printk(KERN_WARNING, "device %s requested null "
 				"bandwidth, defaulting to lowest.\n",
-				video->vdev->name);
+				stream->dev->name);
 			bandwidth = 1;
 		}
 
 		for (i = 0; i < intf->num_altsetting; ++i) {
 			alts = &intf->altsetting[i];
 			ep = uvc_find_endpoint(alts,
-				video->streaming->header.bEndpointAddress);
+				stream->header.bEndpointAddress);
 			if (ep == NULL)
 				continue;
 
@@ -956,18 +960,19 @@
 		if (i >= intf->num_altsetting)
 			return -EIO;
 
-		if ((ret = usb_set_interface(video->dev->udev, intfnum, i)) < 0)
+		ret = usb_set_interface(stream->dev->udev, intfnum, i);
+		if (ret < 0)
 			return ret;
 
-		ret = uvc_init_video_isoc(video, ep, gfp_flags);
+		ret = uvc_init_video_isoc(stream, ep, gfp_flags);
 	} else {
 		/* Bulk endpoint, proceed to URB initialization. */
 		ep = uvc_find_endpoint(&intf->altsetting[0],
-				video->streaming->header.bEndpointAddress);
+				stream->header.bEndpointAddress);
 		if (ep == NULL)
 			return -EIO;
 
-		ret = uvc_init_video_bulk(video, ep, gfp_flags);
+		ret = uvc_init_video_bulk(stream, ep, gfp_flags);
 	}
 
 	if (ret < 0)
@@ -975,10 +980,11 @@
 
 	/* Submit the URBs. */
 	for (i = 0; i < UVC_URBS; ++i) {
-		if ((ret = usb_submit_urb(video->urb[i], gfp_flags)) < 0) {
+		ret = usb_submit_urb(stream->urb[i], gfp_flags);
+		if (ret < 0) {
 			uvc_printk(KERN_ERR, "Failed to submit URB %u "
 					"(%d).\n", i, ret);
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return ret;
 		}
 	}
@@ -997,14 +1003,14 @@
  * video buffers in any way. We mark the device as frozen to make sure the URB
  * completion handler won't try to cancel the queue when we kill the URBs.
  */
-int uvc_video_suspend(struct uvc_video_device *video)
+int uvc_video_suspend(struct uvc_streaming *stream)
 {
-	if (!uvc_queue_streaming(&video->queue))
+	if (!uvc_queue_streaming(&stream->queue))
 		return 0;
 
-	video->frozen = 1;
-	uvc_uninit_video(video, 0);
-	usb_set_interface(video->dev->udev, video->streaming->intfnum, 0);
+	stream->frozen = 1;
+	uvc_uninit_video(stream, 0);
+	usb_set_interface(stream->dev->udev, stream->intfnum, 0);
 	return 0;
 }
 
@@ -1016,22 +1022,24 @@
  * buffers, making sure userspace applications are notified of the problem
  * instead of waiting forever.
  */
-int uvc_video_resume(struct uvc_video_device *video)
+int uvc_video_resume(struct uvc_streaming *stream)
 {
 	int ret;
 
-	video->frozen = 0;
+	stream->frozen = 0;
 
-	if ((ret = uvc_commit_video(video, &video->streaming->ctrl)) < 0) {
-		uvc_queue_enable(&video->queue, 0);
+	ret = uvc_commit_video(stream, &stream->ctrl);
+	if (ret < 0) {
+		uvc_queue_enable(&stream->queue, 0);
 		return ret;
 	}
 
-	if (!uvc_queue_streaming(&video->queue))
+	if (!uvc_queue_streaming(&stream->queue))
 		return 0;
 
-	if ((ret = uvc_init_video(video, GFP_NOIO)) < 0)
-		uvc_queue_enable(&video->queue, 0);
+	ret = uvc_init_video(stream, GFP_NOIO);
+	if (ret < 0)
+		uvc_queue_enable(&stream->queue, 0);
 
 	return ret;
 }
@@ -1050,48 +1058,53 @@
  *
  * This function is called before registering the device with V4L.
  */
-int uvc_video_init(struct uvc_video_device *video)
+int uvc_video_init(struct uvc_streaming *stream)
 {
-	struct uvc_streaming_control *probe = &video->streaming->ctrl;
+	struct uvc_streaming_control *probe = &stream->ctrl;
 	struct uvc_format *format = NULL;
 	struct uvc_frame *frame = NULL;
 	unsigned int i;
 	int ret;
 
-	if (video->streaming->nformats == 0) {
+	if (stream->nformats == 0) {
 		uvc_printk(KERN_INFO, "No supported video formats found.\n");
 		return -EINVAL;
 	}
 
+	atomic_set(&stream->active, 0);
+
+	/* Initialize the video buffers queue. */
+	uvc_queue_init(&stream->queue, stream->type);
+
 	/* Alternate setting 0 should be the default, yet the XBox Live Vision
 	 * Cam (and possibly other devices) crash or otherwise misbehave if
 	 * they don't receive a SET_INTERFACE request before any other video
 	 * control request.
 	 */
-	usb_set_interface(video->dev->udev, video->streaming->intfnum, 0);
+	usb_set_interface(stream->dev->udev, stream->intfnum, 0);
 
 	/* Set the streaming probe control with default streaming parameters
 	 * retrieved from the device. Webcams that don't suport GET_DEF
 	 * requests on the probe control will just keep their current streaming
 	 * parameters.
 	 */
-	if (uvc_get_video_ctrl(video, probe, 1, UVC_GET_DEF) == 0)
-		uvc_set_video_ctrl(video, probe, 1);
+	if (uvc_get_video_ctrl(stream, probe, 1, UVC_GET_DEF) == 0)
+		uvc_set_video_ctrl(stream, probe, 1);
 
 	/* Initialize the streaming parameters with the probe control current
 	 * value. This makes sure SET_CUR requests on the streaming commit
 	 * control will always use values retrieved from a successful GET_CUR
 	 * request on the probe control, as required by the UVC specification.
 	 */
-	ret = uvc_get_video_ctrl(video, probe, 1, UVC_GET_CUR);
+	ret = uvc_get_video_ctrl(stream, probe, 1, UVC_GET_CUR);
 	if (ret < 0)
 		return ret;
 
 	/* Check if the default format descriptor exists. Use the first
 	 * available format otherwise.
 	 */
-	for (i = video->streaming->nformats; i > 0; --i) {
-		format = &video->streaming->format[i-1];
+	for (i = stream->nformats; i > 0; --i) {
+		format = &stream->format[i-1];
 		if (format->index == probe->bFormatIndex)
 			break;
 	}
@@ -1116,21 +1129,20 @@
 	probe->bFormatIndex = format->index;
 	probe->bFrameIndex = frame->bFrameIndex;
 
-	video->streaming->cur_format = format;
-	video->streaming->cur_frame = frame;
-	atomic_set(&video->active, 0);
+	stream->cur_format = format;
+	stream->cur_frame = frame;
 
 	/* Select the video decoding function */
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		if (video->dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)
-			video->decode = uvc_video_decode_isight;
-		else if (video->streaming->intf->num_altsetting > 1)
-			video->decode = uvc_video_decode_isoc;
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		if (stream->dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)
+			stream->decode = uvc_video_decode_isight;
+		else if (stream->intf->num_altsetting > 1)
+			stream->decode = uvc_video_decode_isoc;
 		else
-			video->decode = uvc_video_decode_bulk;
+			stream->decode = uvc_video_decode_bulk;
 	} else {
-		if (video->streaming->intf->num_altsetting == 1)
-			video->decode = uvc_video_encode_bulk;
+		if (stream->intf->num_altsetting == 1)
+			stream->decode = uvc_video_encode_bulk;
 		else {
 			uvc_printk(KERN_INFO, "Isochronous endpoints are not "
 				"supported for video output devices.\n");
@@ -1144,31 +1156,32 @@
 /*
  * Enable or disable the video stream.
  */
-int uvc_video_enable(struct uvc_video_device *video, int enable)
+int uvc_video_enable(struct uvc_streaming *stream, int enable)
 {
 	int ret;
 
 	if (!enable) {
-		uvc_uninit_video(video, 1);
-		usb_set_interface(video->dev->udev,
-			video->streaming->intfnum, 0);
-		uvc_queue_enable(&video->queue, 0);
+		uvc_uninit_video(stream, 1);
+		usb_set_interface(stream->dev->udev, stream->intfnum, 0);
+		uvc_queue_enable(&stream->queue, 0);
 		return 0;
 	}
 
-	if ((video->streaming->cur_format->flags & UVC_FMT_FLAG_COMPRESSED) ||
+	if ((stream->cur_format->flags & UVC_FMT_FLAG_COMPRESSED) ||
 	    uvc_no_drop_param)
-		video->queue.flags &= ~UVC_QUEUE_DROP_INCOMPLETE;
+		stream->queue.flags &= ~UVC_QUEUE_DROP_INCOMPLETE;
 	else
-		video->queue.flags |= UVC_QUEUE_DROP_INCOMPLETE;
+		stream->queue.flags |= UVC_QUEUE_DROP_INCOMPLETE;
 
-	if ((ret = uvc_queue_enable(&video->queue, 1)) < 0)
+	ret = uvc_queue_enable(&stream->queue, 1);
+	if (ret < 0)
 		return ret;
 
 	/* Commit the streaming parameters. */
-	if ((ret = uvc_commit_video(video, &video->streaming->ctrl)) < 0)
+	ret = uvc_commit_video(stream, &stream->ctrl);
+	if (ret < 0)
 		return ret;
 
-	return uvc_init_video(video, GFP_KERNEL);
+	return uvc_init_video(stream, GFP_KERNEL);
 }
 
diff -r da81aafb9c5d linux/drivers/media/video/uvc/uvcvideo.h
--- a/linux/drivers/media/video/uvc/uvcvideo.h	Mon Jul 20 00:16:05 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvcvideo.h	Tue Jul 21 23:54:32 2009 +0200
@@ -362,26 +362,6 @@
 	__u8 bTriggerUsage;
 };
 
-struct uvc_streaming {
-	struct list_head list;
-
-	struct usb_interface *intf;
-	int intfnum;
-	__u16 maxpsize;
-
-	struct uvc_streaming_header header;
-	enum v4l2_buf_type type;
-
-	unsigned int nformats;
-	struct uvc_format *format;
-
-	struct uvc_streaming_control ctrl;
-	struct uvc_format *cur_format;
-	struct uvc_frame *cur_frame;
-
-	struct mutex mutex;
-};
-
 enum uvc_buffer_state {
 	UVC_BUF_STATE_IDLE	= 0,
 	UVC_BUF_STATE_QUEUED	= 1,
@@ -423,26 +403,31 @@
 	struct list_head irqqueue;
 };
 
-struct uvc_video_device {
+struct uvc_streaming {
+	struct list_head list;
 	struct uvc_device *dev;
 	struct video_device *vdev;
 	atomic_t active;
+
+	struct usb_interface *intf;
+	int intfnum;
+	__u16 maxpsize;
+
+	struct uvc_streaming_header header;
+	enum v4l2_buf_type type;
+
+	unsigned int nformats;
+	struct uvc_format *format;
+
+	struct uvc_streaming_control ctrl;
+	struct uvc_format *cur_format;
+	struct uvc_frame *cur_frame;
+
+	struct mutex mutex;
+
 	unsigned int frozen : 1;
-
-	struct list_head iterms;		/* Input terminals */
-	struct uvc_entity *oterm;		/* Output terminal */
-	struct uvc_entity *sterm;		/* USB streaming terminal */
-	struct uvc_entity *processing;
-	struct uvc_entity *selector;
-	struct list_head extensions;
-	struct mutex ctrl_mutex;
-
 	struct uvc_video_queue queue;
-
-	/* Video streaming object, must always be non-NULL. */
-	struct uvc_streaming *streaming;
-
-	void (*decode) (struct urb *urb, struct uvc_video_device *video,
+	void (*decode) (struct urb *urb, struct uvc_streaming *video,
 			struct uvc_buffer *buf);
 
 	/* Context data used by the bulk completion handler. */
@@ -462,6 +447,18 @@
 	__u8 last_fid;
 };
 
+struct uvc_video_device {
+	struct uvc_device *dev;
+
+	struct list_head iterms;		/* Input terminals */
+	struct uvc_entity *oterm;		/* Output terminal */
+	struct uvc_entity *sterm;		/* USB streaming terminal */
+	struct uvc_entity *processing;
+	struct uvc_entity *selector;
+	struct list_head extensions;
+	struct mutex ctrl_mutex;
+};
+
 enum uvc_device_state {
 	UVC_DEV_DISCONNECTED = 1,
 };
@@ -487,15 +484,15 @@
 
 	struct uvc_video_device video;
 
+	/* Video Streaming interfaces */
+	struct list_head streams;
+
 	/* Status Interrupt Endpoint */
 	struct usb_host_endpoint *int_ep;
 	struct urb *int_urb;
 	__u8 *status;
 	struct input_dev *input;
 	char input_phys[64];
-
-	/* Video Streaming interfaces */
-	struct list_head streaming;
 };
 
 enum uvc_handle_state {
@@ -504,7 +501,8 @@
 };
 
 struct uvc_fh {
-	struct uvc_video_device *device;
+	struct uvc_video_device *video;
+	struct uvc_streaming *stream;
 	enum uvc_handle_state state;
 };
 
@@ -601,13 +599,13 @@
 extern const struct v4l2_file_operations uvc_fops;
 
 /* Video */
-extern int uvc_video_init(struct uvc_video_device *video);
-extern int uvc_video_suspend(struct uvc_video_device *video);
-extern int uvc_video_resume(struct uvc_video_device *video);
-extern int uvc_video_enable(struct uvc_video_device *video, int enable);
-extern int uvc_probe_video(struct uvc_video_device *video,
+extern int uvc_video_init(struct uvc_streaming *stream);
+extern int uvc_video_suspend(struct uvc_streaming *stream);
+extern int uvc_video_resume(struct uvc_streaming *stream);
+extern int uvc_video_enable(struct uvc_streaming *stream, int enable);
+extern int uvc_probe_video(struct uvc_streaming *stream,
 		struct uvc_streaming_control *probe);
-extern int uvc_commit_video(struct uvc_video_device *video,
+extern int uvc_commit_video(struct uvc_streaming *stream,
 		struct uvc_streaming_control *ctrl);
 extern int uvc_query_ctrl(struct uvc_device *dev, __u8 query, __u8 unit,
 		__u8 intfnum, __u8 cs, void *data, __u16 size);
@@ -661,7 +659,7 @@
 		struct usb_host_interface *alts, __u8 epaddr);
 
 /* Quirks support */
-void uvc_video_decode_isight(struct urb *urb, struct uvc_video_device *video,
+void uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,
 		struct uvc_buffer *buf);
 
 #endif /* __KERNEL__ */



From laurent.pinchart at skynet.be  Wed Jul 22 20:46:21 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Wed, 22 Jul 2009 20:46:21 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <20090722131106.GA11446@bitwizard.nl>
References: <20090722113406.GF1662@bitwizard.nl>
	<200907221357.39763.laurent.pinchart@skynet.be>
	<20090722131106.GA11446@bitwizard.nl>
Message-ID: <200907222046.22331.laurent.pinchart@skynet.be>

Hi Rogier,

On Wednesday 22 July 2009 15:11:06 Rogier Wolff wrote:
> On Wed, Jul 22, 2009 at 01:57:39PM +0200, Laurent Pinchart wrote:
> > On Wednesday 22 July 2009 13:34:06 Rogier Wolff wrote:

[snip]

> > Does the driver print any error message to the kernel log ? What error
> > messages does luvcview print ?
>
> [12599.183315] quickcam: frame lost
> [14091.528045] usb 6-1: USB disconnect, address 2
> ^^^ I pulled my quickcam.

You're not capturing from the quickcam, are you ?

> [17797.022857] luvcview[32185]: segfault at 14 ip b7eca23d sp b71a8fa0
> error 6 in libSDL-1.2.so.0.11.2[b7e88000+67000]
>
> ^^^ I resized the luvcview window.
>
> It just shows a green window, where I presume the video data normally
> goes... :-)
>
> luvcview 0.2.4
>
> SDL information:
>   Video driver: x11
>   A window manager is available
> Device information:
>   Device path:  /dev/video0
> Stream settings:
>   Frame format: MJPG
>   Frame size:   640x480
>   Frame rate:   30 fps

[snip]

Please post all messages printed by the uvcvideo driver to the kernel log from 
driver loading to luvcview crash.

> > > P.P.S. Mailman stinks. The standard says Email addresses are case
> > > insensitive. I subscribe in all-lowercase, it doesn't go through if I
> > > send from my "normal" spelling email address, e.g. as in my signature.
> >
> > Really ? RFC281, page 13
> > "The local-part of a mailbox MUST BE treated as case sensitive."
>
> Hmm. maybe I'm remembering things wrong, maybe this got changed, 281
> must be superceded some 5 times at least... (from memory, which
> apparantly is leaky anyway).

Sorry, typo, that was 2821 :-)

Regards,

Laurent Pinchart



From pj.assis at gmail.com  Wed Jul 22 22:45:16 2009
From: pj.assis at gmail.com (Paulo Assis)
Date: Wed, 22 Jul 2009 21:45:16 +0100
Subject: [Linux-uvc-devel] settings for Device 002: ID 0402:5606 ALi Corp
In-Reply-To: <1248287146.4014.1.camel@tobarello-laptop>
References: <99dcbcca0907210553x5ea70645mc220073bddea138b@mail.gmail.com>
	<59cf47a80907210758o53846b86l53de06823fec0456@mail.gmail.com>
	<59cf47a80907210802u7cac0a17q5bcedccaf087bac0@mail.gmail.com>
	<200907211705.40248.laurent.pinchart@skynet.be>
	<1248191912.3825.26.camel@tobarello-laptop>
	<59cf47a80907210942i757c7b20k80368d142a9a7733@mail.gmail.com>
	<1248254198.4409.14.camel@tobarello-laptop>
	<59cf47a80907220601x455d2449w179d4e16f43ce8ee@mail.gmail.com>
	<1248287146.4014.1.camel@tobarello-laptop>
Message-ID: <59cf47a80907221345v145ccb14t4f6b7a7874bd0250@mail.gmail.com>

Tommaso,

dmesg output is not strange, it is a standard output for the trace
level you set.
Did you modified the exposure settings? I couldn't find any references
to that in the posted output.

Best regards,
Paulo

2009/7/22 Tommaso Gardumi <tommaso.gardumi at gmail.com>:
> Here again Paulo,
> After the modification of /etc/modprobe.d/uvcvideo.conf
> still no success.
> the output of dmesg is even more strange now:
>
>
>
>
> Il giorno mer, 22/07/2009 alle 14.01 +0100, Paulo Assis ha scritto:
>
> Tommaso,
>
> I find it strange that you cannot change the exposure setting, please
> set the trace parameter to 255,
> edit /etc/modprobe.d/uvcvideo.conf and add:
> options uvcvideo trace=255
>
> now reload the uvcvideo module, and check dmesg after tweaking the
> exposure control (set it to manual, disable "Exposure, Auto Priority"
> and change the "Exposure (Absolute)" value).
>
> Best regards,
> Paulo
>
>
> 2009/7/22 Tommaso Gardumi <tommaso.gardumi at gmail.com>
>>
>> Hi Paul,
>> no good news in the direction you suggested me.
>> Just to be more specfic this my graphic card:
>> dmesg | grep intel
>> [?? 10.484033] agpgart-intel 0000:00:00.0: Intel 965GM Chipset
>> [?? 10.484804] agpgart-intel 0000:00:00.0: detected 7676K stolen memory
>> [?? 10.487429] agpgart-intel 0000:00:00.0: AGP aperture is 256M @
>> 0xd0000000
>>
>> And again, don't know if it's normal but look at this output:
>> dmesg | grep video
>> [??? 1.239259] pci 0000:00:02.0: Boot video device
>> [?? 10.842081] Linux video capture interface: v2.00
>> [?? 10.919121] uvcvideo: Found UVC 1.00 device USB2.0 Camera (0402:5606)
>> [?? 10.935215] usbcore: registered new interface driver uvcvideo
>> [? 109.687343] uvcvideo: UVC non compliance - GET_MIN/MAX(PROBE)
>> incorrectly supported. Enabling workaround.
>> [? 171.749878] uvcvideo: Failed to query (129) UVC control 3 (unit 1) :
>> -32 (exp. 1).
>> [? 171.750501] uvcvideo: Failed to query (129) UVC control 3 (unit 1) :
>> -32 (exp. 1).
>> [? 173.143512] uvcvideo: device USB2.0 Camera requested null bandwidth,
>> defaulting to lowest.
>>
>> Thanks
>>
>>
>>
>>
>> Il giorno mar, 21/07/2009 alle 17.42 +0100, Paulo Assis ha scritto:
>>
>> Hi,
>> The colors are completly wrong it looks like a color channel is missing or
>> maybe switched.
>> Are you sure this is not a graphic card issue ? Could you try disabling
>> hardware acceleration:
>> guvcview --hwd_acel=0
>> This prevents the use of hardware overlays, it decreases performance but
>> could if the colors are OK it may signal a problem with you graphic card.
>>
>> best regards,
>> Paulo
>>
>> 2009/7/21 Tommaso Gardumi <tommaso.gardumi at gmail.com>
>>
>> Sorry the strange values was an attempt to correct the default broken
>> visualisation.
>>
>> I've set everithing back to default but what i get is always the same.
>> I've noticed that when i try to switch to Auto exposure i get this
>> error:
>> VIDIOC_S_CTRL - Unable to set control: Errore di I/O
>> Exposure, Auto Priority change to 1 failed
>> VIDIOC_G_CTRL - Unable to get control: Errore di I/O
>> hardware get failed
>>
>> And if i set to manual exposure and try to change the value nothing
>> happens.
>> ?Even switching between MJPG and YUYV and changing resolution and fps to
>> any possible combination leave me with this quality (.jpg attached)
>>
>>
>> Il giorno mar, 21/07/2009 alle 17.05 +0200, Laurent Pinchart ha scritto:
>>
>> > On Tuesday 21 July 2009 17:02:37 Paulo Assis wrote:
>> > > Also make sure to set an appropriate ?value to exposure and white
>> > > balance.
>> > > hue also seems to be set at an invalid value!!!
>> > >
>> > > guvcview output:
>> > > Hue, -4:1:4, default 0
>> >
>> > As this is consecutive to an Ubuntu upgrade, my guess is that libv4l2
>> > might
>> > not set proper default values.
>> >
>> > Regards,
>> >
>> > Laurent Pinchart
>> >
>>
>>
>


From R.E.Wolff at BitWizard.nl  Thu Jul 23 07:20:41 2009
From: R.E.Wolff at BitWizard.nl (Rogier Wolff)
Date: Thu, 23 Jul 2009 07:20:41 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <200907221357.39763.laurent.pinchart@skynet.be>
References: <20090722113406.GF1662@bitwizard.nl>
	<200907221357.39763.laurent.pinchart@skynet.be>
Message-ID: <20090723052040.GA3608@bitwizard.nl>

On Wed, Jul 22, 2009 at 01:57:39PM +0200, Laurent Pinchart wrote:
> On Wednesday 22 July 2009 13:34:06 Rogier Wolff wrote:
> > Hi,
> >
> > I bought a 5 mpixel webcam. And as a reviewer mentioned "better than
> > 1.3 mpixel", I expected about 1.3Mpixels.
> >
> > It seems to be 0.3 mpixels: 640x480. However I can't seem to be able to
> > change resolutions in wxcam.
> 
> Based on the USB VID:PID, your camera supports the following resolutions:
...
> 640x480

Correct, it seems. I'm still looking for a cheapish camera that has
a bigger sensor. Does anybody know one such webcam?

> 'lsusb -v -d 058f:3820' can help you quickly verify this.
> 
> > Anyway, wxcam sees a 640x480 image, but every other program that
> > I've been trying gives errors:
> > gqcam
> > lucview
> > xine
> > codeine
> > mplayer
> >
> > gqcam is the most "informative": It shows:
> >   Error reading image...
> > at a rate similar to the refresh rate.
> 
> Does the driver print any error message to the kernel log ? 

No. 

> What error messages does luvcview print ?

None. 


This is the "per frame" list of system calles. 

fd 3 = link to X server
fd 4 = ??
fd 5 = /dev/video0

(I redetected my uvc cam to take first position)

26214 <... ioctl resumed> , 0x85096dc)  = 0
26214 ioctl(5, VIDIOC_QBUF, 0x85096dc)  = 0
26214 select(5, [4], [4], NULL, NULL)   = 1 (out [4])
26214 writev(4, [{"\205\23\r\0\204\0\0\0\r\0\200\5\16\0\200\5\1\0\300\5YUY2\0\0\0\0\0\0\0\0\200\2\0\2\0\0\0\0\200\2\0\2\200\2\0\2\0\3\3\3+\3\1\0"..., 56}, {NULL, 0}, {""..., 0}], 3) = 56
26214 select(5, [4], [], NULL, NULL)    = 1 (in [4])
26214 read(4, "\1\1#\0\0\0\0\0\3\0\200\5\0\0\0\0\4\0\0\0\0\0\0\0\0\353\222\n\0\0\0\0"..., 4096) = 32
26214 read(4, 0x84e5c38, 4096)          = -1 EAGAIN (Resource temporarily unavailable)
26214 select(4, [3], [3], NULL, NULL)   = 1 (out [3])
26214 writev(3, [{"\22\0\17\0\3\0\200\5'\0\0\0\37\0\0\0\10\0\1\0\"\0\0\0LUVCview (c) Michel Xhaard, 09 Fps\0\0\22\0\17\0\3\0\200\5\1\1\0\0\362\0\0\0\10\200\0\0\"\0\0\0LUVCview (c) Michel Xhaard, 09 Fps\4\0+\0\1\0"..., 124}, {NULL, 0}, {""..., 0}], 3) = 124
26214 select(4, [3], [], NULL, NULL)    = 1 (in [3])
26214 read(3, "\34\200w\0\3\0\200\5'\0\0\0\356:7\5\0\255\242\277\332\37\t\0108\256\242\277\3\0\200\5\34\200x\0\3\0\200\5\1\1\0\0\356:7\5\0\255\242\277\332\37\t\0108\256\242\277\3\0\200\5\1\1y\0\0\0\0\0\3\0\200\5\0\0\0\0\4\0\0\0\10\0\0\0x\365\313\r\0\0\0\0"..., 4096) = 96
26214 read(3, 0x84dae38, 4096)          = -1 EAGAIN (Resource temporarily unavailable)
26214 nanosleep({0, 10000000}, {0, 10000000}) = 0
26214 gettimeofday({1248325484, 333203}, NULL) = 0
26214 ioctl(5, VIDIOC_DQBUF <unfinished ...>
26215 <... nanosleep resumed> {0, 50000000}) = 0
26215 read(3, 0x84dae38, 4096)          = -1 EAGAIN (Resource temporarily unavailable)
26215 read(3, 0x84dae38, 4096)          = -1 EAGAIN (Resource temporarily unavailable)
26215 read(3, 0x84dae38, 4096)          = -1 EAGAIN (Resource temporarily unavailable)
26215 select(4, [3], NULL, NULL, {0, 0}) = 0 (Timeout)
26215 nanosleep({0, 50000000}, {0, 50000000}) = 0
26215 read(3, 0x84dae38, 4096)          = -1 EAGAIN (Resource temporarily unavailable)
26215 select(4, [3], NULL, NULL, {0, 0}) = 0 (Timeout)
26215 nanosleep({0, 50000000},  <unfinished ...>
26214 <... ioctl resumed> , 0x85096dc)  = 0
26214 ioctl(5, VIDIOC_QBUF, 0x85096dc)  = 0

My kernel log shows: 

[87391.805677] usbcore: deregistering interface driver uvcvideo
[87404.523998] uvcvideo: Found UVC 1.00 device USB 2.0 PC Camera (058f:3820)
[87404.526510] input: USB 2.0 PC Camera as /devices/pci0000:00/0000:00:1d.2/usb8/8-2/8-2:1.0/input/input7
[87404.544709] usbcore: registered new interface driver uvcvideo
[87404.544714] USB Video Class driver (v0.1.0)

(I first reported it showed "nothing" because I didn't realize it
printed things at startup.)

	Roger. 

-- 
** R.E.Wolff at BitWizard.nl ** http://www.BitWizard.nl/ ** +31-15-2600998 **
**    Delftechpark 26 2628 XH  Delft, The Netherlands. KVK: 27239233    **
*-- BitWizard writes Linux device drivers for any device you may have! --*
Q: It doesn't work. A: Look buddy, doesn't work is an ambiguous statement. 
Does it sit on the couch all day? Is it unemployed? Please be specific! 
Define 'it' and what it isn't doing. --------- Adapted from lxrbot FAQ


From jon.fairbairn at cl.cam.ac.uk  Thu Jul 23 10:15:19 2009
From: jon.fairbairn at cl.cam.ac.uk (Jon Fairbairn)
Date: Thu, 23 Jul 2009 09:15:19 +0100
Subject: [Linux-uvc-devel] [PATCH] VIDIOC_[GS]_JPEGCOMP support
References: <EFE3E62A-C489-45B7-A4B2-B0E53E953AB3@federated.com>
	<200906021853.49870.laurent.pinchart@skynet.be>
	<wfprdm7d4w.fsf@calligramme.charmers>
	<200906022008.45012.laurent.pinchart@skynet.be>
Message-ID: <wf7hxz95ns.fsf@calligramme.charmers>

Laurent Pinchart <laurent.pinchart at skynet.be> writes:

> Hi Jon,
>
> On Tuesday 02 June 2009 19:34:55 Jon Fairbairn wrote:
>> Laurent Pinchart <laurent.pinchart at skynet.be> writes:
>> >
>> > I would still be interested in messages printed by the
>> > uvcvideo driver in the kernel log when running motion.
>>
>> With trace=15, there's quite a lot. I've removed what I think
>> is boring, but let me know if I've trimmed too much:
[...]
>> Enabling workaround. [ the next section repeats continually while motion is
>> running ]
>> uvcvideo: Trying format 0x47504a4d (MJPG): 352x288.
>> uvcvideo: Using default frame interval 33333.3 us (30.0 fps).
>> uvcvideo: Trying format 0x47504a4d (MJPG): 352x288.
>> uvcvideo: Using default frame interval 33333.3 us (30.0 fps).
>> uvcvideo: Setting jpeg quality to 100.
>> uvcvideo: Control 0x0098090e not found.
>> uvcvideo: Control 0x0098090f not found.
>> uvcvideo: Control 0x00980911 not found.
>> uvcvideo: Control 0x00980912 not found.
>> uvcvideo: Control 0x00980913 not found.
>> uvcvideo: Control 0x08000000 not found.
>> uvcvideo: Control 0x08000001 not found.
>> uvcvideo: device Live! Cam Optia requested null bandwidth, defaulting to
>> lowest.
>
> The problem might be in motion then.

It turns out that the problem is that the Creative Live! Cam Optia can't
drive 4.8m of cable properly (even though that's less than the spec),
and drops/corrupts frames. Then motion is rather too intolerant of bad
frames. With no extension lead or a hub (even bus-powered) in the line,
the problem disappears.

>> > > mplayer with -tv mjpeg
>> >
>> > It might still be using MJPEG, although this sounds a bit
>> > weird.
>>
>> It doesn't look like it...
> And there might be a problem in mplayer as well.

That seems likely. If I have time I'll report that. In the meantime, I
reckon the JPEGCOMP support is working. Can it go into the released
version, please?

-- 
J?n Fairbairn                                 Jon.Fairbairn at cl.cam.ac.uk




From laurent.pinchart at skynet.be  Thu Jul 23 10:28:40 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Thu, 23 Jul 2009 10:28:40 +0200
Subject: [Linux-uvc-devel] [PATCH] VIDIOC_[GS]_JPEGCOMP support
In-Reply-To: <wf7hxz95ns.fsf@calligramme.charmers>
References: <EFE3E62A-C489-45B7-A4B2-B0E53E953AB3@federated.com>
	<200906022008.45012.laurent.pinchart@skynet.be>
	<wf7hxz95ns.fsf@calligramme.charmers>
Message-ID: <200907231028.41318.laurent.pinchart@skynet.be>

Hi Jon,

On Thursday 23 July 2009 10:15:19 Jon Fairbairn wrote:
> Laurent Pinchart <laurent.pinchart at skynet.be> writes:
> > Hi Jon,
> >
> > On Tuesday 02 June 2009 19:34:55 Jon Fairbairn wrote:
> >> Laurent Pinchart <laurent.pinchart at skynet.be> writes:
> >> > I would still be interested in messages printed by the
> >> > uvcvideo driver in the kernel log when running motion.
> >>
> >> With trace=15, there's quite a lot. I've removed what I think
> >> is boring, but let me know if I've trimmed too much:
>
> [...]
>
> >> Enabling workaround. [ the next section repeats continually while motion
> >> is running ]
> >> uvcvideo: Trying format 0x47504a4d (MJPG): 352x288.
> >> uvcvideo: Using default frame interval 33333.3 us (30.0 fps).
> >> uvcvideo: Trying format 0x47504a4d (MJPG): 352x288.
> >> uvcvideo: Using default frame interval 33333.3 us (30.0 fps).
> >> uvcvideo: Setting jpeg quality to 100.
> >> uvcvideo: Control 0x0098090e not found.
> >> uvcvideo: Control 0x0098090f not found.
> >> uvcvideo: Control 0x00980911 not found.
> >> uvcvideo: Control 0x00980912 not found.
> >> uvcvideo: Control 0x00980913 not found.
> >> uvcvideo: Control 0x08000000 not found.
> >> uvcvideo: Control 0x08000001 not found.
> >> uvcvideo: device Live! Cam Optia requested null bandwidth, defaulting to
> >> lowest.
> >
> > The problem might be in motion then.
>
> It turns out that the problem is that the Creative Live! Cam Optia can't
> drive 4.8m of cable properly (even though that's less than the spec),
> and drops/corrupts frames. Then motion is rather too intolerant of bad
> frames. With no extension lead or a hub (even bus-powered) in the line,
> the problem disappears.
>
> >> > > mplayer with -tv mjpeg
> >> >
> >> > It might still be using MJPEG, although this sounds a bit
> >> > weird.
> >>
> >> It doesn't look like it...
> >
> > And there might be a problem in mplayer as well.
>
> That seems likely. If I have time I'll report that. In the meantime, I
> reckon the JPEGCOMP support is working. Can it go into the released
> version, please?

Unfortunately, no.

According to V4L2 developers (see this thread 
http://thread.gmane.org/gmane.linux.drivers.video-input-
infrastructure/6320/focus=6425), VIDIOC_[GS]_JPEGCOMP ioctls are deprecated 
and should be replaced by controls. Nobody has had time to write a spec yet, 
so JPEG support is currently stalled.

Regards,

Laurent Pinchart



From black.sirius.pt at gmail.com  Fri Jul 24 16:41:20 2009
From: black.sirius.pt at gmail.com (Sirius Black)
Date: Fri, 24 Jul 2009 15:41:20 +0100
Subject: [Linux-uvc-devel] Report new webcam not in the list
Message-ID: <5687f9290907240741tec3678ewd6024fcb0d108ad8@mail.gmail.com>

Dear Sirs,

   I would like to report this webcam as not listed in
http://linux-uvc.berlios.de/


[root at localhost ~]# lsusb
Bus 001 Device 002: ID 0458:704c KYE Systems Corp. (Mouse Systems) Genius
i-Look 1321


[root at localhost ~]# tail -f /var/log/messages
Jul 14 14:56:08 localhost kernel: usb 1-3: new high speed USB device using
ehci_hcd and address 2
Jul 14 14:56:08 localhost kernel: usb 1-3: New USB device found,
idVendor=0458, idProduct=704c
Jul 14 14:56:08 localhost kernel: usb 1-3: New USB device strings: Mfr=0,
Product=1, SerialNumber=0
Jul 14 14:56:08 localhost kernel: usb 1-3: Product: USB20 Camera
Jul 14 14:56:08 localhost kernel: usb 1-3: configuration #1 chosen from 1
choice
Jul 14 14:56:08 localhost kernel: ALSA sound/usb/usbaudio.c:1303: 2:2:1:
cannot get freq at ep 0x84
Jul 14 14:56:08 localhost kernel: usbcore: registered new interface driver
snd-usb-audio
Jul 14 14:56:09 localhost kernel: ALSA sound/usb/usbaudio.c:1303: 2:2:1:
cannot get freq at ep 0x84
Jul 14 14:56:09 localhost kernel: ALSA sound/usb/usbaudio.c:1303: 2:2:1:
cannot get freq at ep 0x84


This is the product homepage:
http://www.geniusnet.com/geniusOnline/online.portal;jsessionid=KcLTckx0YgW2ykX7p3Rlg1JG4v2fd92bHVv1YPHXBJRJcVFPpLZH!-902102165?_nfpb=true&productPortlet_actionOverride=%2Fportlets%2FproductArea%2Fcategory%2FqueryPro&_windowLabel=productPortlet&productPortletproductId=1092061&_pageLabel=productPage&test=portlet-action<http://www.geniusnet.com/geniusOnline/online.portal;jsessionid=KcLTckx0YgW2ykX7p3Rlg1JG4v2fd92bHVv1YPHXBJRJcVFPpLZH%21-902102165?_nfpb=true&productPortlet_actionOverride=%2Fportlets%2FproductArea%2Fcategory%2FqueryPro&_windowLabel=productPortlet&productPortletproductId=1092061&_pageLabel=productPage&test=portlet-action>


Genius says this camara is Linux compatible, but when I plug in I can't use
it in Cheese, Ekiga or Pidgin.
This webcam has a 1.3 Megapixels sensor and it works fine in Windows.

I'm running Fedora 11

[root at localhost ~]# cat /proc/version
Linux version 2.6.29.5-191.fc11.i586 (
mockbuild at xenbuilder2.fedora.redhat.com) (gcc version 4.4.0 20090506 (Red
Hat 4.4.0-4) (GCC) ) #1 SMP Tue Jun 16 23:11:39 EDT 2009


Thank you

Sirius
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090724/fef3abee/attachment.html>

From laurent.pinchart at skynet.be  Fri Jul 24 16:49:31 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Fri, 24 Jul 2009 16:49:31 +0200
Subject: [Linux-uvc-devel] Report new webcam not in the list
In-Reply-To: <5687f9290907240741tec3678ewd6024fcb0d108ad8@mail.gmail.com>
References: <5687f9290907240741tec3678ewd6024fcb0d108ad8@mail.gmail.com>
Message-ID: <200907241649.31398.laurent.pinchart@skynet.be>

Hi,

On Friday 24 July 2009 16:41:20 Sirius Black wrote:
> Dear Sirs,
>
>    I would like to report this webcam as not listed in
> http://linux-uvc.berlios.de/
>
> [root at localhost ~]# lsusb
> Bus 001 Device 002: ID 0458:704c KYE Systems Corp. (Mouse Systems) Genius
> i-Look 1321

lsusb -v -d 0458:704c

please.

Regards,

Laurent Pinchart



From bardia.vivek at gmail.com  Fri Jul 24 16:42:15 2009
From: bardia.vivek at gmail.com (Vivek Bardia)
Date: Fri, 24 Jul 2009 20:12:15 +0530
Subject: [Linux-uvc-devel] Multiple streaming interface and MPEG2-TS
	support?
In-Reply-To: <200907110014.21974.laurent.pinchart@skynet.be>
References: <E54E921FAAA9494485999DFF27C90C95@vivek>
	<200907020133.50926.laurent.pinchart@skynet.be>
	<779226550907090019r64fd8d42g6f33f41eb8d7c1a3@mail.gmail.com>
	<200907110014.21974.laurent.pinchart@skynet.be>
Message-ID: <779226550907240742o728c1a90s34ad816b0213423b@mail.gmail.com>

Hi Laurent,

On Sat, Jul 11, 2009 at 3:44 AM, Laurent Pinchart
<laurent.pinchart at skynet.be> wrote:
>
> Hi Vivek,
>
> On Thursday 09 July 2009 09:19:39 Vivek Bardia wrote:
> > Hi Laurent,
> >
> > On Thu, Jul 2, 2009 at 5:03 AM, Laurent
> >
> > Pinchart<laurent.pinchart at skynet.be> wrote:
> > > Hi Vivek,
> > >
> > > On Friday 26 June 2009 10:26:07 Vivek Bardia wrote:
> > >> On Fri, Jun 26, 2009 at 1:26 AM, Laurent Pinchart wrote
> > >>
> > >> > On Monday 22 June 2009 14:23:21 Vivek Bardia wrote:
> > >> > > Hello Laurent,
> > >> > >
> > >> > > With respect to the mail chain below,
> > >> > > Would you be able to help me with regards to Multiple streaming
> > >> > > interfaces.
> > >> > >
> > >> > > Firstly how much effort could be required to bring up the UVC driver
> > >> > > to support multiple streaming interfaces and MPEG2-TS support ? In
> > >> > > case it is simple and already available, will you be able to provide
> > >> > > that patch so that I am able to test it with the hardware and get
> > >> > > back about the same ?
> > >> >
> > >> > Multiple streaming interfaces and MPEG2-TS are different requirements.
> > >> > Supporting multiple interfaces will require restructuring a good deal
> > >> > of the driver. I started working on that a week or two ago but had to
> > >> > stop for a moment (if you can send me a few hours of free time by
> > >> > e-mail I'll appreciate that). I should have some time this weekend or
> > >> > early next week to prepare a patch.
> > >>
> > >> Although I cannot send you free time by email, but can help you in
> > >> this regard in case you need help. I do not want to add more overhead
> > >> and confusion in case you are already working on it.
> > >>
> > >> > I haven't really looked into what needs to be changed for MPEG2-TS
> > >> > support. I don't expect it to be very difficult. I'll probably work on
> > >> > that over the weekend.
> > >>
> > >> Just one more thing, With regards to MPEG2-TS its just adding the
> > >> parsing support, if I am not wrong?
> > >
> > > Some changes might be required on the video streaming code as well.
> > > Streaming parameters negotiation will have to be modified too to support
> > > MPEG2-specific. parameters.
> >
> > Thank you for the quick response from your end for adding support for
> > Multiple streaming interfaces.
>
> You're welcome.
>
> > Due to some unexpected delay at my end in getting the device, I have
> > not been able to test the patch you had sent.
> >
> > Meanwhile I am trying to emulate such a device by duplicating
> > descriptors of a available normal UVC device. I will share the details
> > once I am done.
>
> Ok.
>
> > Meanwhile I am also trying to add support for MPEG2 - TS, Here are the
> > few places which I thought would require update in the UVC driver code
> >
> > a.) uvc_driver.c - Format parsing support for Stream based payloads,
> > MPEG2-TS payload
>
> That should be easy. You will have to modify the uvc_format structure to add
> MPEG2-TS specific fields (rearrange the existing fields using unions like in
> uvc_entity).
>
> As stream-based formats don't have frame descriptors, you will also have to
> walk through the driver and modify code that assumes each format has at least
> one frame descriptor. You could work around that by creating a dummy frame
> descriptor, like for the DV format, but I think it's now time to get rid of
> the "at least one frame per format" requirement.
>
I have added simple parsing support for MPEG2-TS format and works fine
with the device as of now. I have created a dummy frame for now.

> > b.) uvc_video.c - parameters negotiation, VS Interface Control
> > Selectors support.
>
> VS controls (I suppose you're talking about the "generate key frame" and
> "update frame segment" controls) should be easy to support. They might require
> new V4L2 controls though. Parameters negotiation will be handled through V4L2
> controls, so that might require a rework of the current control handling code.
>

Not Supported by the device as of now.

> > c.) video streaming code to handle MaxVideoFrameSize, BmFramingInfo ?
> > this is the part I am bit jittery about.
>
> I don't think that will be too difficult. Or maybe I don't see the difficulty
> yet :-)

With respect to the handling of dwMaxVideoFrameSize, According to the
UVC 1.1 specifications this field can be ignored if bmFramingInfo bits
is not enabled. This is for a MPG2-TS stream.

But then in this case, the device returns dwMaxVideoFrameSize,
dwMaxPayloadTransferSize to be 0.
uvc_alloc_buffers call in VIDIOC_REQBUFS ioctl and
uvc_alloc_urb_buffers call in uvc_init_video_isoc will always fail as
dwMaxVideoFrameSize will be 0.

In case I give it a hard-coded value for both, the DQBUF happens only
once and then select function blocks on the file descriptor. I am
using the V4L2 video capture example(
http://www.linuxtv.org/downloads/video4linux/API/V4L2_API/spec-single/v4l2.html
).

Could you guide us on how to proceed from this point.

>
> Best regards,
>
> Laurent Pinchart
>

Best regards,
Vivek


From bardia.vivek at gmail.com  Fri Jul 24 22:30:53 2009
From: bardia.vivek at gmail.com (Vivek Bardia)
Date: Sat, 25 Jul 2009 02:00:53 +0530
Subject: [Linux-uvc-devel] Multiple streaming interface and MPEG2-TS
	support?
In-Reply-To: <200907110014.21974.laurent.pinchart@skynet.be>
References: <E54E921FAAA9494485999DFF27C90C95@vivek>
	<200907020133.50926.laurent.pinchart@skynet.be>
	<779226550907090019r64fd8d42g6f33f41eb8d7c1a3@mail.gmail.com>
	<200907110014.21974.laurent.pinchart@skynet.be>
Message-ID: <779226550907241330w2ecde1eag42d4fd994fb6fcf7@mail.gmail.com>

Hi Laurent,

On Sat, Jul 11, 2009 at 3:44 AM, Laurent Pinchart
- Hide quoted text -
<laurent.pinchart at skynet.be> wrote:
>
> Hi Vivek,
>
> On Thursday 09 July 2009 09:19:39 Vivek Bardia wrote:
> > Hi Laurent,
> >
> > On Thu, Jul 2, 2009 at 5:03 AM, Laurent
> >
> > Pinchart<laurent.pinchart at skynet.be> wrote:
> > > Hi Vivek,
> > >
> > > On Friday 26 June 2009 10:26:07 Vivek Bardia wrote:
> > >> On Fri, Jun 26, 2009 at 1:26 AM, Laurent Pinchart wrote
> > >>
> > >> > On Monday 22 June 2009 14:23:21 Vivek Bardia wrote:
> > >> > > Hello Laurent,
> > >> > >
> > >> > > With respect to the mail chain below,
> > >> > > Would you be able to help me with regards to Multiple streaming
> > >> > > interfaces.
> > >> > >
> > >> > > Firstly how much effort could be required to bring up the UVC driver
> > >> > > to support multiple streaming interfaces and MPEG2-TS support ? In
> > >> > > case it is simple and already available, will you be able to provide
> > >> > > that patch so that I am able to test it with the hardware and get
> > >> > > back about the same ?
> > >> >
> > >> > Multiple streaming interfaces and MPEG2-TS are different requirements.
> > >> > Supporting multiple interfaces will require restructuring a good deal
> > >> > of the driver. I started working on that a week or two ago but had to
> > >> > stop for a moment (if you can send me a few hours of free time by
> > >> > e-mail I'll appreciate that). I should have some time this weekend or
> > >> > early next week to prepare a patch.
> > >>
> > >> Although I cannot send you free time by email, but can help you in
> > >> this regard in case you need help. I do not want to add more overhead
> > >> and confusion in case you are already working on it.
> > >>
> > >> > I haven't really looked into what needs to be changed for MPEG2-TS
> > >> > support. I don't expect it to be very difficult. I'll probably work on
> > >> > that over the weekend.
> > >>
> > >> Just one more thing, With regards to MPEG2-TS its just adding the
> > >> parsing support, if I am not wrong?
> > >
> > > Some changes might be required on the video streaming code as well.
> > > Streaming parameters negotiation will have to be modified too to support
> > > MPEG2-specific. parameters.
> >
> > Thank you for the quick response from your end for adding support for
> > Multiple streaming interfaces.
>
> You're welcome.
>
> > Due to some unexpected delay at my end in getting the device, I have
> > not been able to test the patch you had sent.
> >
> > Meanwhile I am trying to emulate such a device by duplicating
> > descriptors of a available normal UVC device. I will share the details
> > once I am done.
>
> Ok.
>
> > Meanwhile I am also trying to add support for MPEG2 - TS, Here are the
> > few places which I thought would require update in the UVC driver code
> >
> > a.) uvc_driver.c - Format parsing support for Stream based payloads,
> > MPEG2-TS payload
>
> That should be easy. You will have to modify the uvc_format structure to add
> MPEG2-TS specific fields (rearrange the existing fields using unions like in
> uvc_entity).
>
> As stream-based formats don't have frame descriptors, you will also have to
> walk through the driver and modify code that assumes each format has at least
> one frame descriptor. You could work around that by creating a dummy frame
> descriptor, like for the DV format, but I think it's now time to get rid of
> the "at least one frame per format" requirement.
>
I have added simple parsing support for MPEG2-TS format and works fine
with the device as of now. I have created a dummy frame for now.

> > b.) uvc_video.c - parameters negotiation, VS Interface Control
> > Selectors support.
>
> VS controls (I suppose you're talking about the "generate key frame" and
> "update frame segment" controls) should be easy to support. They might require
> new V4L2 controls though. Parameters negotiation will be handled through V4L2
> controls, so that might require a rework of the current control handling code.
>

Not Supported by the device as of now.

> > c.) video streaming code to handle MaxVideoFrameSize, BmFramingInfo ?
> > this is the part I am bit jittery about.
>
> I don't think that will be too difficult. Or maybe I don't see the difficulty
> yet :-)

With respect to the handling of dwMaxVideoFrameSize, According to the
UVC 1.1 specifications this field can be ignored if bmFramingInfo bits
is not enabled. This is for a MPG2-TS stream.

But then in this case, the device returns dwMaxVideoFrameSize,
dwMaxPayloadTransferSize to be 0.
uvc_alloc_buffers call in VIDIOC_REQBUFS ioctl and
uvc_alloc_urb_buffers call in uvc_init_video_isoc will always fail as
dwMaxVideoFrameSize will be 0.

In case I give it a hard-coded value for both, the DQBUF happens only
once and then select function blocks on the file descriptor. I am
using the V4L2 video capture example(
http://www.linuxtv.org/downloads/video4linux/API/V4L2_API/spec-single/v4l2.html
).

Could you guide us on how to proceed from this point.

>
> Best regards,
>
> Laurent Pinchart
>

Best regards,
Vivek


From eli_venter at yahoo.com  Sat Jul 25 04:25:10 2009
From: eli_venter at yahoo.com (E V)
Date: Fri, 24 Jul 2009 19:25:10 -0700 (PDT)
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <390300.69636.qm@web36906.mail.mud.yahoo.com>
Message-ID: <564638.91089.qm@web36906.mail.mud.yahoo.com>


I have the Dell SP2208WFP monitor with the built in webcam.
It works fine on my old 32-bit athlon system with a 2.6.29
kernel(gentoo), but not on my new 64-bit core2 system with
2.6.29 or 2.6.30. I just get:
 
uvcvideo: Found UVC 1.00 device Monitor Webcam (SP2208WFP) (05a9:2643)
uvcvideo: UVC non compliance - GET_DEF(PROBE) not supported. Enabling workaround.
uvcvideo: Failed to query (129) UVC probe control : -32 (exp. 26).
uvcvideo: Failed to initialize the device (-5).
 
no /dev/video at all :-(

Same deal on recent ubuntu and opensuse. Any thoughts or
pointers, could it be as simple as a struct size/alignment
issue or the 32/64-bit thing just a red herring? What should
I poke 1st...
 
Thanks,

-Eli


      


From gianluca.cecchi at gmail.com  Sat Jul 25 07:47:00 2009
From: gianluca.cecchi at gmail.com (Gianluca Cecchi)
Date: Sat, 25 Jul 2009 07:47:00 +0200
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <564638.91089.qm@web36906.mail.mud.yahoo.com>
References: <390300.69636.qm@web36906.mail.mud.yahoo.com>
	<564638.91089.qm@web36906.mail.mud.yahoo.com>
Message-ID: <561c252c0907242247w10d58e4p8d59fe7da430c57f@mail.gmail.com>

Hello,
I have the same monitor and I'm using Fedora 11 x86_64 with kernel
2.6.29.6-213.fc11.x86_64
I have the same problem since fedora 8 32bit if I remember well.
The workaround was/is to rmmod and then modprobe again the uvcvideo
kernel module.
See below for example:

first detection:
Jul 25 07:36:50 tekkaman kernel: usbcore: deregistering interface
driver uvcvideo
Jul 25 07:36:55 tekkaman kernel: uvcvideo: Found UVC 1.00 device
Monitor Webcam (SP2208WFP) (05a9:2643)
Jul 25 07:36:55 tekkaman kernel: uvcvideo: UVC non compliance -
GET_DEF(PROBE) not supported. Enabling workaround.
Jul 25 07:36:55 tekkaman kernel: uvcvideo: Failed to query (129) UVC
probe control : -32 (exp. 26).
Jul 25 07:36:55 tekkaman kernel: uvcvideo: Failed to initialize the device (-5).
Jul 25 07:36:55 tekkaman kernel: usbcore: registered new interface
driver uvcvideo
Jul 25 07:36:55 tekkaman kernel: USB Video Class driver (v0.1.0)

rmmod uvcvideo;modprobe uvcvideo
Jul 25 07:37:21 tekkaman kernel: usbcore: deregistering interface
driver uvcvideo
Jul 25 07:37:23 tekkaman kernel: uvcvideo: Found UVC 1.00 device
Monitor Webcam (SP2208WFP) (05a9:2643)
Jul 25 07:37:24 tekkaman kernel: uvcvideo: UVC non compliance -
GET_DEF(PROBE) not supported. Enabling workaround.
Jul 25 07:37:24 tekkaman kernel: input: Monitor Webcam (SP2208WFP) as
/devices/pci0000:00/0000:00:1a.7/usb1/1-2/1-2.1/1-2.1:1.0/input/input15
Jul 25 07:37:24 tekkaman kernel: usbcore: registered new interface
driver uvcvideo
Jul 25 07:37:24 tekkaman kernel: USB Video Class driver (v0.1.0)

Sometimes it is needed 2-3 times before correct loading.
I can see my webcam and the device is under /dev/video0

[root at tekkaman ~]# ll /dev/video0
crw-rw----+ 1 root video 81, 0 2009-07-25 07:37 /dev/video0

and can use it under cheese or ekiga or skype.

See thread https://lists.berlios.de/pipermail/linux-uvc-devel/2008-February/003076.html
where Laurent answered about the reasons....
HIH,
Gianluca

On Sat, Jul 25, 2009 at 4:25 AM, E V<eli_venter at yahoo.com> wrote:
>
> I have the Dell SP2208WFP monitor with the built in webcam.
> It works fine on my old 32-bit athlon system with a 2.6.29
> kernel(gentoo), but not on my new 64-bit core2 system with
> 2.6.29 or 2.6.30. I just get:
>
> uvcvideo: Found UVC 1.00 device Monitor Webcam (SP2208WFP) (05a9:2643)
> uvcvideo: UVC non compliance - GET_DEF(PROBE) not supported. Enabling workaround.
> uvcvideo: Failed to query (129) UVC probe control : -32 (exp. 26).
> uvcvideo: Failed to initialize the device (-5).
>
> no /dev/video at all :-(
>
> Same deal on recent ubuntu and opensuse. Any thoughts or
> pointers, could it be as simple as a struct size/alignment
> issue or the 32/64-bit thing just a red herring? What should
> I poke 1st...
>
> Thanks,
>
> -Eli
>
>
>
> _______________________________________________
> Linux-uvc-devel mailing list
> Linux-uvc-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
>


From laurent.pinchart at skynet.be  Sat Jul 25 11:36:22 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Sat, 25 Jul 2009 11:36:22 +0200
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <564638.91089.qm@web36906.mail.mud.yahoo.com>
References: <564638.91089.qm@web36906.mail.mud.yahoo.com>
Message-ID: <200907251136.23271.laurent.pinchart@skynet.be>

Hi Eli,

On Saturday 25 July 2009 04:25:10 E V wrote:
> I have the Dell SP2208WFP monitor with the built in webcam.
> It works fine on my old 32-bit athlon system with a 2.6.29
> kernel(gentoo), but not on my new 64-bit core2 system with
> 2.6.29 or 2.6.30. I just get:
>
> uvcvideo: Found UVC 1.00 device Monitor Webcam (SP2208WFP) (05a9:2643)
> uvcvideo: UVC non compliance - GET_DEF(PROBE) not supported. Enabling
> workaround. uvcvideo: Failed to query (129) UVC probe control : -32 (exp.
> 26). uvcvideo: Failed to initialize the device (-5).
>
> no /dev/video at all :-(
>
> Same deal on recent ubuntu and opensuse. Any thoughts or
> pointers, could it be as simple as a struct size/alignment
> issue or the 32/64-bit thing just a red herring? What should
> I poke 1st...

I doubt it's a 32/64-bit alignment issue, as I've been using (and developing 
:-)) the driver on a 64-bit machine for months now.

Could you get the latest driver version from 
http://linuxtv.org/hg/~pinchartl/uvcvideo, compile and load the module with 
quirks = 128 and tell me if it helps ?

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Sat Jul 25 13:53:34 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Sat, 25 Jul 2009 13:53:34 +0200
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <540430.93540.qm@web36902.mail.mud.yahoo.com>
References: <540430.93540.qm@web36902.mail.mud.yahoo.com>
Message-ID: <200907251353.35006.laurent.pinchart@skynet.be>

Hi Eli,

On Saturday 25 July 2009 13:46:33 E V wrote:
> ok downloaded uvcvideo-da81aafb9c5d, rmmod uvcvideo, make, make install,
> modprobe uvcvideo quirks=128. Still no dice:
>
> [  449.055320] uvcvideo 1-3.1:1.0: usb_probe_interface
> [  449.055324] uvcvideo 1-3.1:1.0: usb_probe_interface - got id
> [  449.055341] uvcvideo: Found UVC 1.00 device Monitor Webcam (SP2208WFP)
> (05a9:2643) [  449.055343] uvcvideo: Forcing device quirks 0x80 by module
> parameter for testing purpose. [  449.055345] uvcvideo: Please report
> required quirks to the linux-uvc-devel mailing list. [  449.055682]
> uvcvideo: UVC non compliance - GET_DEF(PROBE) not supported. Enabling
> workaround. [  449.055929] uvcvideo: Failed to query (129) UVC probe
> control : -32 (exp. 26). [  449.055932] uvcvideo: Failed to initialize the
> device (-5).
> [  449.055960] usbcore: registered new interface driver uvcvideo

My bad, I meant quirks=256, sorry.

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Sat Jul 25 14:02:45 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Sat, 25 Jul 2009 14:02:45 +0200
Subject: [Linux-uvc-devel] Multiple streaming interface and MPEG2-TS
	support?
In-Reply-To: <779226550907240742o728c1a90s34ad816b0213423b@mail.gmail.com>
References: <E54E921FAAA9494485999DFF27C90C95@vivek>
	<200907110014.21974.laurent.pinchart@skynet.be>
	<779226550907240742o728c1a90s34ad816b0213423b@mail.gmail.com>
Message-ID: <200907251402.45786.laurent.pinchart@skynet.be>

Hi Vivek,

On Friday 24 July 2009 16:42:15 Vivek Bardia wrote:
> On Sat, Jul 11, 2009 at 3:44 AM, Laurent Pinchart wrote:
> > On Thursday 09 July 2009 09:19:39 Vivek Bardia wrote:

[snip]

> > > Meanwhile I am also trying to add support for MPEG2 - TS, Here are the
> > > few places which I thought would require update in the UVC driver code
> > >
> > > a.) uvc_driver.c - Format parsing support for Stream based payloads,
> > > MPEG2-TS payload
> >
> > That should be easy. You will have to modify the uvc_format structure to
> > add MPEG2-TS specific fields (rearrange the existing fields using unions
> > like in uvc_entity).
> >
> > As stream-based formats don't have frame descriptors, you will also have
> > to walk through the driver and modify code that assumes each format has
> > at least one frame descriptor. You could work around that by creating a
> > dummy frame descriptor, like for the DV format, but I think it's now time
> > to get rid of the "at least one frame per format" requirement.
>
> I have added simple parsing support for MPEG2-TS format and works fine
> with the device as of now. I have created a dummy frame for now.
>
> > > b.) uvc_video.c - parameters negotiation, VS Interface Control
> > > Selectors support.
> >
> > VS controls (I suppose you're talking about the "generate key frame" and
> > "update frame segment" controls) should be easy to support. They might
> > require new V4L2 controls though. Parameters negotiation will be handled
> > through V4L2 controls, so that might require a rework of the current
> > control handling code.
>
> Not Supported by the device as of now.
>
> > > c.) video streaming code to handle MaxVideoFrameSize, BmFramingInfo ?
> > > this is the part I am bit jittery about.
> >
> > I don't think that will be too difficult. Or maybe I don't see the
> > difficulty yet :-)
>
> With respect to the handling of dwMaxVideoFrameSize, According to the
> UVC 1.1 specifications this field can be ignored if bmFramingInfo bits
> is not enabled. This is for a MPG2-TS stream.
>
> But then in this case, the device returns dwMaxVideoFrameSize,
> dwMaxPayloadTransferSize to be 0. uvc_alloc_buffers call in VIDIOC_REQBUFS
> ioctl and uvc_alloc_urb_buffers call in uvc_init_video_isoc will always fail
> as dwMaxVideoFrameSize will be 0.

Right, that's a problem. In that case the uvcvideo driver should decide on an 
appropriate buffer size. Too small buffers will result in high CPU usage, and 
too big buffers will result in higher latency before MPEG2-TS data reach 
userspace. In your experience, how could/should that buffer size be computed ?

> In case I give it a hard-coded value for both, the DQBUF happens only
> once and then select function blocks on the file descriptor. I am
> using the V4L2 video capture example(
> http://www.linuxtv.org/downloads/video4linux/API/V4L2_API/spec-single/v4l2.
>html ).
>
> Could you guide us on how to proceed from this point.

Could you please send me the output of lsusb -v for your device (using 
usbutils 0.72 or newer, 0.73+ preferred) and send me a patch for the MPEG2-TS 
descriptors parsing ? I will then review the patch and have a look at what the 
next step should be.

Best regards,

Laurent Pinchart



From eli_venter at yahoo.com  Sat Jul 25 16:29:40 2009
From: eli_venter at yahoo.com (E V)
Date: Sat, 25 Jul 2009 07:29:40 -0700 (PDT)
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <200907251353.35006.laurent.pinchart@skynet.be>
Message-ID: <916710.27798.qm@web36905.mail.mud.yahoo.com>


quirks=256 doesn't work either:

[10410.179890] uvcvideo 1-3.1:1.0: usb_probe_interface
[10410.179894] uvcvideo 1-3.1:1.0: usb_probe_interface - got id
[10410.179911] uvcvideo: Found UVC 1.00 device Monitor Webcam (SP2208WFP) (05a9:2643)
[10410.179914] uvcvideo: Forcing device quirks 0x100 by module parameter for testing purpose.
[10410.179916] uvcvideo: Please report required quirks to the linux-uvc-devel mailing list.
[10411.181078] usb 1-3.1: modprobe timed out on ep0in len=0/26
[10411.181083] uvcvideo: Failed to query (129) UVC probe control : -110 (exp. 26).
[10411.181086] uvcvideo: Failed to initialize the device (-5).
[10411.181132] usbcore: registered new interface driver uvcvideo
[10411.181135] USB Video Class driver (v0.1.0)



--- On Sat, 7/25/09, Laurent Pinchart <laurent.pinchart at skynet.be> wrote:

> From: Laurent Pinchart <laurent.pinchart at skynet.be>
> Subject: Re: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
> To: "E V" <eli_venter at yahoo.com>
> Cc: linux-uvc-devel at lists.berlios.de
> Date: Saturday, July 25, 2009, 7:53 AM
> Hi Eli,
> 
> On Saturday 25 July 2009 13:46:33 E V wrote:
> > ok downloaded uvcvideo-da81aafb9c5d, rmmod uvcvideo,
> make, make install,
> > modprobe uvcvideo quirks=128. Still no dice:
> >
> > [? 449.055320] uvcvideo 1-3.1:1.0:
> usb_probe_interface
> > [? 449.055324] uvcvideo 1-3.1:1.0:
> usb_probe_interface - got id
> > [? 449.055341] uvcvideo: Found UVC 1.00 device
> Monitor Webcam (SP2208WFP)
> > (05a9:2643) [? 449.055343] uvcvideo: Forcing
> device quirks 0x80 by module
> > parameter for testing purpose. [? 449.055345]
> uvcvideo: Please report
> > required quirks to the linux-uvc-devel mailing list.
> [? 449.055682]
> > uvcvideo: UVC non compliance - GET_DEF(PROBE) not
> supported. Enabling
> > workaround. [? 449.055929] uvcvideo: Failed to
> query (129) UVC probe
> > control : -32 (exp. 26). [? 449.055932] uvcvideo:
> Failed to initialize the
> > device (-5).
> > [? 449.055960] usbcore: registered new interface
> driver uvcvideo
> 
> My bad, I meant quirks=256, sorry.
> 
> Best regards,
> 
> Laurent Pinchart
> 
> 


      


From mannemerak at gmail.com  Mon Jul 27 13:33:43 2009
From: mannemerak at gmail.com (Manne Merak)
Date: Mon, 27 Jul 2009 13:33:43 +0200
Subject: [Linux-uvc-devel] Cheap Pixart 1.3M cam
Message-ID: <4A6D9097.4030603@gmail.com>

Hi, thanks for a great driver set.
I have a cheap UVC compatible webcam that works at 640x480 (093a:2700)
It seems to be a Pixart and looking at the imaging chip and some 
datasheets it seems to be a 1.3M pixel device (PAS5101CS).
Now how do I get it to stream at 1280x1024?  I tried passing the 
resolution with mplayer, but it always just defaults to 640x480.

Manne
(ps I have the same issue with my builtin Dell laptop webcam 2Mp, but 
only streams at VGA, 05a9:2640)


From laurent.pinchart at skynet.be  Mon Jul 27 13:42:27 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Mon, 27 Jul 2009 13:42:27 +0200
Subject: [Linux-uvc-devel] Cheap Pixart 1.3M cam
In-Reply-To: <4A6D9097.4030603@gmail.com>
References: <4A6D9097.4030603@gmail.com>
Message-ID: <200907271342.28270.laurent.pinchart@skynet.be>

Hi Manne,

On Monday 27 July 2009 13:33:43 Manne Merak wrote:
> Hi, thanks for a great driver set.
> I have a cheap UVC compatible webcam that works at 640x480 (093a:2700)
> It seems to be a Pixart and looking at the imaging chip and some
> datasheets it seems to be a 1.3M pixel device (PAS5101CS).
> Now how do I get it to stream at 1280x1024?  I tried passing the
> resolution with mplayer, but it always just defaults to 640x480.

Could you please send me the output of

lsusb -v -d 093a:2700

using usbutils 0.72 or newer (0.73+ preferred) ?

> (ps I have the same issue with my builtin Dell laptop webcam 2Mp, but
> only streams at VGA, 05a9:2640)

That camera is limited to 640x480 in uncompressed (YUYV) mode. Try to use 
MJPEG instead, you should be able to reach 1600x1200 @10fps.

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Mon Jul 27 16:34:19 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Mon, 27 Jul 2009 16:34:19 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <20090723052040.GA3608@bitwizard.nl>
References: <20090722113406.GF1662@bitwizard.nl>
	<200907221357.39763.laurent.pinchart@skynet.be>
	<20090723052040.GA3608@bitwizard.nl>
Message-ID: <200907271634.19269.laurent.pinchart@skynet.be>

Hi Rogier,

On Thursday 23 July 2009 07:20:41 Rogier Wolff wrote:
> On Wed, Jul 22, 2009 at 01:57:39PM +0200, Laurent Pinchart wrote:
> > On Wednesday 22 July 2009 13:34:06 Rogier Wolff wrote:
> > > Anyway, wxcam sees a 640x480 image, but every other program that
> > > I've been trying gives errors:
> > > gqcam
> > > lucview
> > > xine
> > > codeine
> > > mplayer
> > >
> > > gqcam is the most "informative": It shows:
> > >   Error reading image...
> > > at a rate similar to the refresh rate.
> >
> > Does the driver print any error message to the kernel log ?
>
> No.
>
> > What error messages does luvcview print ?
>
> None.
>
> This is the "per frame" list of system calles.
>
> fd 3 = link to X server
> fd 4 = ??
> fd 5 = /dev/video0

[snip]

Nothing helpful in there.

Could you load the driver with trace=255 and have a look at the kernel log ? 
It might get pretty verbose.

Best regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Mon Jul 27 16:37:19 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Mon, 27 Jul 2009 16:37:19 +0200
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <916710.27798.qm@web36905.mail.mud.yahoo.com>
References: <916710.27798.qm@web36905.mail.mud.yahoo.com>
Message-ID: <200907271637.19779.laurent.pinchart@skynet.be>

Hi Eli,

On Saturday 25 July 2009 16:29:40 E V wrote:
> quirks=256 doesn't work either:
>
> [10410.179890] uvcvideo 1-3.1:1.0: usb_probe_interface
> [10410.179894] uvcvideo 1-3.1:1.0: usb_probe_interface - got id
> [10410.179911] uvcvideo: Found UVC 1.00 device Monitor Webcam (SP2208WFP)
> (05a9:2643) [10410.179914] uvcvideo: Forcing device quirks 0x100 by module
> parameter for testing purpose. [10410.179916] uvcvideo: Please report
> required quirks to the linux-uvc-devel mailing list. [10411.181078] usb
> 1-3.1: modprobe timed out on ep0in len=0/26
> [10411.181083] uvcvideo: Failed to query (129) UVC probe control : -110
> (exp. 26). [10411.181086] uvcvideo: Failed to initialize the device (-5).
> [10411.181132] usbcore: registered new interface driver uvcvideo
> [10411.181135] USB Video Class driver (v0.1.0)

Then I guess you're out of luck, sorry :-S That's a pretty buggy camera, and 
it seems to be quite sensitive to timings.

Best regards,

Laurent Pinchart



From R.E.Wolff at BitWizard.nl  Mon Jul 27 16:45:32 2009
From: R.E.Wolff at BitWizard.nl (Rogier Wolff)
Date: Mon, 27 Jul 2009 16:45:32 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <200907271634.19269.laurent.pinchart@skynet.be>
References: <20090722113406.GF1662@bitwizard.nl>
	<200907221357.39763.laurent.pinchart@skynet.be>
	<20090723052040.GA3608@bitwizard.nl>
	<200907271634.19269.laurent.pinchart@skynet.be>
Message-ID: <20090727144532.GB4272@bitwizard.nl>

On Mon, Jul 27, 2009 at 04:34:19PM +0200, Laurent Pinchart wrote:
> Could you load the driver with trace=255 and have a look at the kernel log ? 
> It might get pretty verbose.

I can. 

Here is the log of the insmod. I'm not at the machine right now, so I
can't expect the "live video" over the internet to work to my display
here at work.

	Roger. 

---------------------
[61208.931496] uvcvideo: Adding mapping Brightness to control 00000000-0000-0000-0000-000000000101/2.
[61208.931500] uvcvideo: Adding mapping Contrast to control 00000000-0000-0000-0000-000000000101/3.
[61208.931502] uvcvideo: Adding mapping Hue to control 00000000-0000-0000-0000-000000000101/6.
[61208.931504] uvcvideo: Adding mapping Saturation to control 00000000-0000-0000-0000-000000000101/7.
[61208.931507] uvcvideo: Adding mapping Sharpness to control 00000000-0000-0000-0000-000000000101/8.
[61208.931509] uvcvideo: Adding mapping Gamma to control 00000000-0000-0000-0000-000000000101/9.
[61208.931511] uvcvideo: Adding mapping Backlight Compensation to control 00000000-0000-0000-0000-000000000101/1.
[61208.931514] uvcvideo: Adding mapping Gain to control 00000000-0000-0000-0000-000000000101/4.
[61208.931516] uvcvideo: Adding mapping Power Line Frequency to control 00000000-0000-0000-0000-000000000101/5.
[61208.931519] uvcvideo: Adding mapping Hue, Auto to control 00000000-0000-0000-0000-000000000101/16.
[61208.931522] uvcvideo: Adding mapping Exposure, Auto to control 00000000-0000-0000-0000-000000000001/2.
[61208.931525] uvcvideo: Adding mapping Exposure, Auto Priority to control 00000000-0000-0000-0000-000000000001/3.
[61208.931528] uvcvideo: Adding mapping Exposure (Absolute) to control 00000000-0000-0000-0000-000000000001/4.
[61208.931531] uvcvideo: Adding mapping White Balance Temperature, Auto to control 00000000-0000-0000-0000-000000000101/11.
[61208.931534] uvcvideo: Adding mapping White Balance Temperature to control 00000000-0000-0000-0000-000000000101/10.
[61208.931537] uvcvideo: Adding mapping White Balance Component, Auto to control 00000000-0000-0000-0000-000000000101/13.
[61208.931539] uvcvideo: Adding mapping White Balance Blue Component to control 00000000-0000-0000-0000-000000000101/12.
[61208.931542] uvcvideo: Adding mapping White Balance Red Component to control 00000000-0000-0000-0000-000000000101/12.
[61208.931545] uvcvideo: Adding mapping Focus (absolute) to control 00000000-0000-0000-0000-000000000001/6.
[61208.931548] uvcvideo: Adding mapping Focus, Auto to control 00000000-0000-0000-0000-000000000001/8.
[61208.931575] uvcvideo: Probing generic UVC device 2
[61208.931581] uvcvideo: Found format MJPEG.
[61208.931583] uvcvideo: - 320x240 (30.0 fps)
[61208.931584] uvcvideo: - 160x120 (30.0 fps)
[61208.931585] uvcvideo: - 176x144 (30.0 fps)
[61208.931586] uvcvideo: - 352x288 (30.0 fps)
[61208.931588] uvcvideo: - 640x480 (30.0 fps)
[61208.931590] uvcvideo: Found a Status endpoint (addr 81).
[61208.931592] uvcvideo: Found UVC 1.00 device USB 2.0 PC Camera (058f:3820)
[61208.931595] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/2 to device 2 entity 2
[61208.931597] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/3 to device 2 entity 2
[61208.931600] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/6 to device 2 entity 2
[61208.931603] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/7 to device 2 entity 2
[61208.931605] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/8 to device 2 entity 2
[61208.931608] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/9 to device 2 entity 2
[61208.931610] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/10 to device 2 entity 2
[61208.931613] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/1 to device 2 entity 2
[61208.931616] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/5 to device 2 entity 2
[61208.931618] uvcvideo: Added control 00000000-0000-0000-0000-000000000101/11 to device 2 entity 2
[61208.931623] uvcvideo: Scanning UVC chain: OT 3 <- PU 2 (-> XU 6) <- IT 1
[61208.931627] uvcvideo: Found a valid video chain (1 -> 3).
[61208.937972] input: USB 2.0 PC Camera as /devices/pci0000:00/0000:00:1d.2/usb8/8-2/8-2:1.0/input/input7
[61208.948592] uvcvideo: UVC device initialized.
[61208.948610] usbcore: registered new interface driver uvcvideo
[61208.948612] USB Video Class driver (v0.1.0)
[61209.032648] uvcvideo: uvc_v4l2_open
[61209.032655] uvcvideo: uvc_v4l2_ioctl
[61209.032657] VIDIOC_QUERYCAP<7>uvcvideo: uvc_v4l2_release


-- 
** R.E.Wolff at BitWizard.nl ** http://www.BitWizard.nl/ ** +31-15-2600998 **
**    Delftechpark 26 2628 XH  Delft, The Netherlands. KVK: 27239233    **
*-- BitWizard writes Linux device drivers for any device you may have! --*
Q: It doesn't work. A: Look buddy, doesn't work is an ambiguous statement. 
Does it sit on the couch all day? Is it unemployed? Please be specific! 
Define 'it' and what it isn't doing. --------- Adapted from lxrbot FAQ


From laurent.pinchart at skynet.be  Mon Jul 27 16:49:14 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Mon, 27 Jul 2009 16:49:14 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <20090727144532.GB4272@bitwizard.nl>
References: <20090722113406.GF1662@bitwizard.nl>
	<200907271634.19269.laurent.pinchart@skynet.be>
	<20090727144532.GB4272@bitwizard.nl>
Message-ID: <200907271649.15002.laurent.pinchart@skynet.be>

On Monday 27 July 2009 16:45:32 Rogier Wolff wrote:
> On Mon, Jul 27, 2009 at 04:34:19PM +0200, Laurent Pinchart wrote:
> > Could you load the driver with trace=255 and have a look at the kernel
> > log ? It might get pretty verbose.
>
> I can.
>
> Here is the log of the insmod. I'm not at the machine right now, so I
> can't expect the "live video" over the internet to work to my display
> here at work.

It's the "live video" log that I'm interested in :-) Please send it when 
you'll have physical access to your machine.

Best regards,

Laurent Pinchart



From gianluca.cecchi at gmail.com  Mon Jul 27 17:03:44 2009
From: gianluca.cecchi at gmail.com (Gianluca Cecchi)
Date: Mon, 27 Jul 2009 17:03:44 +0200
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <200907271637.19779.laurent.pinchart@skynet.be>
References: <916710.27798.qm@web36905.mail.mud.yahoo.com>
	<200907271637.19779.laurent.pinchart@skynet.be>
Message-ID: <561c252c0907270803q7f832aaavc1140089366114c4@mail.gmail.com>

On Mon, Jul 27, 2009 at 4:37 PM, Laurent
Pinchart<laurent.pinchart at skynet.be> wrote:
> Hi Eli,
>
> On Saturday 25 July 2009 16:29:40 E V wrote:
>> quirks=256 doesn't work either:
>>
>> [10410.179890] uvcvideo 1-3.1:1.0: usb_probe_interface
>> [10410.179894] uvcvideo 1-3.1:1.0: usb_probe_interface - got id
>> [10410.179911] uvcvideo: Found UVC 1.00 device Monitor Webcam (SP2208WFP)
>> (05a9:2643) [10410.179914] uvcvideo: Forcing device quirks 0x100 by module
>> parameter for testing purpose. [10410.179916] uvcvideo: Please report
>> required quirks to the linux-uvc-devel mailing list. [10411.181078] usb
>> 1-3.1: modprobe timed out on ep0in len=0/26
>> [10411.181083] uvcvideo: Failed to query (129) UVC probe control : -110
>> (exp. 26). [10411.181086] uvcvideo: Failed to initialize the device (-5).
>> [10411.181132] usbcore: registered new interface driver uvcvideo
>> [10411.181135] USB Video Class driver (v0.1.0)
>
> Then I guess you're out of luck, sorry :-S That's a pretty buggy camera, and
> it seems to be quite sensitive to timings.
>
> Best regards,
>
> Laurent Pinchart
>
> _______________________________________________
> Linux-uvc-devel mailing list
> Linux-uvc-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/linux-uvc-devel
>

Did you try to unload/load the kernel module to see if  after 2-3
attempts you are able to get it correctly loaded, as I suggested in
previous answer?
In case, you could write a sort of wrapper that queries along
/var/log/messages and continues to try until it reaches a number of
attempts.
In my case at maximum at third attempt I can get it correctly loaded
and usable by applications.

Gianluca


From eli_venter at yahoo.com  Mon Jul 27 17:40:08 2009
From: eli_venter at yahoo.com (E V)
Date: Mon, 27 Jul 2009 08:40:08 -0700 (PDT)
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <561c252c0907270803q7f832aaavc1140089366114c4@mail.gmail.com>
Message-ID: <579486.85225.qm@web36903.mail.mud.yahoo.com>


Well, I did load it a few times with different quirks settings and none worked. Didn't try just loading and unloading one after the other. I'll try that tonight.

Thanks,

-Eli 

--- On Mon, 7/27/09, Gianluca Cecchi <gianluca.cecchi at gmail.com> wrote:
> 
> Did you try to unload/load the kernel module to see
> if? after 2-3
> attempts you are able to get it correctly loaded, as I
> suggested in
> previous answer?
> In case, you could write a sort of wrapper that queries
> along
> /var/log/messages and continues to try until it reaches a
> number of
> attempts.
> In my case at maximum at third attempt I can get it
> correctly loaded
> and usable by applications.
> 
> Gianluca
> 


      


From eli_venter at yahoo.com  Mon Jul 27 17:46:20 2009
From: eli_venter at yahoo.com (E V)
Date: Mon, 27 Jul 2009 08:46:20 -0700 (PDT)
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <200907271637.19779.laurent.pinchart@skynet.be>
Message-ID: <334863.88256.qm@web36903.mail.mud.yahoo.com>


If it's a timing issue, do you think it would be feasible to record what/when things happen on my old athlon system that works and replicate it on my new core2 system?

-Eli

--- On Mon, 7/27/09, Laurent Pinchart <laurent.pinchart at skynet.be> wrote:

> From: Laurent Pinchart <laurent.pinchart at skynet.be>
> Subject: Re: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
> To: linux-uvc-devel at lists.berlios.de
> Cc: "E V" <eli_venter at yahoo.com>
> Date: Monday, July 27, 2009, 10:37 AM
> Hi Eli,
> 
> On Saturday 25 July 2009 16:29:40 E V wrote:
> > quirks=256 doesn't work either:
> >
> > [10410.179890] uvcvideo 1-3.1:1.0:
> usb_probe_interface
> > [10410.179894] uvcvideo 1-3.1:1.0: usb_probe_interface
> - got id
> > [10410.179911] uvcvideo: Found UVC 1.00 device Monitor
> Webcam (SP2208WFP)
> > (05a9:2643) [10410.179914] uvcvideo: Forcing device
> quirks 0x100 by module
> > parameter for testing purpose. [10410.179916]
> uvcvideo: Please report
> > required quirks to the linux-uvc-devel mailing list.
> [10411.181078] usb
> > 1-3.1: modprobe timed out on ep0in len=0/26
> > [10411.181083] uvcvideo: Failed to query (129) UVC
> probe control : -110
> > (exp. 26). [10411.181086] uvcvideo: Failed to
> initialize the device (-5).
> > [10411.181132] usbcore: registered new interface
> driver uvcvideo
> > [10411.181135] USB Video Class driver (v0.1.0)
> 
> Then I guess you're out of luck, sorry :-S That's a pretty
> buggy camera, and 
> it seems to be quite sensitive to timings.
> 
> Best regards,
> 
> Laurent Pinchart
> 
> 


      


From R.E.Wolff at BitWizard.nl  Tue Jul 28 07:43:41 2009
From: R.E.Wolff at BitWizard.nl (Rogier Wolff)
Date: Tue, 28 Jul 2009 07:43:41 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <200907271649.15002.laurent.pinchart@skynet.be>
References: <20090722113406.GF1662@bitwizard.nl>
	<200907271634.19269.laurent.pinchart@skynet.be>
	<20090727144532.GB4272@bitwizard.nl>
	<200907271649.15002.laurent.pinchart@skynet.be>
Message-ID: <20090728054341.GA20080@bitwizard.nl>

On Mon, Jul 27, 2009 at 04:49:14PM +0200, Laurent Pinchart wrote:
> On Monday 27 July 2009 16:45:32 Rogier Wolff wrote:
> > On Mon, Jul 27, 2009 at 04:34:19PM +0200, Laurent Pinchart wrote:
> > > Could you load the driver with trace=255 and have a look at the kernel
> > > log ? It might get pretty verbose.
> >
> > I can.
> >
> > Here is the log of the insmod. I'm not at the machine right now, so I
> > can't expect the "live video" over the internet to work to my display
> > here at work.
> 
> It's the "live video" log that I'm interested in :-) Please send it when 
> you'll have physical access to your machine.

Here is the rest: 

<7>[52260.329939] uvcvideo: uvc_v4l2_open
<7>[52260.329945] uvcvideo: uvc_v4l2_ioctl
<4>[52260.329947] VIDIOC_QUERYCAP<7>uvcvideo: uvc_v4l2_ioctl
<4>[52260.329987] VIDIOC_ENUM_FMT<7>uvcvideo: uvc_v4l2_ioctl
<4>[52260.329989] VIDIOC_ENUM_FMT<7>uvcvideo: uvc_v4l2_ioctl
<4>[52260.330096] VIDIOC_S_FMT<7>uvcvideo: Trying format 0x47504a4d (MJPG): 640x
480.
<7>[52260.330100] uvcvideo: Using default frame interval 33333.3 us (30.0 fps).
<7>[52260.335681] uvcvideo: uvc_v4l2_ioctl
<4>[52260.335683] VIDIOC_S_PARM<7>uvcvideo: Setting frame interval to 1/30 (3333
33).
<7>[52260.340611] uvcvideo: uvc_v4l2_ioctl
<4>[52260.340613] VIDIOC_G_PARM<7>uvcvideo: uvc_v4l2_ioctl
<4>[52260.340679] VIDIOC_REQBUFS<7>uvcvideo: uvc_v4l2_ioctl
<4>[52260.340942] VIDIOC_QUERYBUF<7>uvcvideo: uvc_v4l2_mmap
<7>[52260.341024] uvcvideo: uvc_v4l2_ioctl
<4>[52260.341025] VIDIOC_QUERYBUF<7>uvcvideo: uvc_v4l2_mmap
<7>[52260.341106] uvcvideo: uvc_v4l2_ioctl
<4>[52260.341107] VIDIOC_QUERYBUF<7>uvcvideo: uvc_v4l2_mmap
<7>[52260.341189] uvcvideo: uvc_v4l2_ioctl
<4>[52260.341190] VIDIOC_QUERYBUF<7>uvcvideo: uvc_v4l2_mmap
<7>[52260.341270] uvcvideo: uvc_v4l2_ioctl
<4>[52260.341271] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 0.
<7>[52260.341274] uvcvideo: uvc_v4l2_ioctl
<4>[52260.341275] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 1.
<7>[52260.341277] uvcvideo: uvc_v4l2_ioctl
<4>[52260.341278] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 2.
<7>[52260.341280] uvcvideo: uvc_v4l2_ioctl
<4>[52260.341281] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 3.
<7>[52260.448517] uvcvideo: uvc_v4l2_ioctl
<4>[52260.448521] VIDIOC_STREAMON<7>uvcvideo: uvc_v4l2_ioctl
<4>[52260.451712] VIDIOC_DQBUF<7>uvcvideo: Dropping payload (error bit set).
<7>[52260.941626] uvcvideo: Dropping payload (error bit set).
<7>[52260.941628] uvcvideo: Dropping payload (error bit set).
<7>[52260.941630] uvcvideo: Dropping payload (error bit set).
<7>[52260.941631] uvcvideo: Dropping payload (error bit set).
<7>[52260.941632] uvcvideo: Dropping payload (error bit set).
<7>[52260.941633] uvcvideo: Dropping payload (error bit set).
<7>[52260.941634] uvcvideo: Dropping payload (error bit set).
<7>[52260.941636] uvcvideo: Dropping payload (error bit set).
<7>[52260.941637] uvcvideo: Dropping payload (error bit set).
<7>[52260.941638] uvcvideo: Dropping payload (error bit set).
<7>[52260.941639] uvcvideo: Dropping payload (error bit set).
<7>[52260.941641] uvcvideo: Dropping payload (error bit set).
<7>[52260.941642] uvcvideo: Dropping payload (error bit set).
<7>[52260.941643] uvcvideo: Dropping payload (error bit set).
<7>[52260.941644] uvcvideo: Dropping payload (error bit set).
<7>[52260.941645] uvcvideo: Dropping payload (error bit set).
<7>[52260.941647] uvcvideo: Dropping payload (error bit set).
<7>[52260.941648] uvcvideo: Dropping payload (error bit set).
<7>[52260.941649] uvcvideo: Dropping payload (error bit set).
<7>[52260.941650] uvcvideo: Dropping payload (error bit set).
<7>[52260.941651] uvcvideo: Dropping payload (error bit set).
<7>[52260.941653] uvcvideo: Dropping payload (error bit set).
<7>[52260.981622] uvcvideo: Dropping payload (error bit set).
<7>[52260.981624] uvcvideo: Dropping payload (error bit set).
<7>[52260.981625] uvcvideo: Dropping payload (error bit set).
<7>[52260.981627] uvcvideo: Dropping payload (error bit set).
<7>[52260.981628] uvcvideo: Dropping payload (error bit set).
<7>[52260.981629] uvcvideo: Dropping payload (error bit set).
<7>[52260.981630] uvcvideo: Dropping payload (error bit set).
<7>[52260.981632] uvcvideo: Dropping payload (error bit set).
<7>[52260.981633] uvcvideo: Dropping payload (error bit set).
<7>[52260.981634] uvcvideo: Dropping payload (error bit set).
<7>[52260.981635] uvcvideo: Dropping payload (error bit set).
<7>[52260.981637] uvcvideo: Dropping payload (error bit set).
<7>[52260.981638] uvcvideo: Dropping payload (error bit set).
<7>[52260.981639] uvcvideo: Dropping payload (error bit set).
<7>[52260.981640] uvcvideo: Dropping payload (error bit set).
<7>[52261.101630] uvcvideo: Frame complete (EOF found).
<7>[52261.101641] uvcvideo: Dequeuing buffer 0 (3, 22930 bytes).
<7>[52261.101702] uvcvideo: uvc_v4l2_ioctl
<4>[52261.101705] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 0.
<7>[52261.127126] uvcvideo: uvc_v4l2_ioctl
<4>[52261.127131] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
<7>[52261.221642] uvcvideo: Dequeuing buffer 1 (3, 22682 bytes).
<7>[52261.221688] uvcvideo: uvc_v4l2_ioctl
<4>[52261.221689] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 1.
<7>[52261.234064] uvcvideo: uvc_v4l2_ioctl
<4>[52261.234069] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
<7>[52261.341653] uvcvideo: Dequeuing buffer 2 (3, 25734 bytes).
<7>[52261.341711] uvcvideo: uvc_v4l2_ioctl
<4>[52261.341714] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 2.
<7>[52261.354175] uvcvideo: uvc_v4l2_ioctl
<4>[52261.354181] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
<7>[52261.461651] uvcvideo: Dequeuing buffer 3 (3, 25702 bytes).
<7>[52261.461702] uvcvideo: uvc_v4l2_ioctl
<4>[52261.461704] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 3.
<7>[52261.474363] uvcvideo: uvc_v4l2_ioctl
<4>[52261.474368] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
<7>[52261.581655] uvcvideo: Dequeuing buffer 0 (3, 27500 bytes).
<7>[52261.581705] uvcvideo: uvc_v4l2_ioctl
<4>[52261.581707] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 0.
<7>[52261.594133] uvcvideo: uvc_v4l2_ioctl
<4>[52261.594139] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
<7>[52261.701659] uvcvideo: Dequeuing buffer 1 (3, 27352 bytes).
<7>[52261.701709] uvcvideo: uvc_v4l2_ioctl
...
[ and this repeats. ]
...
<4>[52270.667558] VIDIOC_STREAMOFF<7>uvcvideo: uvc_v4l2_release

What I don't understand is the 120ms interval between the buffers
getting queued. I had expected 30ms intervals....

	Roger. 

-- 
** R.E.Wolff at BitWizard.nl ** http://www.BitWizard.nl/ ** +31-15-2600998 **
**    Delftechpark 26 2628 XH  Delft, The Netherlands. KVK: 27239233    **
*-- BitWizard writes Linux device drivers for any device you may have! --*
Q: It doesn't work. A: Look buddy, doesn't work is an ambiguous statement. 
Does it sit on the couch all day? Is it unemployed? Please be specific! 
Define 'it' and what it isn't doing. --------- Adapted from lxrbot FAQ


From acimmarusti at gmail.com  Thu Jul 30 18:54:03 2009
From: acimmarusti at gmail.com (Andres Cimmarusti)
Date: Thu, 30 Jul 2009 12:54:03 -0400
Subject: [Linux-uvc-devel] newest creative live cam notebook ultra doesn't
	work
Message-ID: <e194349c0907300954m5a0064d1ubc929d2078086171@mail.gmail.com>

Hi,

I just want to say that I just bought a Creative Live! Cam Notebook Ultra
(because it was fully supported according to your website). Unfortunately,
the device doesn't work at all and the Device ID does not match the one you
have in the website (perhaps the one I bought is the most recent model).
Here is the information I could find in /var/log/

uvcvideo: Failed to query (1) UVC control 1 (unit 0) : -110 (exp. 26).
uvcvideo: Found UVC 1.00 device VF0490 Live Cam Notebook Ultra (041e:4072)

While the webcam usually fails to load, sometimes it is loaded properly and
using luvcview makes it work. However, 80% of the time this is not so
causing this error:

Unable to set format: Input/output error
 Init v4L2 failed !! exit fatal

When the device is actually loaded to /dev/video0 properly and it works
under luvcview and skype, usb audio doesn't work at all. The modules are
loaded, but if I try:

alsamixer -c 2
alsamixer: function snd_mixer_load failed: Invalid argument

In fact when double clicking on the sound applet in the gnome panel, if I
try to select other devices, the usb microphone is not listed at all. This
is very strange since I get the following output from the commands:

cat /proc/asound/cards
 0 [IXP            ]: ATIIXP - ATI IXP
                      ATI IXP rev 2 with unknown codec at 0xc0003400, irq 17
 1 [Modem          ]: ATIIXP-MODEM - ATI IXP Modem
                      ATI IXP Modem rev 2 at 0xc0003800, irq 17
 2 [Ultra          ]: USB-Audio - VF0490 Live Cam Notebook Ultra
                      Creative Technology Ltd VF0490 Live Cam Notebook Ultra
at usb-0000:00:13.2-1, h

arecord -l
**** List of CAPTURE Hardware Devices ****
card 0: IXP [ATI IXP], device 0: ATI IXP AC97 [ATI IXP AC97]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: Modem [ATI IXP Modem], device 0: ATI IXP MC97 [ATI IXP MC97]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 2: Ultra [VF0490 Live Cam Notebook Ultra], device 0: USB Audio [USB
Audio]
  Subdevices: 1/1
  Subdevice #0: subdevice #0

lsmod | grep snd_usb
snd_usb_audio          87584  0
snd_usb_lib            15872  1 snd_usb_audio
snd_rawmidi            22944  2 snd_usb_lib,snd_seq_midi
snd_hwdep               7880  1 snd_usb_audio
snd_pcm                75788  6
snd_usb_audio,snd_atiixp,snd_atiixp_modem,snd_ac97_codec
snd                    58936  16
snd_usb_audio,snd_rawmidi,snd_hwdep,snd_atiixp,snd_atiixp_modem,snd_ac97_codec,snd_pcm,snd_seq,snd_timer,snd_seq_device

I believe the previous model (which is the one probably listed on the
website) is the VF0310. I will now return the product for a refund.

I'm running Debian Lenny 5.0.2 amd64 gnome with a custom built kernel:
2.6.27.28

I have another UVC webcam device (logitech quickcam pro for notebooks (2007
model)) which works perfectly under the same circumstances.

I hope you will update the information in your website, thanks


Best regards,

Andres Cimmarusti
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090730/6b2e8329/attachment.html>

From laurent.pinchart at skynet.be  Fri Jul 31 14:51:45 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Fri, 31 Jul 2009 14:51:45 +0200
Subject: [Linux-uvc-devel] Webcam(05a9:2643) not working on 64-bit kernel
In-Reply-To: <334863.88256.qm@web36903.mail.mud.yahoo.com>
References: <334863.88256.qm@web36903.mail.mud.yahoo.com>
Message-ID: <200907311451.45699.laurent.pinchart@skynet.be>

Hi Eli,

On Monday 27 July 2009 17:46:20 E V wrote:
> If it's a timing issue, do you think it would be feasible to record
> what/when things happen on my old athlon system that works and replicate it
> on my new core2 system?

I don't think so, sorry. Most of those timing issues are caused by subtle 
differences in timing between USB packets, which are scheduled by the hardware 
USB controller and not directly controlled of the Linux kernel.

Of course you are free to hack and try to find a solution :-)

Regards,

Laurent Pinchart



From laurent.pinchart at skynet.be  Fri Jul 31 15:01:11 2009
From: laurent.pinchart at skynet.be (Laurent Pinchart)
Date: Fri, 31 Jul 2009 15:01:11 +0200
Subject: [Linux-uvc-devel] 058f:3820 webcam.
In-Reply-To: <20090728054341.GA20080@bitwizard.nl>
References: <20090722113406.GF1662@bitwizard.nl>
	<200907271649.15002.laurent.pinchart@skynet.be>
	<20090728054341.GA20080@bitwizard.nl>
Message-ID: <200907311501.11520.laurent.pinchart@skynet.be>

On Tuesday 28 July 2009 07:43:41 Rogier Wolff wrote:
> On Mon, Jul 27, 2009 at 04:49:14PM +0200, Laurent Pinchart wrote:
> > On Monday 27 July 2009 16:45:32 Rogier Wolff wrote:
> > > On Mon, Jul 27, 2009 at 04:34:19PM +0200, Laurent Pinchart wrote:
> > > > Could you load the driver with trace=255 and have a look at the
> > > > kernel log ? It might get pretty verbose.
> > >
> > > I can.
> > >
> > > Here is the log of the insmod. I'm not at the machine right now, so I
> > > can't expect the "live video" over the internet to work to my display
> > > here at work.
> >
> > It's the "live video" log that I'm interested in :-) Please send it when
> > you'll have physical access to your machine.
>
> Here is the rest:
>

[snip]
> <4>[52260.448521] VIDIOC_STREAMON<7>uvcvideo: uvc_v4l2_ioctl
> <4>[52260.451712] VIDIOC_DQBUF<7>uvcvideo: Dropping payload (error bit set).
> <7>[52260.941626] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941628] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941630] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941631] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941632] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941633] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941634] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941636] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941637] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941638] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941639] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941641] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941642] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941643] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941644] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941645] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941647] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941648] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941649] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941650] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941651] uvcvideo: Dropping payload (error bit set).
> <7>[52260.941653] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981622] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981624] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981625] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981627] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981628] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981629] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981630] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981632] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981633] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981634] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981635] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981637] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981638] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981639] uvcvideo: Dropping payload (error bit set).
> <7>[52260.981640] uvcvideo: Dropping payload (error bit set).
> <7>[52261.101630] uvcvideo: Frame complete (EOF found).
> <7>[52261.101641] uvcvideo: Dequeuing buffer 0 (3, 22930 bytes).
> <7>[52261.101702] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.101705] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 0.
> <7>[52261.127126] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.127131] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
> <7>[52261.221642] uvcvideo: Dequeuing buffer 1 (3, 22682 bytes).
> <7>[52261.221688] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.221689] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 1.
> <7>[52261.234064] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.234069] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
> <7>[52261.341653] uvcvideo: Dequeuing buffer 2 (3, 25734 bytes).
> <7>[52261.341711] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.341714] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 2.
> <7>[52261.354175] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.354181] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
> <7>[52261.461651] uvcvideo: Dequeuing buffer 3 (3, 25702 bytes).
> <7>[52261.461702] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.461704] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 3.
> <7>[52261.474363] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.474368] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
> <7>[52261.581655] uvcvideo: Dequeuing buffer 0 (3, 27500 bytes).
> <7>[52261.581705] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.581707] VIDIOC_QBUF<7>uvcvideo: Queuing buffer 0.
> <7>[52261.594133] uvcvideo: uvc_v4l2_ioctl
> <4>[52261.594139] VIDIOC_DQBUF<7>uvcvideo: Frame complete (EOF found).
> <7>[52261.701659] uvcvideo: Dequeuing buffer 1 (3, 27352 bytes).
> <7>[52261.701709] uvcvideo: uvc_v4l2_ioctl
> ...
> [ and this repeats. ]
> ...

I can't see anything wrong there. Video data is transferred from the webcam to 
the driver and then to the application. What exactly goes wrong on the 
application side ?

> <4>[52270.667558] VIDIOC_STREAMOFF<7>uvcvideo: uvc_v4l2_release
>
> What I don't understand is the 120ms interval between the buffers
> getting queued. I had expected 30ms intervals....

Not too surprising, most webcams have auto-exposure turned on by default and 
reduce the frame rate in low light conditions.

Regards,

Laurent Pinchart



From laurent.pinchart at ideasonboard.com  Fri Jul 31 15:05:30 2009
From: laurent.pinchart at ideasonboard.com (Laurent Pinchart)
Date: Fri, 31 Jul 2009 15:05:30 +0200
Subject: [Linux-uvc-devel] newest creative live cam notebook ultra
	doesn't work
Message-ID: <200907311505.30179.laurent.pinchart@ideasonboard.com>

Hi Andres,

On Thursday 30 July 2009 18:54:03 Andres Cimmarusti wrote:
> Hi,
>
> I just want to say that I just bought a Creative Live! Cam Notebook Ultra
> (because it was fully supported according to your website). Unfortunately,
> the device doesn't work at all and the Device ID does not match the one you
> have in the website (perhaps the one I bought is the most recent model).
> Here is the information I could find in /var/log/
>
> uvcvideo: Failed to query (1) UVC control 1 (unit 0) : -110 (exp. 26).
> uvcvideo: Found UVC 1.00 device VF0490 Live Cam Notebook Ultra (041e:4072)
>
> While the webcam usually fails to load, sometimes it is loaded properly and
> using luvcview makes it work. However, 80% of the time this is not so
> causing this error:
>
> Unable to set format: Input/output error
>  Init v4L2 failed !! exit fatal
>
> When the device is actually loaded to /dev/video0 properly and it works
> under luvcview and skype, usb audio doesn't work at all. The modules are
> loaded, but if I try:
>
> alsamixer -c 2
> alsamixer: function snd_mixer_load failed: Invalid argument
>
> In fact when double clicking on the sound applet in the gnome panel, if I
> try to select other devices, the usb microphone is not listed at all. This
> is very strange since I get the following output from the commands:
>
> cat /proc/asound/cards
>  0 [IXP            ]: ATIIXP - ATI IXP
>                       ATI IXP rev 2 with unknown codec at 0xc0003400, irq
> 17 1 [Modem          ]: ATIIXP-MODEM - ATI IXP Modem
>                       ATI IXP Modem rev 2 at 0xc0003800, irq 17
>  2 [Ultra          ]: USB-Audio - VF0490 Live Cam Notebook Ultra
>                       Creative Technology Ltd VF0490 Live Cam Notebook
> Ultra at usb-0000:00:13.2-1, h
>
> arecord -l
> **** List of CAPTURE Hardware Devices ****
> card 0: IXP [ATI IXP], device 0: ATI IXP AC97 [ATI IXP AC97]
>   Subdevices: 1/1
>   Subdevice #0: subdevice #0
> card 1: Modem [ATI IXP Modem], device 0: ATI IXP MC97 [ATI IXP MC97]
>   Subdevices: 1/1
>   Subdevice #0: subdevice #0
> card 2: Ultra [VF0490 Live Cam Notebook Ultra], device 0: USB Audio [USB
> Audio]
>   Subdevices: 1/1
>   Subdevice #0: subdevice #0
>
> lsmod | grep snd_usb
> snd_usb_audio          87584  0
> snd_usb_lib            15872  1 snd_usb_audio
> snd_rawmidi            22944  2 snd_usb_lib,snd_seq_midi
> snd_hwdep               7880  1 snd_usb_audio
> snd_pcm                75788  6
> snd_usb_audio,snd_atiixp,snd_atiixp_modem,snd_ac97_codec
> snd                    58936  16
> snd_usb_audio,snd_rawmidi,snd_hwdep,snd_atiixp,snd_atiixp_modem,snd_ac97_co
>dec,snd_pcm,snd_seq,snd_timer,snd_seq_device
>
> I believe the previous model (which is the one probably listed on the
> website) is the VF0310. I will now return the product for a refund.
>
> I'm running Debian Lenny 5.0.2 amd64 gnome with a custom built kernel:
> 2.6.27.28
>
> I have another UVC webcam device (logitech quickcam pro for notebooks (2007
> model)) which works perfectly under the same circumstances.
>
> I hope you will update the information in your website, thanks

If it's not too late, could you send me the output of lsusb -v for your 
Creative webcam ?

Regards,

Laurent Pinchart




From acimmarusti at gmail.com  Fri Jul 31 15:23:13 2009
From: acimmarusti at gmail.com (Andres Cimmarusti)
Date: Fri, 31 Jul 2009 09:23:13 -0400
Subject: [Linux-uvc-devel] newest creative live cam notebook ultra
	doesn't work
In-Reply-To: <200907311445.00756.laurent.pinchart@ideasonboard.com>
References: <e194349c0907300954m5a0064d1ubc929d2078086171@mail.gmail.com>
	<200907311445.00756.laurent.pinchart@ideasonboard.com>
Message-ID: <e194349c0907310623y6ef173b0h976afc5ebf80b248@mail.gmail.com>

Sorry, it is too late..., however I do remember vaguely the output of
"plain" lsusb, it was something like this:

ID 041e:4072 Creative Technology Ltd

Andres
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090731/c4502dbc/attachment.html>

