<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Linux-uvc-devel] [RFC] Discard overrun (corrupted) RX images
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/linux-uvc-devel/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BRFC%5D%20Discard%20overrun%20%28corrupted%29%20RX%20images&In-Reply-To=%3C201007021500.15314.laurent.pinchart%40ideasonboard.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005828.html">
   <LINK REL="Next"  HREF="005832.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Linux-uvc-devel] [RFC] Discard overrun (corrupted) RX images</H1>
    <B>Laurent Pinchart</B> 
    <A HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BRFC%5D%20Discard%20overrun%20%28corrupted%29%20RX%20images&In-Reply-To=%3C201007021500.15314.laurent.pinchart%40ideasonboard.com%3E"
       TITLE="[Linux-uvc-devel] [RFC] Discard overrun (corrupted) RX images">laurent.pinchart at ideasonboard.com
       </A><BR>
    <I>Fri Jul  2 15:00:13 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="005828.html">[Linux-uvc-devel] Better webcam support
</A></li>
        <LI>Next message: <A HREF="005832.html">[Linux-uvc-devel] [RFC] Discard overrun (corrupted) RX images
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5829">[ date ]</a>
              <a href="thread.html#5829">[ thread ]</a>
              <a href="subject.html#5829">[ subject ]</a>
              <a href="author.html#5829">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

On Friday 18 June 2010 21:26:01 P F wrote:
&gt;<i> 
</I>&gt;<i> Hi Laurent.  Thank you for your attention on this issue.
</I>
You're welcome.

CC'ing Mark O'Neill who seem to suffer from the same problem. Mark, is your
hardware setup identical ?

&gt;<i> I upgraded my uvcvideo driver from 2.6.31 to 2.6.34, and the corrupted
</I>&gt;<i> frames were still present.  I then applied your patch to 2.6.34, but the
</I>&gt;<i> corrupted frames are still present.
</I>
:<i>-(
</I>
There was a small mistake in the patch that would result in all frames being
discarded when a transfer error was detected. It shouldn't prevent corruption
from being detected though.

&gt;<i> I originally noticed this problem with a custom application, but in the
</I>&gt;<i> process of debugging, I have been able to reproduce it with a modified
</I>&gt;<i> version of luvcview as well.  My patch for luvcview is attached.  The
</I>&gt;<i> patch disables JPEG decoding and drawing to the display.  It also reduces
</I>&gt;<i> the number of v4l2 buffers to 1.  These changes are not required to trigger
</I>&gt;<i> the frame corruption, but they seem to exacerbate the problem.  I realize
</I>&gt;<i> that 1 v4l2 buffer might be unreasonable, but I can produce this problem
</I>&gt;<i> with 2 or 3 buffers as well.
</I>
I've tried the patch, but haven't been able to reproduce the problem with a
Logitech Portable Webcam C200.

&gt;<i> Counterintuitively, having more CPU available (by disabling rendering)
</I>&gt;<i> seems to worsen the problem.  Also, adding printks for debugging almost
</I>&gt;<i> always masks the problem.  For these reasons, I think maybe there might be
</I>&gt;<i> some cache coherency issue, but my attempts at sprinkling
</I>&gt;<i> flush_dcache_page() in the OHCI driver have not helped.  (For reference:
</I>&gt;<i> <A HREF="http://thread.gmane.org/gmane.linux.usb.general/27072/focus=944990">http://thread.gmane.org/gmane.linux.usb.general/27072/focus=944990</A>)
</I>
There could indeed be cache issues, but that thread is about a completely
different problem. Your USB host controller uses DMA, and I'd be quite
surprised if cache was handled incorrectly in the OHCI driver.

&gt;<i> I extracted some JPEGs from an AVI generated by luvcview to give you an
</I>&gt;<i> idea of what I'm seeing.  I shook the camera while filming some color bars
</I>&gt;<i> (shaking also seems to trigger the problem).  The files are named by
</I>&gt;<i> timestamp, and the middle one shows the characteristic corruption.
</I>&gt;<i>
</I>&gt;<i> I have seen this behavior consistently on two different models of UVC
</I>&gt;<i> camera.  I am going to try a non-UVC v4l2 camera to see if this is
</I>&gt;<i> actually a platform issue as opposed to a uvcvideo one.
</I>
What models have you tried ?
 
&gt;<i> I will be on holiday next week, so if you have another patch I won't be
</I>&gt;<i> able to test it until June 28.
</I>
I've attached a new patch to this e-mail that fixes the problem mentioned
above. Could you please add a printk statement in uvc_queue_next_buffer when
buf-&gt;error is set, to check that every occurrence of the &quot;USB isochronous
frame lost&quot; message results in the frame being dropped in
uvc_queue_next_buffer ?

It's also quite possible that, due to a buffer underrun, part of the image
gets dropped by the camera. Could you try a YUYV UVC device, and see if you
get any frame dropped by the buffer length test despite no USB isochronous
frame loss being detected ?

From 3fa13b68dbe14ebe891a6529e9b514ff9922ff16 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">laurent.pinchart at ideasonboard.com</A>&gt;
Date: Thu, 17 Jun 2010 11:52:37 +0200
Subject: [PATCH] uvcvideo: Drop corrupted compressed frames

Corrupted video frames are dropped by default by the driver for
uncompressed formats. Data corruption is not less problematic for
compressed formats, so frame drop should be enabled by default for those
formats as well.

Mark buffers as faulty when an isochronous packet loss is detected for
any format, or when the buffer length doesn't match the image size for
uncompressed formats. Drop erroneous buffers regardless of whether the
format is compressed or uncompressed.

Signed-off-by: Laurent Pinchart &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">laurent.pinchart at ideasonboard.com</A>&gt;
---
 drivers/media/video/uvc/uvc_queue.c |   13 +++++++++----
 drivers/media/video/uvc/uvc_video.c |   19 +++++++++++--------
 drivers/media/video/uvc/uvcvideo.h  |    5 +++--
 3 files changed, 23 insertions(+), 14 deletions(-)

diff --git a/drivers/media/video/uvc/uvc_queue.c b/drivers/media/video/uvc/uvc_queue.c
index 133c78d..e9928a4 100644
--- a/drivers/media/video/uvc/uvc_queue.c
+++ b/drivers/media/video/uvc/uvc_queue.c
@@ -78,12 +78,14 @@
  *
  */
 
-void uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type)
+void uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,
+		    int drop_corrupted)
 {
 	mutex_init(&amp;queue-&gt;mutex);
 	spin_lock_init(&amp;queue-&gt;irqlock);
 	INIT_LIST_HEAD(&amp;queue-&gt;mainqueue);
 	INIT_LIST_HEAD(&amp;queue-&gt;irqqueue);
+	queue-&gt;flags = drop_corrupted ? UVC_QUEUE_DROP_CORRUPTED : 0;
 	queue-&gt;type = type;
 }
 
@@ -435,8 +437,10 @@ int uvc_queue_enable(struct uvc_video_queue *queue, int enable)
 		uvc_queue_cancel(queue, 0);
 		INIT_LIST_HEAD(&amp;queue-&gt;mainqueue);
 
-		for (i = 0; i &lt; queue-&gt;count; ++i)
+		for (i = 0; i &lt; queue-&gt;count; ++i) {
+			queue-&gt;buffer[i].error = 0;
 			queue-&gt;buffer[i].state = UVC_BUF_STATE_IDLE;
+		}
 
 		queue-&gt;flags &amp;= ~UVC_QUEUE_STREAMING;
 	}
@@ -488,8 +492,8 @@ struct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,
 	struct uvc_buffer *nextbuf;
 	unsigned long flags;
 
-	if ((queue-&gt;flags &amp; UVC_QUEUE_DROP_INCOMPLETE) &amp;&amp;
-	    buf-&gt;buf.length != buf-&gt;buf.bytesused) {
+	if ((queue-&gt;flags &amp; UVC_QUEUE_DROP_CORRUPTED) &amp;&amp; buf-&gt;error) {
+		buf-&gt;error = 0;
 		buf-&gt;state = UVC_BUF_STATE_QUEUED;
 		buf-&gt;buf.bytesused = 0;
 		return buf;
@@ -497,6 +501,7 @@ struct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,
 
 	spin_lock_irqsave(&amp;queue-&gt;irqlock, flags);
 	list_del(&amp;buf-&gt;queue);
+	buf-&gt;error = 0;
 	buf-&gt;state = UVC_BUF_STATE_DONE;
 	if (!list_empty(&amp;queue-&gt;irqqueue))
 		nextbuf = list_first_entry(&amp;queue-&gt;irqqueue, struct uvc_buffer,
diff --git a/drivers/media/video/uvc/uvc_video.c b/drivers/media/video/uvc/uvc_video.c
index 53f3ef4..e27cf0d 100644
--- a/drivers/media/video/uvc/uvc_video.c
+++ b/drivers/media/video/uvc/uvc_video.c
@@ -555,6 +555,9 @@ static void uvc_video_decode_isoc(struct urb *urb, struct uvc_streaming *stream,
 		if (urb-&gt;iso_frame_desc[i].status &lt; 0) {
 			uvc_trace(UVC_TRACE_FRAME, &quot;USB isochronous frame &quot;
 				&quot;lost (%d).\n&quot;, urb-&gt;iso_frame_desc[i].status);
+			/* Mark the buffer as faulty. */
+			if (buf != NULL)
+				buf-&gt;error = 1;
 			continue;
 		}
 
@@ -579,8 +582,14 @@ static void uvc_video_decode_isoc(struct urb *urb, struct uvc_streaming *stream,
 		uvc_video_decode_end(stream, buf, mem,
 			urb-&gt;iso_frame_desc[i].actual_length);
 
-		if (buf-&gt;state == UVC_BUF_STATE_READY)
+		if (buf-&gt;state == UVC_BUF_STATE_READY) {
+			if (buf-&gt;buf.length != buf-&gt;buf.bytesused &amp;&amp;
+			    !(stream-&gt;cur_format-&gt;flags &amp;
+			      UVC_FMT_FLAG_COMPRESSED))
+				buf-&gt;error = 1;
+
 			buf = uvc_queue_next_buffer(&amp;stream-&gt;queue, buf);
+		}
 	}
 }
 
@@ -1104,7 +1113,7 @@ int uvc_video_init(struct uvc_streaming *stream)
 	atomic_set(&amp;stream-&gt;active, 0);
 
 	/* Initialize the video buffers queue. */
-	uvc_queue_init(&amp;stream-&gt;queue, stream-&gt;type);
+	uvc_queue_init(&amp;stream-&gt;queue, stream-&gt;type, !uvc_no_drop_param);
 
 	/* Alternate setting 0 should be the default, yet the XBox Live Vision
 	 * Cam (and possibly other devices) crash or otherwise misbehave if
@@ -1197,12 +1206,6 @@ int uvc_video_enable(struct uvc_streaming *stream, int enable)
 		return 0;
 	}
 
-	if ((stream-&gt;cur_format-&gt;flags &amp; UVC_FMT_FLAG_COMPRESSED) ||
-	    uvc_no_drop_param)
-		stream-&gt;queue.flags &amp;= ~UVC_QUEUE_DROP_INCOMPLETE;
-	else
-		stream-&gt;queue.flags |= UVC_QUEUE_DROP_INCOMPLETE;
-
 	ret = uvc_queue_enable(&amp;stream-&gt;queue, 1);
 	if (ret &lt; 0)
 		return ret;
diff --git a/drivers/media/video/uvc/uvcvideo.h b/drivers/media/video/uvc/uvcvideo.h
index 47b20e7..85e2f89 100644
--- a/drivers/media/video/uvc/uvcvideo.h
+++ b/drivers/media/video/uvc/uvcvideo.h
@@ -398,11 +398,12 @@ struct uvc_buffer {
 	struct list_head queue;
 	wait_queue_head_t wait;
 	enum uvc_buffer_state state;
+	unsigned int error;
 };
 
 #define UVC_QUEUE_STREAMING		(1 &lt;&lt; 0)
 #define UVC_QUEUE_DISCONNECTED		(1 &lt;&lt; 1)
-#define UVC_QUEUE_DROP_INCOMPLETE	(1 &lt;&lt; 2)
+#define UVC_QUEUE_DROP_CORRUPTED	(1 &lt;&lt; 2)
 
 struct uvc_video_queue {
 	enum v4l2_buf_type type;
@@ -581,7 +582,7 @@ extern struct uvc_driver uvc_driver;
 
 /* Video buffers queue management. */
 extern void uvc_queue_init(struct uvc_video_queue *queue,
-		enum v4l2_buf_type type);
+		enum v4l2_buf_type type, int drop_corrupted);
 extern int uvc_alloc_buffers(struct uvc_video_queue *queue,
 		unsigned int nbuffers, unsigned int buflength);
 extern int uvc_free_buffers(struct uvc_video_queue *queue);
-- 
1.7.1

-- 
Regards,

Laurent Pinchart

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005828.html">[Linux-uvc-devel] Better webcam support
</A></li>
	<LI>Next message: <A HREF="005832.html">[Linux-uvc-devel] [RFC] Discard overrun (corrupted) RX images
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5829">[ date ]</a>
              <a href="thread.html#5829">[ thread ]</a>
              <a href="subject.html#5829">[ subject ]</a>
              <a href="author.html#5829">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">More information about the Linux-uvc-devel
mailing list</a><br>
</body></html>
