<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/linux-uvc-devel/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BPATCH%202/2%5D%20uvcvideo%3A%20Multiple%20streaming%0A%20interfaces%20support&In-Reply-To=%3C57789.194.3.40.246.1246548844.squirrel%40mail2.esiee.fr%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004943.html">
   <LINK REL="Next"  HREF="004952.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support</H1>
    <B>lescopc at esiee.fr</B> 
    <A HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BPATCH%202/2%5D%20uvcvideo%3A%20Multiple%20streaming%0A%20interfaces%20support&In-Reply-To=%3C57789.194.3.40.246.1246548844.squirrel%40mail2.esiee.fr%3E"
       TITLE="[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support">lescopc at esiee.fr
       </A><BR>
    <I>Thu Jul  2 17:34:04 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004943.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support
</A></li>
        <LI>Next message: <A HREF="004952.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4951">[ date ]</a>
              <a href="thread.html#4951">[ thread ]</a>
              <a href="subject.html#4951">[ subject ]</a>
              <a href="author.html#4951">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello everyone,

I am trying to stream with 2 webcams simultaneously so I tried your patch.
The thing is I am not that good with Linux so.... didn't work. Here what I
did:

**I downloaded your source from:
<A HREF="http://linuxtv.org/hg/~pinchartl/uvcvideo/">http://linuxtv.org/hg/~pinchartl/uvcvideo/</A>


**I copied/pasted the content of this mail and the second one started from:

diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_ctrl.c

till the end to files that I named patchOne.diff and patchTwo.diff

**Then, in a terminal, I went to:
uvcvideo-bff77ec33116/linux/drivers/media/video/uvc

**I did:
patch &lt;patchOne.diff

It did not changed the content of the original files and I got:
patching file uvc_driver.c
Hunk #1 FAILED at 551.
Hunk #2 FAILED at 752.
Hunk #3 FAILED at 1167.
Hunk #5 FAILED at 1494.
Hunk #6 FAILED at 1515.
Hunk #7 FAILED at 1530.
Hunk #8 FAILED at 1568.
Hunk #9 FAILED at 1602.
Hunk #10 FAILED at 1643.
Hunk #11 FAILED at 1697.
Hunk #12 FAILED at 1706.
Hunk #13 FAILED at 1735.
12 out of 13 hunks FAILED -- saving rejects to file uvc_driver.c.rej
patching file uvc_isight.c
Hunk #1 FAILED at 99.
Hunk #2 FAILED at 120.
etc...

Can anyone tell me what I am doing wrong?
Regards,


LESCOP C&#233;dric




On Thu, July 2, 2009 01:31, Laurent Pinchart wrote:
&gt;<i> Restructure the UVC descriptors parsing code to handle multiple streaming
</I>&gt;<i>  interfaces. The driver now creates a uvc_video_chain instance for each
</I>&gt;<i> chain detected in the UVC control interface descriptors, and tries to
</I>&gt;<i> register one video device per streaming endpoint.
</I>&gt;<i>
</I>&gt;<i> Priority: normal
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Signed-off-by: Laurent Pinchart &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">laurent.pinchart at skynet.be</A>&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> diff -r 88ef3b9f5071 -r 012e480c8e6a
</I>&gt;<i> linux/drivers/media/video/uvc/uvc_ctrl.c ---
</I>&gt;<i> a/linux/drivers/media/video/uvc/uvc_ctrl.c	Sun Jun 28 13:37:50 2009 +0200
</I>&gt;<i>  +++ b/linux/drivers/media/video/uvc/uvc_ctrl.c	Thu Jul 02 01:24:47 2009
</I>&gt;<i> +0200
</I>&gt;<i> @@ -731,7 +731,7 @@
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -struct uvc_control *uvc_find_control(struct uvc_video_device *video,
</I>&gt;<i> +struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
</I>&gt;<i> __u32 v4l2_id, struct uvc_control_mapping **mapping)
</I>&gt;<i> {
</I>&gt;<i> struct uvc_control *ctrl = NULL; @@ -744,17 +744,17 @@
</I>&gt;<i> v4l2_id &amp;= V4L2_CTRL_ID_MASK;
</I>&gt;<i>
</I>&gt;<i> /* Find the control. */
</I>&gt;<i> -	__uvc_find_control(video-&gt;processing, v4l2_id, mapping, &amp;ctrl, next);
</I>&gt;<i> +	__uvc_find_control(chain-&gt;processing, v4l2_id, mapping, &amp;ctrl, next);
</I>&gt;<i> if (ctrl &amp;&amp; !next) return ctrl;
</I>&gt;<i>
</I>&gt;<i> -	list_for_each_entry(entity, &amp;video-&gt;iterms, chain) {
</I>&gt;<i> +	list_for_each_entry(entity, &amp;chain-&gt;iterms, chain) {
</I>&gt;<i> __uvc_find_control(entity, v4l2_id, mapping, &amp;ctrl, next);
</I>&gt;<i> if (ctrl &amp;&amp; !next) return ctrl; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -	list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
</I>&gt;<i> +	list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
</I>&gt;<i> __uvc_find_control(entity, v4l2_id, mapping, &amp;ctrl, next);
</I>&gt;<i> if (ctrl &amp;&amp; !next) return ctrl; @@ -767,7 +767,7 @@
</I>&gt;<i> return ctrl; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
</I>&gt;<i> +int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
</I>&gt;<i> struct v4l2_queryctrl *v4l2_ctrl) {
</I>&gt;<i> struct uvc_control *ctrl; @@ -777,7 +777,7 @@
</I>&gt;<i> __u8 *data;
</I>&gt;<i> int ret;
</I>&gt;<i>
</I>&gt;<i> -	ctrl = uvc_find_control(video, v4l2_ctrl-&gt;id, &amp;mapping);
</I>&gt;<i> +	ctrl = uvc_find_control(chain, v4l2_ctrl-&gt;id, &amp;mapping);
</I>&gt;<i> if (ctrl == NULL) return -EINVAL;
</I>&gt;<i>
</I>&gt;<i> @@ -795,9 +795,10 @@
</I>&gt;<i> v4l2_ctrl-&gt;flags |= V4L2_CTRL_FLAG_READ_ONLY;
</I>&gt;<i>
</I>&gt;<i> if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_DEF) { -		if ((ret =
</I>&gt;<i> uvc_query_ctrl(video-&gt;dev, GET_DEF, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -				data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> 0)
</I>&gt;<i> +		ret = uvc_query_ctrl(chain-&gt;dev, GET_DEF, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> +				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
</I>&gt;<i> +				     data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> +		if (ret &lt; 0)
</I>&gt;<i> goto out; v4l2_ctrl-&gt;default_value = mapping-&gt;get(mapping, GET_DEF,
</I>data); }
&gt;<i>  @@ -831,23 +832,26 @@
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_MIN) { -		if ((ret =
</I>&gt;<i> uvc_query_ctrl(video-&gt;dev, GET_MIN, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -				data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> 0)
</I>&gt;<i> +		ret = uvc_query_ctrl(chain-&gt;dev, GET_MIN, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> +				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
</I>&gt;<i> +				     data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> +		if (ret &lt; 0)
</I>&gt;<i> goto out; v4l2_ctrl-&gt;minimum = mapping-&gt;get(mapping, GET_MIN, data); }
</I>&gt;<i> if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_MAX) { -		if ((ret =
</I>&gt;<i> uvc_query_ctrl(video-&gt;dev, GET_MAX, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -				data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> 0)
</I>&gt;<i> +		ret = uvc_query_ctrl(chain-&gt;dev, GET_MAX, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> +				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
</I>&gt;<i> +				     data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> +		if (ret &lt; 0)
</I>&gt;<i> goto out; v4l2_ctrl-&gt;maximum = mapping-&gt;get(mapping, GET_MAX, data); }
</I>&gt;<i> if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_RES) { -		if ((ret =
</I>&gt;<i> uvc_query_ctrl(video-&gt;dev, GET_RES, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -				data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> 0)
</I>&gt;<i> +		ret = uvc_query_ctrl(chain-&gt;dev, GET_RES, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> +				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
</I>&gt;<i> +				     data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> +		if (ret &lt; 0)
</I>&gt;<i> goto out; v4l2_ctrl-&gt;step = mapping-&gt;get(mapping, GET_RES, data); }
</I>&gt;<i> @@ -883,9 +887,9 @@
</I>&gt;<i> * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release
</I>&gt;<i> the * control lock.
</I>&gt;<i> */
</I>&gt;<i> -int uvc_ctrl_begin(struct uvc_video_device *video)
</I>&gt;<i> +int uvc_ctrl_begin(struct uvc_video_chain *chain)
</I>&gt;<i> {
</I>&gt;<i> -	return mutex_lock_interruptible(&amp;video-&gt;ctrl_mutex) ? -ERESTARTSYS : 0;
</I>&gt;<i> +	return mutex_lock_interruptible(&amp;chain-&gt;ctrl_mutex) ? -ERESTARTSYS : 0;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> static int uvc_ctrl_commit_entity(struct uvc_device *dev, @@ -935,34
</I>&gt;<i> +939,34 @@
</I>&gt;<i> return 0; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
</I>&gt;<i> +int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
</I>&gt;<i> {
</I>&gt;<i> struct uvc_entity *entity; int ret = 0;
</I>&gt;<i>
</I>&gt;<i> /* Find the control. */
</I>&gt;<i> -	ret = uvc_ctrl_commit_entity(video-&gt;dev, video-&gt;processing, rollback);
</I>&gt;<i> +	ret = uvc_ctrl_commit_entity(chain-&gt;dev, chain-&gt;processing, rollback);
</I>&gt;<i> if (ret &lt; 0) goto done;
</I>&gt;<i>
</I>&gt;<i> -	list_for_each_entry(entity, &amp;video-&gt;iterms, chain) {
</I>&gt;<i> -		ret = uvc_ctrl_commit_entity(video-&gt;dev, entity, rollback);
</I>&gt;<i> +	list_for_each_entry(entity, &amp;chain-&gt;iterms, chain) {
</I>&gt;<i> +		ret = uvc_ctrl_commit_entity(chain-&gt;dev, entity, rollback);
</I>&gt;<i> if (ret &lt; 0) goto done; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -	list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
</I>&gt;<i> -		ret = uvc_ctrl_commit_entity(video-&gt;dev, entity, rollback);
</I>&gt;<i> +	list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
</I>&gt;<i> +		ret = uvc_ctrl_commit_entity(chain-&gt;dev, entity, rollback);
</I>&gt;<i> if (ret &lt; 0) goto done; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> done:
</I>&gt;<i> -	mutex_unlock(&amp;video-&gt;ctrl_mutex);
</I>&gt;<i> +	mutex_unlock(&amp;chain-&gt;ctrl_mutex);
</I>&gt;<i> return ret; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -int uvc_ctrl_get(struct uvc_video_device *video,
</I>&gt;<i> +int uvc_ctrl_get(struct uvc_video_chain *chain,
</I>&gt;<i> struct v4l2_ext_control *xctrl) {
</I>&gt;<i> struct uvc_control *ctrl; @@ -971,13 +975,13 @@
</I>&gt;<i> unsigned int i; int ret;
</I>&gt;<i>
</I>&gt;<i> -	ctrl = uvc_find_control(video, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> +	ctrl = uvc_find_control(chain, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> if (ctrl == NULL || (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_CUR) == 0) return
</I>&gt;<i> -EINVAL;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> if (!ctrl-&gt;loaded) { -		ret = uvc_query_ctrl(video-&gt;dev, GET_CUR,
</I>&gt;<i> ctrl-&gt;entity-&gt;id, -				video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
</I>&gt;<i> +		ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> +				chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
</I>&gt;<i> uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), ctrl-&gt;info-&gt;size); if (ret &lt; 0)
</I>&gt;<i> @@ -1002,7 +1006,7 @@
</I>&gt;<i> return 0; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -int uvc_ctrl_set(struct uvc_video_device *video,
</I>&gt;<i> +int uvc_ctrl_set(struct uvc_video_chain *chain,
</I>&gt;<i> struct v4l2_ext_control *xctrl) {
</I>&gt;<i> struct uvc_control *ctrl; @@ -1010,7 +1014,7 @@
</I>&gt;<i> s32 value = xctrl-&gt;value; int ret;
</I>&gt;<i>
</I>&gt;<i> -	ctrl = uvc_find_control(video, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> +	ctrl = uvc_find_control(chain, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> if (ctrl == NULL || (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_SET_CUR) == 0) return
</I>&gt;<i> -EINVAL;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -1025,8 +1029,8 @@
</I>&gt;<i> memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), 0, ctrl-&gt;info-&gt;size);
</I>&gt;<i> } else {
</I>&gt;<i> -			ret = uvc_query_ctrl(video-&gt;dev, GET_CUR,
</I>&gt;<i> -				ctrl-&gt;entity-&gt;id, video-&gt;dev-&gt;intfnum,
</I>&gt;<i> +			ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR,
</I>&gt;<i> +				ctrl-&gt;entity-&gt;id, chain-&gt;dev-&gt;intfnum,
</I>&gt;<i> ctrl-&gt;info-&gt;selector, uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
</I>&gt;<i> ctrl-&gt;info-&gt;size); @@ -1055,7 +1059,7 @@
</I>&gt;<i> * Dynamic controls
</I>&gt;<i> */
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -int uvc_xu_ctrl_query(struct uvc_video_device *video,
</I>&gt;<i> +int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
</I>&gt;<i> struct uvc_xu_control *xctrl, int set) {
</I>&gt;<i> struct uvc_entity *entity; @@ -1065,7 +1069,7 @@
</I>&gt;<i> int ret;
</I>&gt;<i>
</I>&gt;<i> /* Find the extension unit. */
</I>&gt;<i> -	list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
</I>&gt;<i> +	list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
</I>&gt;<i> if (entity-&gt;id == xctrl-&gt;unit) break; }
</I>&gt;<i> @@ -1104,7 +1108,7 @@
</I>&gt;<i> (!set &amp;&amp; !(ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_CUR)))
</I>&gt;<i> return -EINVAL;
</I>&gt;<i>
</I>&gt;<i> -	if (mutex_lock_interruptible(&amp;video-&gt;ctrl_mutex))
</I>&gt;<i> +	if (mutex_lock_interruptible(&amp;chain-&gt;ctrl_mutex))
</I>&gt;<i> return -ERESTARTSYS;
</I>&gt;<i>
</I>&gt;<i> memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), @@ -1117,8 +1121,8 @@
</I>&gt;<i> goto out; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -	ret = uvc_query_ctrl(video-&gt;dev, set ? SET_CUR : GET_CUR, xctrl-&gt;unit,
</I>&gt;<i> -			     video-&gt;dev-&gt;intfnum, xctrl-&gt;selector, data,
</I>&gt;<i> +	ret = uvc_query_ctrl(chain-&gt;dev, set ? SET_CUR : GET_CUR, xctrl-&gt;unit,
</I>&gt;<i> +			     chain-&gt;dev-&gt;intfnum, xctrl-&gt;selector, data,
</I>&gt;<i> xctrl-&gt;size); if (ret &lt; 0) goto out; @@ -1134,7 +1138,7 @@
</I>&gt;<i> uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), xctrl-&gt;size);
</I>&gt;<i>
</I>&gt;<i> -	mutex_unlock(&amp;video-&gt;ctrl_mutex);
</I>&gt;<i> +	mutex_unlock(&amp;chain-&gt;ctrl_mutex);
</I>&gt;<i> return ret; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> diff -r 88ef3b9f5071 -r 012e480c8e6a
</I>&gt;<i> linux/drivers/media/video/uvc/uvc_driver.c ---
</I>&gt;<i> a/linux/drivers/media/video/uvc/uvc_driver.c	Sun Jun 28 13:37:50 2009
</I>&gt;<i> +0200
</I>&gt;<i> +++ b/linux/drivers/media/video/uvc/uvc_driver.c	Thu Jul 02 01:24:47 2009
</I>&gt;<i> +0200
</I>&gt;<i> @@ -276,8 +276,20 @@
</I>&gt;<i> return NULL; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev,
</I>&gt;<i> int id) +{
</I>&gt;<i> +	struct uvc_streaming *stream;
</I>&gt;<i> +
</I>&gt;<i> +	list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
</I>&gt;<i> +		if (stream-&gt;header.bTerminalLink == id)
</I>&gt;<i> +			return stream;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return NULL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> /*
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> - * Descriptors handling
</I>&gt;<i> + * Descriptors parsing
</I>&gt;<i> */
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> static int uvc_parse_format(struct uvc_device *dev, @@ -1159,101 +1171,36
</I>&gt;<i> @@
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> - * USB probe and disconnect
</I>&gt;<i> + * UVC device scan
</I>&gt;<i> */
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> - * Unregister the video devices.
</I>&gt;<i> - */
</I>&gt;<i> -static void uvc_unregister_video(struct uvc_device *dev)
</I>&gt;<i> -{
</I>&gt;<i> -	struct uvc_streaming *streaming;
</I>&gt;<i> -
</I>&gt;<i> -	list_for_each_entry(streaming, &amp;dev-&gt;streams, list) {
</I>&gt;<i> -		if (streaming-&gt;vdev == NULL)
</I>&gt;<i> -			continue;
</I>&gt;<i> -
</I>&gt;<i> -		if (streaming-&gt;vdev-&gt;minor == -1)
</I>&gt;<i> -			video_device_release(streaming-&gt;vdev);
</I>&gt;<i> -		else
</I>&gt;<i> -			video_unregister_device(streaming-&gt;vdev);
</I>&gt;<i> -		streaming-&gt;vdev = NULL;
</I>&gt;<i> -	}
</I>&gt;<i> -}
</I>&gt;<i> -
</I>&gt;<i> -static int uvc_register_video(struct uvc_device *dev,
</I>&gt;<i> -		struct uvc_streaming *stream)
</I>&gt;<i> -{
</I>&gt;<i> -	struct video_device *vdev;
</I>&gt;<i> -	struct uvc_entity *term;
</I>&gt;<i> -	int ret;
</I>&gt;<i> -
</I>&gt;<i> -	if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> -		uvc_printk(KERN_INFO, &quot;Found a valid video chain (&quot;);
</I>&gt;<i> -		list_for_each_entry(term, &amp;dev-&gt;video.iterms, chain) {
</I>&gt;<i> -			printk(&quot;%d&quot;, term-&gt;id);
</I>&gt;<i> -			if (term-&gt;chain.next != &amp;dev-&gt;video.iterms)
</I>&gt;<i> -				printk(&quot;,&quot;);
</I>&gt;<i> -		}
</I>&gt;<i> -		printk(&quot; -&gt; %d).\n&quot;, dev-&gt;video.oterm-&gt;id);
</I>&gt;<i> -	}
</I>&gt;<i> -
</I>&gt;<i> -	/* Initialize the streaming interface with default streaming
</I>&gt;<i> -	 * parameters.
</I>&gt;<i> -	 */
</I>&gt;<i> -	ret = uvc_video_init(stream);
</I>&gt;<i> -	if (ret &lt; 0) {
</I>&gt;<i> -		uvc_printk(KERN_ERR, &quot;Failed to initialize the device &quot;
</I>&gt;<i> -			&quot;(%d).\n&quot;, ret);
</I>&gt;<i> -		return ret;
</I>&gt;<i> -	}
</I>&gt;<i> -
</I>&gt;<i> -	/* Register the device with V4L. */
</I>&gt;<i> -	vdev = video_device_alloc();
</I>&gt;<i> -	if (vdev == NULL)
</I>&gt;<i> -		return -1;
</I>&gt;<i> -
</I>&gt;<i> -	/* We already hold a reference to dev-&gt;udev. The video device will be
</I>&gt;<i> -	 * unregistered before the reference is released, so we don't need to
</I>&gt;<i> -	 * get another one.
</I>&gt;<i> -	 */
</I>&gt;<i> -	vdev-&gt;parent = &amp;dev-&gt;intf-&gt;dev;
</I>&gt;<i> -	vdev-&gt;minor = -1;
</I>&gt;<i> -	vdev-&gt;fops = &amp;uvc_fops;
</I>&gt;<i> -	vdev-&gt;release = video_device_release;
</I>&gt;<i> -	strlcpy(vdev-&gt;name, dev-&gt;name, sizeof vdev-&gt;name);
</I>&gt;<i> -
</I>&gt;<i> -	/* Set the driver data before calling video_register_device, otherwise
</I>&gt;<i> -	 * uvc_v4l2_open might race us.
</I>&gt;<i> -	 */
</I>&gt;<i> -	stream-&gt;vdev = vdev;
</I>&gt;<i> -	video_set_drvdata(vdev, stream);
</I>&gt;<i> -
</I>&gt;<i> -	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) &lt; 0) {
</I>&gt;<i> -		stream-&gt;vdev = NULL;
</I>&gt;<i> -		video_device_release(vdev);
</I>&gt;<i> -		return -1;
</I>&gt;<i> -	}
</I>&gt;<i> -
</I>&gt;<i> -	return 0;
</I>&gt;<i> -}
</I>&gt;<i> -
</I>&gt;<i> -/*
</I>&gt;<i> * Scan the UVC descriptors to locate a chain starting at an Output
</I>&gt;<i> Terminal
</I>&gt;<i> * and containing the following units:
</I>&gt;<i> *
</I>&gt;<i> - * - one Output Terminal (USB Streaming or Display)
</I>&gt;<i> + * - one or more Output Terminals (USB Streaming or Display)
</I>&gt;<i> * - zero or one Processing Unit
</I>&gt;<i> - * - zero, one or mode single-input Selector Units
</I>&gt;<i> + * - zero, one or more single-input Selector Units
</I>&gt;<i> * - zero or one multiple-input Selector Units, provided all inputs are
</I>&gt;<i> *   connected to input terminals
</I>&gt;<i> * - zero, one or mode single-input Extension Units
</I>&gt;<i> * - one or more Input Terminals (Camera, External or USB Streaming)
</I>&gt;<i> *
</I>&gt;<i> - * A side forward scan is made on each detected entity to check for
</I>&gt;<i> additional - * extension units.
</I>&gt;<i> + * The terminal and units must match on of the following structures:
</I>&gt;<i> + *
</I>&gt;<i> + * ITT_*(0) -&gt; +---------+    +---------+    +---------+ -&gt;
</I>&gt;<i> TT_STREAMING(0)
</I>&gt;<i> + * ...         | SU{0,1} | -&gt; | PU{0,1} | -&gt; | XU{0,n} |    ...
</I>&gt;<i> + * ITT_*(n) -&gt; +---------+    +---------+    +---------+ -&gt;
</I>&gt;<i> TT_STREAMING(n)
</I>&gt;<i> + *
</I>&gt;<i> + *                 +---------+    +---------+ -&gt; OTT_*(0)
</I>&gt;<i> + * TT_STREAMING -&gt; | PU{0,1} | -&gt; | XU{0,n} |    ...
</I>&gt;<i> + *                 +---------+    +---------+ -&gt; OTT_*(n)
</I>&gt;<i> + *
</I>&gt;<i> + * The Processing Unit and Extension Units can be in any order.
</I>&gt;<i> Additional
</I>&gt;<i> + * Extension Units connected to the main chain as single-unit branches
</I>&gt;<i> are + * also supported. Single-input Selector Units are ignored.
</I>&gt;<i> */
</I>&gt;<i> -static int uvc_scan_chain_entity(struct uvc_video_device *video,
</I>&gt;<i> +static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
</I>&gt;<i> struct uvc_entity *entity) {
</I>&gt;<i> switch (UVC_ENTITY_TYPE(entity)) { @@ -1267,20 +1214,20 @@
</I>&gt;<i> return -1; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;extensions);
</I>&gt;<i> +		list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;extensions);
</I>&gt;<i> break;
</I>&gt;<i>
</I>&gt;<i> case VC_PROCESSING_UNIT: if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot; &lt;-
</I>&gt;<i> PU %d&quot;, entity-&gt;id);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		if (video-&gt;processing != NULL) {
</I>&gt;<i> +		if (chain-&gt;processing != NULL) {
</I>&gt;<i> uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple &quot; &quot;Processing Units in
</I>&gt;<i> chain.\n&quot;); return -1; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		video-&gt;processing = entity;
</I>&gt;<i> +		chain-&gt;processing = entity;
</I>&gt;<i> break;
</I>&gt;<i>
</I>&gt;<i> case VC_SELECTOR_UNIT: @@ -1291,13 +1238,13 @@
</I>&gt;<i> if (entity-&gt;selector.bNrInPins == 1) break;
</I>&gt;<i>
</I>&gt;<i> -		if (video-&gt;selector != NULL) {
</I>&gt;<i> +		if (chain-&gt;selector != NULL) {
</I>&gt;<i> uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple Selector &quot; &quot;Units in chain.\n&quot;);
</I>&gt;<i>  return -1; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		video-&gt;selector = entity;
</I>&gt;<i> +		chain-&gt;selector = entity;
</I>&gt;<i> break;
</I>&gt;<i>
</I>&gt;<i> case ITT_VENDOR_SPECIFIC: @@ -1306,7 +1253,7 @@
</I>&gt;<i> if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot; &lt;- IT %d\n&quot;, entity-&gt;id);
</I>&gt;<i>
</I>&gt;<i> -		list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;iterms);
</I>&gt;<i> +		list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;iterms);
</I>&gt;<i> break;
</I>&gt;<i>
</I>&gt;<i> case TT_STREAMING: @@ -1319,14 +1266,7 @@
</I>&gt;<i> return -1; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		if (video-&gt;sterm != NULL) {
</I>&gt;<i> -			uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple streaming &quot;
</I>&gt;<i> -				&quot;entities in chain.\n&quot;);
</I>&gt;<i> -			return -1;
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;iterms);
</I>&gt;<i> -		video-&gt;sterm = entity;
</I>&gt;<i> +		list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;iterms);
</I>&gt;<i> break;
</I>&gt;<i>
</I>&gt;<i> default:
</I>&gt;<i> @@ -1338,7 +1278,7 @@
</I>&gt;<i> return 0; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -static int uvc_scan_chain_forward(struct uvc_video_device *video,
</I>&gt;<i> +static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
</I>&gt;<i> struct uvc_entity *entity, struct uvc_entity *prev) {
</I>&gt;<i> struct uvc_entity *forward; @@ -1349,28 +1289,51 @@
</I>&gt;<i> found = 0;
</I>&gt;<i>
</I>&gt;<i> while (1) { -		forward = uvc_entity_by_reference(video-&gt;dev, entity-&gt;id,
</I>&gt;<i> +		forward = uvc_entity_by_reference(chain-&gt;dev, entity-&gt;id,
</I>&gt;<i> forward); if (forward == NULL) break; -
</I>&gt;<i> -		if (UVC_ENTITY_TYPE(forward) != VC_EXTENSION_UNIT ||
</I>&gt;<i> -		    forward == prev)
</I>&gt;<i> +		if (forward == prev)
</I>&gt;<i> continue;
</I>&gt;<i>
</I>&gt;<i> -		if (forward-&gt;extension.bNrInPins != 1) {
</I>&gt;<i> -			uvc_trace(UVC_TRACE_DESCR, &quot;Extension unit %d has &quot;
</I>&gt;<i> -				&quot;more than 1 input pin.\n&quot;, entity-&gt;id);
</I>&gt;<i> -			return -1;
</I>&gt;<i> -		}
</I>&gt;<i> +		switch (UVC_ENTITY_TYPE(forward)) {
</I>&gt;<i> +		case VC_EXTENSION_UNIT:
</I>&gt;<i> +			if (forward-&gt;extension.bNrInPins != 1) {
</I>&gt;<i> +				uvc_trace(UVC_TRACE_DESCR, &quot;Extension unit %d &quot;
</I>&gt;<i> +					  &quot;has more than 1 input pin.\n&quot;,
</I>&gt;<i> +					  entity-&gt;id);
</I>&gt;<i> +				return -EINVAL;
</I>&gt;<i> +			}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		list_add_tail(&amp;forward-&gt;chain, &amp;video-&gt;extensions);
</I>&gt;<i> -		if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> -			if (!found)
</I>&gt;<i> -				printk(&quot; (-&gt; XU&quot;);
</I>&gt;<i> +			list_add_tail(&amp;forward-&gt;chain, &amp;chain-&gt;extensions);
</I>&gt;<i> +			if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> +				if (!found)
</I>&gt;<i> +					printk(&quot; (-&gt;&quot;);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -			printk(&quot; %d&quot;, forward-&gt;id);
</I>&gt;<i> -			found = 1;
</I>&gt;<i> +				printk(&quot; XU %d&quot;, forward-&gt;id);
</I>&gt;<i> +				found = 1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> +
</I>&gt;<i> +		case OTT_VENDOR_SPECIFIC:
</I>&gt;<i> +		case OTT_DISPLAY:
</I>&gt;<i> +		case OTT_MEDIA_TRANSPORT_OUTPUT:
</I>&gt;<i> +		case TT_STREAMING:
</I>&gt;<i> +			if (UVC_ENTITY_IS_ITERM(forward)) {
</I>&gt;<i> +				uvc_trace(UVC_TRACE_DESCR, &quot;Unsupported input &quot;
</I>&gt;<i> +					&quot;terminal %u.\n&quot;, forward-&gt;id);
</I>&gt;<i> +				return -EINVAL;
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			list_add_tail(&amp;forward-&gt;chain, &amp;chain-&gt;oterms);
</I>&gt;<i> +			if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> +				if (!found)
</I>&gt;<i> +					printk(&quot; (-&gt;&quot;);
</I>&gt;<i> +
</I>&gt;<i> +				printk(&quot; OT %d&quot;, forward-&gt;id);
</I>&gt;<i> +				found = 1;
</I>&gt;<i> +			}
</I>&gt;<i> +			break;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> if (found) @@ -1379,7 +1342,7 @@
</I>&gt;<i> return 0; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -static int uvc_scan_chain_backward(struct uvc_video_device *video,
</I>&gt;<i> +static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
</I>&gt;<i> struct uvc_entity *entity) {
</I>&gt;<i> struct uvc_entity *term; @@ -1404,10 +1367,10 @@
</I>&gt;<i> if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot; &lt;- IT&quot;);
</I>&gt;<i>
</I>&gt;<i> -		video-&gt;selector = entity;
</I>&gt;<i> +		chain-&gt;selector = entity;
</I>&gt;<i> for (i = 0; i &lt; entity-&gt;selector.bNrInPins; ++i) { id =
</I>&gt;<i> entity-&gt;selector.baSourceID[i]; -			term = uvc_entity_by_id(video-&gt;dev,
</I>&gt;<i> id); +			term = uvc_entity_by_id(chain-&gt;dev, id);
</I>&gt;<i> if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
</I>&gt;<i> uvc_trace(UVC_TRACE_DESCR, &quot;Selector unit %d &quot; &quot;input %d isn't connected
</I>&gt;<i> to an &quot; @@ -1418,8 +1381,8 @@
</I>&gt;<i> if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot; %d&quot;, term-&gt;id);
</I>&gt;<i>
</I>&gt;<i> -			list_add_tail(&amp;term-&gt;chain, &amp;video-&gt;iterms);
</I>&gt;<i> -			uvc_scan_chain_forward(video, term, entity);
</I>&gt;<i> +			list_add_tail(&amp;term-&gt;chain, &amp;chain-&gt;iterms);
</I>&gt;<i> +			uvc_scan_chain_forward(chain, term, entity);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> if (uvc_trace_param &amp; UVC_TRACE_PROBE) @@ -1432,108 +1395,264 @@
</I>&gt;<i> return id; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -static int uvc_scan_chain(struct uvc_video_device *video)
</I>&gt;<i> +static int uvc_scan_chain(struct uvc_video_chain *chain,
</I>&gt;<i> +			  struct uvc_entity *oterm)
</I>&gt;<i> {
</I>&gt;<i> struct uvc_entity *entity, *prev; int id;
</I>&gt;<i>
</I>&gt;<i> -	entity = video-&gt;oterm;
</I>&gt;<i> +	entity = oterm;
</I>&gt;<i> +	list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;oterms);
</I>&gt;<i> uvc_trace(UVC_TRACE_PROBE, &quot;Scanning UVC chain: OT %d&quot;, entity-&gt;id);
</I>&gt;<i>
</I>&gt;<i> -	if (UVC_ENTITY_TYPE(entity) == TT_STREAMING)
</I>&gt;<i> -		video-&gt;sterm = entity;
</I>&gt;<i> -
</I>&gt;<i> id = entity-&gt;output.bSourceID; while (id != 0) { prev = entity; -		entity =
</I>&gt;<i> uvc_entity_by_id(video-&gt;dev, id); +		entity = uvc_entity_by_id(chain-&gt;dev,
</I>&gt;<i> id); if (entity == NULL) { uvc_trace(UVC_TRACE_DESCR, &quot;Found reference to &quot;
</I>&gt;<i>  &quot;unknown entity %d.\n&quot;, id);
</I>&gt;<i> -			return -1;
</I>&gt;<i> +			return -EINVAL;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		if (entity-&gt;chain.next || entity-&gt;chain.prev) {
</I>&gt;<i> +			uvc_trace(UVC_TRACE_DESCR, &quot;Found reference to &quot;
</I>&gt;<i> +				&quot;entity %d already in chain.\n&quot;, id);
</I>&gt;<i> +			return -EINVAL;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* Process entity */
</I>&gt;<i> -		if (uvc_scan_chain_entity(video, entity) &lt; 0)
</I>&gt;<i> -			return -1;
</I>&gt;<i> +		if (uvc_scan_chain_entity(chain, entity) &lt; 0)
</I>&gt;<i> +			return -EINVAL;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* Forward scan */
</I>&gt;<i> -		if (uvc_scan_chain_forward(video, entity, prev) &lt; 0)
</I>&gt;<i> -			return -1;
</I>&gt;<i> +		if (uvc_scan_chain_forward(chain, entity, prev) &lt; 0)
</I>&gt;<i> +			return -EINVAL;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* Stop when a terminal is found. */
</I>&gt;<i> -		if (!UVC_ENTITY_IS_UNIT(entity))
</I>&gt;<i> +		if (UVC_ENTITY_IS_TERM(entity))
</I>&gt;<i> break;
</I>&gt;<i>
</I>&gt;<i> /* Backward scan */
</I>&gt;<i> -		id = uvc_scan_chain_backward(video, entity);
</I>&gt;<i> +		id = uvc_scan_chain_backward(chain, entity);
</I>&gt;<i> if (id &lt; 0) return id; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -	if (video-&gt;sterm == NULL) {
</I>&gt;<i> -		uvc_trace(UVC_TRACE_DESCR, &quot;No streaming entity found in &quot;
</I>&gt;<i> -			&quot;chain.\n&quot;);
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static unsigned int uvc_print_terms(struct list_head *terms, char
</I>&gt;<i> *buffer)
</I>&gt;<i> +{
</I>&gt;<i> +	struct uvc_entity *term;
</I>&gt;<i> +	unsigned int nterms = 0;
</I>&gt;<i> +	char *p = buffer;
</I>&gt;<i> +
</I>&gt;<i> +	list_for_each_entry(term, terms, chain) {
</I>&gt;<i> +		p += sprintf(p, &quot;%u&quot;, term-&gt;id);
</I>&gt;<i> +		if (term-&gt;chain.next != terms) {
</I>&gt;<i> +			p += sprintf(p, &quot;,&quot;);
</I>&gt;<i> +			if (++nterms &gt;= 4) {
</I>&gt;<i> +				p += sprintf(p, &quot;...&quot;);
</I>&gt;<i> +				break;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return p - buffer;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static const char *uvc_print_chain(struct uvc_video_chain *chain)
</I>&gt;<i> +{
</I>&gt;<i> +	static char buffer[43];
</I>&gt;<i> +	char *p = buffer;
</I>&gt;<i> +
</I>&gt;<i> +	p += uvc_print_terms(&amp;chain-&gt;iterms, p);
</I>&gt;<i> +	p += sprintf(p, &quot; -&gt; &quot;);
</I>&gt;<i> +	uvc_print_terms(&amp;chain-&gt;oterms, p);
</I>&gt;<i> +
</I>&gt;<i> +	return buffer;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> + * Scan the device for video chains and register video devices.
</I>&gt;<i> + *
</I>&gt;<i> + * Chains are scanned starting at their output terminals and walked
</I>&gt;<i> backwards. + */
</I>&gt;<i> +static int uvc_scan_device(struct uvc_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct uvc_video_chain *chain;
</I>&gt;<i> +	struct uvc_entity *term;
</I>&gt;<i> +
</I>&gt;<i> +	list_for_each_entry(term, &amp;dev-&gt;entities, list) {
</I>&gt;<i> +		if (!UVC_ENTITY_IS_OTERM(term))
</I>&gt;<i> +			continue;
</I>&gt;<i> +
</I>&gt;<i> +		/* If the terminal is already included in a chain, skip it.
</I>&gt;<i> +		 * This can happen for chains that have multiple output
</I>&gt;<i> +		 * terminals, where all output terminals beside the first one
</I>&gt;<i> +		 * will be inserted in the chain in forward scans.
</I>&gt;<i> +		 */
</I>&gt;<i> +		if (term-&gt;chain.next || term-&gt;chain.prev)
</I>&gt;<i> +			continue;
</I>&gt;<i> +
</I>&gt;<i> +		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
</I>&gt;<i> +		if (chain == NULL)
</I>&gt;<i> +			return -ENOMEM;
</I>&gt;<i> +
</I>&gt;<i> +		INIT_LIST_HEAD(&amp;chain-&gt;iterms);
</I>&gt;<i> +		INIT_LIST_HEAD(&amp;chain-&gt;oterms);
</I>&gt;<i> +		INIT_LIST_HEAD(&amp;chain-&gt;extensions);
</I>&gt;<i> +		mutex_init(&amp;chain-&gt;ctrl_mutex);
</I>&gt;<i> +		chain-&gt;dev = dev;
</I>&gt;<i> +
</I>&gt;<i> +		if (uvc_scan_chain(chain, term) &lt; 0) {
</I>&gt;<i> +			kfree(chain);
</I>&gt;<i> +			continue;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		uvc_trace(UVC_TRACE_PROBE, &quot;Found a valid video chain (%s).\n&quot;,
</I>&gt;<i> +			  uvc_print_chain(chain));
</I>&gt;<i> +
</I>&gt;<i> +		list_add_tail(&amp;chain-&gt;list, &amp;dev-&gt;chains);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (list_empty(&amp;dev-&gt;chains)) {
</I>&gt;<i> +		uvc_printk(KERN_INFO, &quot;No valid video chain found.\n&quot;);
</I>&gt;<i> return -1; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> return 0; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +/*
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> + * Video device registration and unregistration
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> /*
</I>&gt;<i> - * Scan the device for video chains and register video devices.
</I>&gt;<i> - *
</I>&gt;<i> - * The driver currently supports a single video device per control
</I>&gt;<i> interface - * only. The terminal and units must match the following
</I>&gt;<i> structure:
</I>&gt;<i> - *
</I>&gt;<i> - * ITT_* -&gt; VC_PROCESSING_UNIT -&gt; VC_EXTENSION_UNIT{0,n} -&gt; TT_STREAMING
</I>&gt;<i> - * TT_STREAMING -&gt; VC_PROCESSING_UNIT -&gt; VC_EXTENSION_UNIT{0,n} -&gt; OTT_*
</I>&gt;<i> - *
</I>&gt;<i> - * The Extension Units, if present, must have a single input pin. The
</I>&gt;<i> - * Processing Unit and Extension Units can be in any order. Additional
</I>&gt;<i> - * Extension Units connected to the main chain as single-unit branches
</I>&gt;<i> are - * also supported.
</I>&gt;<i> + * Unregister the video devices.
</I>&gt;<i> */
</I>&gt;<i> -static int uvc_scan_device(struct uvc_device *dev)
</I>&gt;<i> +static void uvc_unregister_video(struct uvc_device *dev)
</I>&gt;<i> {
</I>&gt;<i> -	struct uvc_entity *term;
</I>&gt;<i> -	int found = 0;
</I>&gt;<i> +	struct uvc_streaming *stream;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -	/* Check if the control interface matches the structure we expect. */
</I>&gt;<i> -	list_for_each_entry(term, &amp;dev-&gt;entities, list) {
</I>&gt;<i> -		struct uvc_streaming *stream;
</I>&gt;<i> -
</I>&gt;<i> -		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
</I>&gt;<i> +	list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
</I>&gt;<i> +		if (stream-&gt;vdev == NULL)
</I>&gt;<i> continue;
</I>&gt;<i>
</I>&gt;<i> -		memset(&amp;dev-&gt;video, 0, sizeof dev-&gt;video);
</I>&gt;<i> -		mutex_init(&amp;dev-&gt;video.ctrl_mutex);
</I>&gt;<i> -		INIT_LIST_HEAD(&amp;dev-&gt;video.iterms);
</I>&gt;<i> -		INIT_LIST_HEAD(&amp;dev-&gt;video.extensions);
</I>&gt;<i> -		dev-&gt;video.oterm = term;
</I>&gt;<i> -		dev-&gt;video.dev = dev;
</I>&gt;<i> -		if (uvc_scan_chain(&amp;dev-&gt;video) &lt; 0)
</I>&gt;<i> -			continue;
</I>&gt;<i> +		if (stream-&gt;vdev-&gt;minor == -1)
</I>&gt;<i> +			video_device_release(stream-&gt;vdev);
</I>&gt;<i> +		else
</I>&gt;<i> +			video_unregister_device(stream-&gt;vdev);
</I>&gt;<i> +		stream-&gt;vdev = NULL;
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
</I>&gt;<i> -			if (stream-&gt;header.bTerminalLink ==
</I>&gt;<i> -			    dev-&gt;video.sterm-&gt;id) {
</I>&gt;<i> -				uvc_register_video(dev, stream);
</I>&gt;<i> -				found = 1;
</I>&gt;<i> -				break;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> +static int uvc_register_video(struct uvc_device *dev,
</I>&gt;<i> +		struct uvc_streaming *stream)
</I>&gt;<i> +{
</I>&gt;<i> +	struct video_device *vdev;
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	/* Initialize the streaming interface with default streaming
</I>&gt;<i> +	 * parameters.
</I>&gt;<i> +	 */
</I>&gt;<i> +	ret = uvc_video_init(stream);
</I>&gt;<i> +	if (ret &lt; 0) {
</I>&gt;<i> +		uvc_printk(KERN_ERR, &quot;Failed to initialize the device &quot;
</I>&gt;<i> +			&quot;(%d).\n&quot;, ret);
</I>&gt;<i> +		return ret;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -	if (!found) {
</I>&gt;<i> -		uvc_printk(KERN_INFO, &quot;No valid video chain found.\n&quot;);
</I>&gt;<i> -		return -1;
</I>&gt;<i> +	/* Register the device with V4L. */
</I>&gt;<i> +	vdev = video_device_alloc();
</I>&gt;<i> +	if (vdev == NULL) {
</I>&gt;<i> +		uvc_printk(KERN_ERR, &quot;Failed to allocate video device (%d).\n&quot;,
</I>&gt;<i> +			   ret);
</I>&gt;<i> +		return -ENOMEM;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	/* We already hold a reference to dev-&gt;udev. The video device will be
</I>&gt;<i> +	 * unregistered before the reference is released, so we don't need to
</I>&gt;<i> +	 * get another one.
</I>&gt;<i> +	 */
</I>&gt;<i> +	vdev-&gt;parent = &amp;dev-&gt;intf-&gt;dev;
</I>&gt;<i> +	vdev-&gt;minor = -1;
</I>&gt;<i> +	vdev-&gt;fops = &amp;uvc_fops;
</I>&gt;<i> +	vdev-&gt;release = video_device_release;
</I>&gt;<i> +	strlcpy(vdev-&gt;name, dev-&gt;name, sizeof vdev-&gt;name);
</I>&gt;<i> +
</I>&gt;<i> +	/* Set the driver data before calling video_register_device, otherwise
</I>&gt;<i> +	 * uvc_v4l2_open might race us.
</I>&gt;<i> +	 */
</I>&gt;<i> +	stream-&gt;vdev = vdev;
</I>&gt;<i> +	video_set_drvdata(vdev, stream);
</I>&gt;<i> +
</I>&gt;<i> +	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
</I>&gt;<i> +	if (ret &lt; 0) {
</I>&gt;<i> +		uvc_printk(KERN_ERR, &quot;Failed to register video device (%d).\n&quot;,
</I>&gt;<i> +			   ret);
</I>&gt;<i> +		stream-&gt;vdev = NULL;
</I>&gt;<i> +		video_device_release(vdev);
</I>&gt;<i> +		return ret;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> return 0; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /*
</I>&gt;<i> + * Register all video devices in all chains.
</I>&gt;<i> + */
</I>&gt;<i> +static int uvc_register_terms(struct uvc_device *dev,
</I>&gt;<i> +	struct uvc_video_chain *chain, struct list_head *terms)
</I>&gt;<i> +{
</I>&gt;<i> +	struct uvc_streaming *stream;
</I>&gt;<i> +	struct uvc_entity *term;
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	list_for_each_entry(term, terms, chain) {
</I>&gt;<i> +		if (UVC_ENTITY_TYPE(term) != TT_STREAMING)
</I>&gt;<i> +			continue;
</I>&gt;<i> +
</I>&gt;<i> +		stream = uvc_stream_by_id(dev, term-&gt;id);
</I>&gt;<i> +		if (stream == NULL) {
</I>&gt;<i> +			uvc_printk(KERN_INFO, &quot;No streaming interface found &quot;
</I>&gt;<i> +				   &quot;for terminal %u.&quot;, term-&gt;id);
</I>&gt;<i> +			continue;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		stream-&gt;chain = chain;
</I>&gt;<i> +		ret = uvc_register_video(dev, stream);
</I>&gt;<i> +		if (ret &lt; 0)
</I>&gt;<i> +			return ret;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int uvc_register_chains(struct uvc_device *dev)
</I>&gt;<i> +{
</I>&gt;<i> +	struct uvc_video_chain *chain;
</I>&gt;<i> +	int ret;
</I>&gt;<i> +
</I>&gt;<i> +	list_for_each_entry(chain, &amp;dev-&gt;chains, list) {
</I>&gt;<i> +		ret = uvc_register_terms(dev, chain, &amp;chain-&gt;iterms);
</I>&gt;<i> +		if (ret &lt; 0)
</I>&gt;<i> +			return ret;
</I>&gt;<i> +
</I>&gt;<i> +		ret = uvc_register_terms(dev, chain, &amp;chain-&gt;oterms);
</I>&gt;<i> +		if (ret &lt; 0)
</I>&gt;<i> +			return ret;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	return 0;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> + * USB probe, disconnect, suspend and resume
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +/*
</I>&gt;<i> * Delete the UVC device.
</I>&gt;<i> *
</I>&gt;<i> * Called by the kernel when the last reference to the uvc_device structure
</I>&gt;<i>  @@ -1554,7 +1673,7 @@
</I>&gt;<i> struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
</I>&gt;<i> struct list_head *p, *n;
</I>&gt;<i>
</I>&gt;<i> -	/* Unregister the video device. */
</I>&gt;<i> +	/* Unregister the video devices. */
</I>&gt;<i> uvc_unregister_video(dev); usb_put_intf(dev-&gt;intf); usb_put_dev(dev-&gt;udev);
</I>&gt;<i> @@ -1562,6 +1681,12 @@
</I>&gt;<i> uvc_status_cleanup(dev); uvc_ctrl_cleanup_device(dev);
</I>&gt;<i>
</I>&gt;<i> +	list_for_each_safe(p, n, &amp;dev-&gt;chains) {
</I>&gt;<i> +		struct uvc_video_chain *chain;
</I>&gt;<i> +		chain = list_entry(p, struct uvc_video_chain, list);
</I>&gt;<i> +		kfree(chain);
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> list_for_each_safe(p, n, &amp;dev-&gt;entities) { struct uvc_entity *entity;
</I>entity
&gt;<i> = list_entry(p, struct uvc_entity, list);
</I>&gt;<i> @@ -1602,6 +1727,7 @@
</I>&gt;<i> return -ENOMEM;
</I>&gt;<i>
</I>&gt;<i> INIT_LIST_HEAD(&amp;dev-&gt;entities);
</I>&gt;<i> +	INIT_LIST_HEAD(&amp;dev-&gt;chains);
</I>&gt;<i> INIT_LIST_HEAD(&amp;dev-&gt;streams);
</I>&gt;<i> kref_init(&amp;dev-&gt;kref); atomic_set(&amp;dev-&gt;users, 0); @@ -1643,10 +1769,14 @@
</I>&gt;<i> if (uvc_ctrl_init_device(dev) &lt; 0) goto error;
</I>&gt;<i>
</I>&gt;<i> -	/* Scan the device for video chains and register video devices. */
</I>&gt;<i> +	/* Scan the device for video chains. */
</I>&gt;<i> if (uvc_scan_device(dev) &lt; 0) goto error;
</I>&gt;<i>
</I>&gt;<i> +	/* Register video devices. */
</I>&gt;<i> +	if (uvc_register_chains(dev) &lt; 0)
</I>&gt;<i> +		goto error;
</I>&gt;<i> +
</I>&gt;<i> /* Save our data pointer in the interface data. */
</I>&gt;<i> usb_set_intfdata(intf, dev);
</I>&gt;<i>
</I>&gt;<i> diff -r 88ef3b9f5071 -r 012e480c8e6a
</I>&gt;<i> linux/drivers/media/video/uvc/uvc_v4l2.c ---
</I>&gt;<i> a/linux/drivers/media/video/uvc/uvc_v4l2.c	Sun Jun 28 13:37:50 2009 +0200
</I>&gt;<i>  +++ b/linux/drivers/media/video/uvc/uvc_v4l2.c	Thu Jul 02 01:24:47 2009
</I>&gt;<i> +0200
</I>&gt;<i> @@ -40,7 +40,7 @@
</I>&gt;<i> * table for the controls that can be mapped directly, and handle the
</I>&gt;<i> others * manually.
</I>&gt;<i> */
</I>&gt;<i> -static int uvc_v4l2_query_menu(struct uvc_video_device *video,
</I>&gt;<i> +static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
</I>&gt;<i> struct v4l2_querymenu *query_menu) {
</I>&gt;<i> struct uvc_menu_info *menu_info; @@ -49,7 +49,7 @@
</I>&gt;<i> u32 index = query_menu-&gt;index; u32 id = query_menu-&gt;id;
</I>&gt;<i>
</I>&gt;<i> -	ctrl = uvc_find_control(video, query_menu-&gt;id, &amp;mapping);
</I>&gt;<i> +	ctrl = uvc_find_control(chain, query_menu-&gt;id, &amp;mapping);
</I>&gt;<i> if (ctrl == NULL || mapping-&gt;v4l2_type != V4L2_CTRL_TYPE_MENU) return
</I>&gt;<i> -EINVAL;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -493,7 +493,7 @@
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -	handle-&gt;video = &amp;stream-&gt;dev-&gt;video;
</I>&gt;<i> +	handle-&gt;chain = stream-&gt;chain;
</I>&gt;<i> handle-&gt;stream = stream; handle-&gt;state = UVC_HANDLE_PASSIVE;
</I>&gt;<i> file-&gt;private_data = handle; @@ -542,7 +542,7 @@
</I>&gt;<i> {
</I>&gt;<i> struct video_device *vdev = video_devdata(file); struct uvc_fh *handle =
</I>&gt;<i> (struct uvc_fh *)file-&gt;private_data;
</I>&gt;<i> -	struct uvc_video_device *video = handle-&gt;video;
</I>&gt;<i> +	struct uvc_video_chain *chain = handle-&gt;chain;
</I>&gt;<i> struct uvc_streaming *stream = handle-&gt;stream; long ret = 0;
</I>&gt;<i>
</I>&gt;<i> @@ -569,7 +569,7 @@
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* Get, Set &amp; Query control */
</I>&gt;<i> case VIDIOC_QUERYCTRL: -		return uvc_query_v4l2_ctrl(video, arg);
</I>&gt;<i> +		return uvc_query_v4l2_ctrl(chain, arg);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> case VIDIOC_G_CTRL: {
</I>&gt;<i> @@ -579,9 +579,9 @@
</I>&gt;<i> memset(&amp;xctrl, 0, sizeof xctrl); xctrl.id = ctrl-&gt;id;
</I>&gt;<i>
</I>&gt;<i> -		uvc_ctrl_begin(video);
</I>&gt;<i> -		ret = uvc_ctrl_get(video, &amp;xctrl);
</I>&gt;<i> -		uvc_ctrl_rollback(video);
</I>&gt;<i> +		uvc_ctrl_begin(chain);
</I>&gt;<i> +		ret = uvc_ctrl_get(chain, &amp;xctrl);
</I>&gt;<i> +		uvc_ctrl_rollback(chain);
</I>&gt;<i> if (ret &gt;= 0) ctrl-&gt;value = xctrl.value; break; @@ -596,18 +596,18 @@
</I>&gt;<i> xctrl.id = ctrl-&gt;id; xctrl.value = ctrl-&gt;value;
</I>&gt;<i>
</I>&gt;<i> -		uvc_ctrl_begin(video);
</I>&gt;<i> -		ret = uvc_ctrl_set(video, &amp;xctrl);
</I>&gt;<i> +		uvc_ctrl_begin(chain);
</I>&gt;<i> +		ret = uvc_ctrl_set(chain, &amp;xctrl);
</I>&gt;<i> if (ret &lt; 0) { -			uvc_ctrl_rollback(video);
</I>&gt;<i> +			uvc_ctrl_rollback(chain);
</I>&gt;<i> return ret; }
</I>&gt;<i> -		ret = uvc_ctrl_commit(video);
</I>&gt;<i> +		ret = uvc_ctrl_commit(chain);
</I>&gt;<i> break; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> case VIDIOC_QUERYMENU: -		return uvc_v4l2_query_menu(video, arg);
</I>&gt;<i> +		return uvc_v4l2_query_menu(chain, arg);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> case VIDIOC_G_EXT_CTRLS: {
</I>&gt;<i> @@ -615,17 +615,17 @@
</I>&gt;<i> struct v4l2_ext_control *ctrl = ctrls-&gt;controls; unsigned int i;
</I>&gt;<i>
</I>&gt;<i> -		uvc_ctrl_begin(video);
</I>&gt;<i> +		uvc_ctrl_begin(chain);
</I>&gt;<i> for (i = 0; i &lt; ctrls-&gt;count; ++ctrl, ++i) { -			ret = uvc_ctrl_get(video,
</I>&gt;<i> ctrl); +			ret = uvc_ctrl_get(chain, ctrl);
</I>&gt;<i> if (ret &lt; 0) { -				uvc_ctrl_rollback(video);
</I>&gt;<i> +				uvc_ctrl_rollback(chain);
</I>&gt;<i> ctrls-&gt;error_idx = i; return ret; }
</I>&gt;<i> }
</I>&gt;<i> ctrls-&gt;error_idx = 0; -		ret = uvc_ctrl_rollback(video);
</I>&gt;<i> +		ret = uvc_ctrl_rollback(chain);
</I>&gt;<i> break; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -636,14 +636,14 @@
</I>&gt;<i> struct v4l2_ext_control *ctrl = ctrls-&gt;controls; unsigned int i;
</I>&gt;<i>
</I>&gt;<i> -		ret = uvc_ctrl_begin(video);
</I>&gt;<i> +		ret = uvc_ctrl_begin(chain);
</I>&gt;<i> if (ret &lt; 0) return ret;
</I>&gt;<i>
</I>&gt;<i> for (i = 0; i &lt; ctrls-&gt;count; ++ctrl, ++i) { -			ret = uvc_ctrl_set(video,
</I>&gt;<i> ctrl); +			ret = uvc_ctrl_set(chain, ctrl);
</I>&gt;<i> if (ret &lt; 0) { -				uvc_ctrl_rollback(video);
</I>&gt;<i> +				uvc_ctrl_rollback(chain);
</I>&gt;<i> ctrls-&gt;error_idx = i; return ret; }
</I>&gt;<i> @@ -652,31 +652,31 @@
</I>&gt;<i> ctrls-&gt;error_idx = 0;
</I>&gt;<i>
</I>&gt;<i> if (cmd == VIDIOC_S_EXT_CTRLS) -			ret = uvc_ctrl_commit(video);
</I>&gt;<i> +			ret = uvc_ctrl_commit(chain);
</I>&gt;<i> else -			ret = uvc_ctrl_rollback(video);
</I>&gt;<i> +			ret = uvc_ctrl_rollback(chain);
</I>&gt;<i> break; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* Get, Set &amp; Enum input */
</I>&gt;<i> case VIDIOC_ENUMINPUT: {
</I>&gt;<i> -		const struct uvc_entity *selector = video-&gt;selector;
</I>&gt;<i> +		const struct uvc_entity *selector = chain-&gt;selector;
</I>&gt;<i> struct v4l2_input *input = arg; struct uvc_entity *iterm = NULL; u32
</I>index =
&gt;<i> input-&gt;index; int pin = 0;
</I>&gt;<i>
</I>&gt;<i> if (selector == NULL || -		    (video-&gt;dev-&gt;quirks &amp;
</I>&gt;<i> UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
</I>&gt;<i> +		    (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
</I>&gt;<i> if (index != 0) return -EINVAL; -			iterm =
</I>list_first_entry(&amp;video-&gt;iterms,
&gt;<i>  +			iterm = list_first_entry(&amp;chain-&gt;iterms,
</I>&gt;<i> struct uvc_entity, chain); pin = iterm-&gt;id; } else if (pin &lt;
</I>&gt;<i> selector-&gt;selector.bNrInPins) { pin =
</I>&gt;<i> selector-&gt;selector.baSourceID[index]; -			list_for_each_entry(iterm,
</I>&gt;<i> video-&gt;iterms.next, chain) { +			list_for_each_entry(iterm,
</I>&gt;<i> chain-&gt;iterms.next, chain) { if (iterm-&gt;id == pin) break; }
</I>&gt;<i> @@ -697,14 +697,14 @@
</I>&gt;<i> {
</I>&gt;<i> u8 input;
</I>&gt;<i>
</I>&gt;<i> -		if (video-&gt;selector == NULL ||
</I>&gt;<i> -		    (video-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
</I>&gt;<i> +		if (chain-&gt;selector == NULL ||
</I>&gt;<i> +		    (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
</I>&gt;<i> *(int *)arg = 0;
</I>&gt;<i> break; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		ret = uvc_query_ctrl(video-&gt;dev, GET_CUR, video-&gt;selector-&gt;id,
</I>&gt;<i> -			video-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> +		ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR, chain-&gt;selector-&gt;id,
</I>&gt;<i> +			chain-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> &amp;input, 1);
</I>&gt;<i> if (ret &lt; 0) return ret; @@ -720,18 +720,18 @@
</I>&gt;<i> if ((ret = uvc_acquire_privileges(handle)) &lt; 0) return ret;
</I>&gt;<i>
</I>&gt;<i> -		if (video-&gt;selector == NULL ||
</I>&gt;<i> -		    (video-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
</I>&gt;<i> +		if (chain-&gt;selector == NULL ||
</I>&gt;<i> +		    (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
</I>&gt;<i> if (input != 1) return -EINVAL; break; }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -		if (input == 0 || input &gt; video-&gt;selector-&gt;selector.bNrInPins)
</I>&gt;<i> +		if (input == 0 || input &gt; chain-&gt;selector-&gt;selector.bNrInPins)
</I>&gt;<i> return -EINVAL;
</I>&gt;<i>
</I>&gt;<i> -		return uvc_query_ctrl(video-&gt;dev, SET_CUR, video-&gt;selector-&gt;id,
</I>&gt;<i> -			video-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> +		return uvc_query_ctrl(chain-&gt;dev, SET_CUR, chain-&gt;selector-&gt;id,
</I>&gt;<i> +			chain-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> &amp;input, 1);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -1064,10 +1064,10 @@
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> case UVCIOC_CTRL_GET: -		return uvc_xu_ctrl_query(video, arg, 0);
</I>&gt;<i> +		return uvc_xu_ctrl_query(chain, arg, 0);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> case UVCIOC_CTRL_SET: -		return uvc_xu_ctrl_query(video, arg, 1);
</I>&gt;<i> +		return uvc_xu_ctrl_query(chain, arg, 1);
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> default:
</I>&gt;<i> if ((ret = v4l_compat_translate_ioctl(file, cmd, arg, diff -r 88ef3b9f5071
</I>&gt;<i> -r 012e480c8e6a linux/drivers/media/video/uvc/uvcvideo.h
</I>&gt;<i> --- a/linux/drivers/media/video/uvc/uvcvideo.h	Sun Jun 28 13:37:50 2009
</I>&gt;<i> +0200
</I>&gt;<i> +++ b/linux/drivers/media/video/uvc/uvcvideo.h	Thu Jul 02 01:24:47 2009
</I>&gt;<i> +0200
</I>&gt;<i> @@ -224,9 +224,11 @@
</I>&gt;<i> #define UVC_ENTITY_IS_UNIT(entity)	(((entity)-&gt;type &amp; 0xff00) == 0)
</I>&gt;<i> #define UVC_ENTITY_IS_TERM(entity)	(((entity)-&gt;type &amp; 0xff00) != 0)
</I>&gt;<i> #define UVC_ENTITY_IS_ITERM(entity) \
</I>&gt;<i> -	(((entity)-&gt;type &amp; 0x8000) == UVC_TERM_INPUT)
</I>&gt;<i> +	(UVC_ENTITY_IS_TERM(entity) &amp;&amp; \
</I>&gt;<i> +	((entity)-&gt;type &amp; 0x8000) == UVC_TERM_INPUT)
</I>&gt;<i> #define UVC_ENTITY_IS_OTERM(entity) \
</I>&gt;<i> -	(((entity)-&gt;type &amp; 0x8000) == UVC_TERM_OUTPUT)
</I>&gt;<i> +	(UVC_ENTITY_IS_TERM(entity) &amp;&amp; \
</I>&gt;<i> +	((entity)-&gt;type &amp; 0x8000) == UVC_TERM_OUTPUT)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> #define UVC_STATUS_TYPE_CONTROL		1
</I>&gt;<i> #define UVC_STATUS_TYPE_STREAMING	2
</I>&gt;<i> @@ -560,10 +562,24 @@
</I>&gt;<i> struct list_head irqqueue; };
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +struct uvc_video_chain {
</I>&gt;<i> +	struct uvc_device *dev;
</I>&gt;<i> +	struct list_head list;
</I>&gt;<i> +
</I>&gt;<i> +	struct list_head iterms;		/* Input terminals */
</I>&gt;<i> +	struct list_head oterms;		/* Output terminals */
</I>&gt;<i> +	struct uvc_entity *processing;		/* Processing unit */
</I>&gt;<i> +	struct uvc_entity *selector;		/* Selector unit */
</I>&gt;<i> +	struct list_head extensions;		/* Extension units */
</I>&gt;<i> +
</I>&gt;<i> +	struct mutex ctrl_mutex;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> struct uvc_streaming { struct list_head list; struct uvc_device *dev;
</I>struct
&gt;<i> video_device *vdev; +	struct uvc_video_chain *chain;
</I>&gt;<i> atomic_t active;
</I>&gt;<i>
</I>&gt;<i> struct usb_interface *intf; @@ -604,18 +620,6 @@
</I>&gt;<i> __u8 last_fid;
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -struct uvc_video_device {
</I>&gt;<i> -	struct uvc_device *dev;
</I>&gt;<i> -
</I>&gt;<i> -	struct list_head iterms;		/* Input terminals */
</I>&gt;<i> -	struct uvc_entity *oterm;		/* Output terminal */
</I>&gt;<i> -	struct uvc_entity *sterm;		/* USB streaming terminal */
</I>&gt;<i> -	struct uvc_entity *processing;
</I>&gt;<i> -	struct uvc_entity *selector;
</I>&gt;<i> -	struct list_head extensions;
</I>&gt;<i> -	struct mutex ctrl_mutex;
</I>&gt;<i> -};
</I>&gt;<i> -
</I>&gt;<i> enum uvc_device_state { UVC_DEV_DISCONNECTED = 1,
</I>&gt;<i> };
</I>&gt;<i> @@ -638,8 +642,7 @@
</I>&gt;<i> __u32 clock_frequency;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> struct list_head entities; -
</I>&gt;<i> -	struct uvc_video_device video;
</I>&gt;<i> +	struct list_head chains;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> /* Video Streaming interfaces */
</I>&gt;<i> struct list_head streams; @@ -658,7 +661,7 @@
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> struct uvc_fh { -	struct uvc_video_device *video;
</I>&gt;<i> +	struct uvc_video_chain *chain;
</I>&gt;<i> struct uvc_streaming *stream; enum uvc_handle_state state; };
</I>&gt;<i> @@ -776,9 +779,9 @@
</I>&gt;<i> extern int uvc_status_resume(struct uvc_device *dev);
</I>&gt;<i>
</I>&gt;<i> /* Controls */
</I>&gt;<i> -extern struct uvc_control *uvc_find_control(struct uvc_video_device
</I>&gt;<i> *video,
</I>&gt;<i> +extern struct uvc_control *uvc_find_control(struct uvc_video_chain
</I>&gt;<i> *chain,
</I>&gt;<i> __u32 v4l2_id, struct uvc_control_mapping **mapping);
</I>&gt;<i> -extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
</I>&gt;<i> +extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
</I>&gt;<i> struct v4l2_queryctrl *v4l2_ctrl);
</I>&gt;<i>
</I>&gt;<i> extern int uvc_ctrl_add_info(struct uvc_control_info *info); @@ -788,23
</I>&gt;<i> +791,23 @@
</I>&gt;<i> extern int uvc_ctrl_resume_device(struct uvc_device *dev); extern void
</I>&gt;<i> uvc_ctrl_init(void);
</I>&gt;<i>
</I>&gt;<i> -extern int uvc_ctrl_begin(struct uvc_video_device *video);
</I>&gt;<i> -extern int __uvc_ctrl_commit(struct uvc_video_device *video, int
</I>&gt;<i> rollback); -static inline int uvc_ctrl_commit(struct uvc_video_device
</I>&gt;<i> *video)
</I>&gt;<i> +extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
</I>&gt;<i> +extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int
</I>&gt;<i> rollback); +static inline int uvc_ctrl_commit(struct uvc_video_chain
</I>&gt;<i> *chain)
</I>&gt;<i> {
</I>&gt;<i> -	return __uvc_ctrl_commit(video, 0);
</I>&gt;<i> +	return __uvc_ctrl_commit(chain, 0);
</I>&gt;<i> }
</I>&gt;<i> -static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
</I>&gt;<i> +static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
</I>&gt;<i> {
</I>&gt;<i> -	return __uvc_ctrl_commit(video, 1);
</I>&gt;<i> +	return __uvc_ctrl_commit(chain, 1);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -extern int uvc_ctrl_get(struct uvc_video_device *video,
</I>&gt;<i> +extern int uvc_ctrl_get(struct uvc_video_chain *chain,
</I>&gt;<i> struct v4l2_ext_control *xctrl); -extern int uvc_ctrl_set(struct
</I>&gt;<i> uvc_video_device *video, +extern int uvc_ctrl_set(struct uvc_video_chain
</I>&gt;<i> *chain,
</I>&gt;<i> struct v4l2_ext_control *xctrl);
</I>&gt;<i>
</I>&gt;<i> -extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
</I>&gt;<i> +extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
</I>&gt;<i> struct uvc_xu_control *ctrl, int set);
</I>&gt;<i>
</I>&gt;<i> /* Utility functions */
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Linux-uvc-devel mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">Linux-uvc-devel at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">https://lists.berlios.de/mailman/listinfo/linux-uvc-devel</A>
</I>&gt;<i>
</I>&gt;<i>
</I>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004943.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support
</A></li>
	<LI>Next message: <A HREF="004952.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4951">[ date ]</a>
              <a href="thread.html#4951">[ thread ]</a>
              <a href="subject.html#4951">[ subject ]</a>
              <a href="author.html#4951">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">More information about the Linux-uvc-devel
mailing list</a><br>
</body></html>
