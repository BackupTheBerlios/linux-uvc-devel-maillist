<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/linux-uvc-devel/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BPATCH%202/2%5D%20uvcvideo%3A%20Multiple%20streaming%0A%09interfaces%20support&In-Reply-To=%3Ca81f87bb0907020950t42e98ad8x7333ff69868cf914%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004959.html">
   <LINK REL="Next"  HREF="004957.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support</H1>
    <B>Brian Pin</B> 
    <A HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BPATCH%202/2%5D%20uvcvideo%3A%20Multiple%20streaming%0A%09interfaces%20support&In-Reply-To=%3Ca81f87bb0907020950t42e98ad8x7333ff69868cf914%40mail.gmail.com%3E"
       TITLE="[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support">shaohuang at gmail.com
       </A><BR>
    <I>Thu Jul  2 18:50:23 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004959.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support
</A></li>
        <LI>Next message: <A HREF="004957.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4955">[ date ]</a>
              <a href="thread.html#4955">[ thread ]</a>
              <a href="subject.html#4955">[ subject ]</a>
              <a href="author.html#4955">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I think 1) you should do the patch under Linux top dir not uvc dir.2) use
patch -p1 &lt; the_patch
That probably helps..

On Thu, Jul 2, 2009 at 8:34 AM, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">lescopc at esiee.fr</A>&gt; wrote:

&gt;<i> Hello everyone,
</I>&gt;<i>
</I>&gt;<i> I am trying to stream with 2 webcams simultaneously so I tried your patch.
</I>&gt;<i> The thing is I am not that good with Linux so.... didn't work. Here what I
</I>&gt;<i> did:
</I>&gt;<i>
</I>&gt;<i> **I downloaded your source from:
</I>&gt;<i> <A HREF="http://linuxtv.org/hg/~pinchartl/uvcvideo/">http://linuxtv.org/hg/~pinchartl/uvcvideo/</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> **I copied/pasted the content of this mail and the second one started from:
</I>&gt;<i>
</I>&gt;<i> diff -r 88ef3b9f5071 -r 012e480c8e6a
</I>&gt;<i> linux/drivers/media/video/uvc/uvc_ctrl.c
</I>&gt;<i>
</I>&gt;<i> till the end to files that I named patchOne.diff and patchTwo.diff
</I>&gt;<i>
</I>&gt;<i> **Then, in a terminal, I went to:
</I>&gt;<i> uvcvideo-bff77ec33116/linux/drivers/media/video/uvc
</I>&gt;<i>
</I>&gt;<i> **I did:
</I>&gt;<i> patch &lt;patchOne.diff
</I>&gt;<i>
</I>&gt;<i> It did not changed the content of the original files and I got:
</I>&gt;<i> patching file uvc_driver.c
</I>&gt;<i> Hunk #1 FAILED at 551.
</I>&gt;<i> Hunk #2 FAILED at 752.
</I>&gt;<i> Hunk #3 FAILED at 1167.
</I>&gt;<i> Hunk #5 FAILED at 1494.
</I>&gt;<i> Hunk #6 FAILED at 1515.
</I>&gt;<i> Hunk #7 FAILED at 1530.
</I>&gt;<i> Hunk #8 FAILED at 1568.
</I>&gt;<i> Hunk #9 FAILED at 1602.
</I>&gt;<i> Hunk #10 FAILED at 1643.
</I>&gt;<i> Hunk #11 FAILED at 1697.
</I>&gt;<i> Hunk #12 FAILED at 1706.
</I>&gt;<i> Hunk #13 FAILED at 1735.
</I>&gt;<i> 12 out of 13 hunks FAILED -- saving rejects to file uvc_driver.c.rej
</I>&gt;<i> patching file uvc_isight.c
</I>&gt;<i> Hunk #1 FAILED at 99.
</I>&gt;<i> Hunk #2 FAILED at 120.
</I>&gt;<i> etc...
</I>&gt;<i>
</I>&gt;<i> Can anyone tell me what I am doing wrong?
</I>&gt;<i> Regards,
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> LESCOP C&#233;dric
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Thu, July 2, 2009 01:31, Laurent Pinchart wrote:
</I>&gt;<i> &gt; Restructure the UVC descriptors parsing code to handle multiple streaming
</I>&gt;<i> &gt;  interfaces. The driver now creates a uvc_video_chain instance for each
</I>&gt;<i> &gt; chain detected in the UVC control interface descriptors, and tries to
</I>&gt;<i> &gt; register one video device per streaming endpoint.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Priority: normal
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Signed-off-by: Laurent Pinchart &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">laurent.pinchart at skynet.be</A>&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; diff -r 88ef3b9f5071 -r 012e480c8e6a
</I>&gt;<i> &gt; linux/drivers/media/video/uvc/uvc_ctrl.c ---
</I>&gt;<i> &gt; a/linux/drivers/media/video/uvc/uvc_ctrl.c    Sun Jun 28 13:37:50 2009
</I>&gt;<i> +0200
</I>&gt;<i> &gt;  +++ b/linux/drivers/media/video/uvc/uvc_ctrl.c       Thu Jul 02 01:24:47
</I>&gt;<i> 2009
</I>&gt;<i> &gt; +0200
</I>&gt;<i> &gt; @@ -731,7 +731,7 @@
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -struct uvc_control *uvc_find_control(struct uvc_video_device *video,
</I>&gt;<i> &gt; +struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; __u32 v4l2_id, struct uvc_control_mapping **mapping)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; struct uvc_control *ctrl = NULL; @@ -744,17 +744,17 @@
</I>&gt;<i> &gt; v4l2_id &amp;= V4L2_CTRL_ID_MASK;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Find the control. */
</I>&gt;<i> &gt; -     __uvc_find_control(video-&gt;processing, v4l2_id, mapping, &amp;ctrl,
</I>&gt;<i> next);
</I>&gt;<i> &gt; +     __uvc_find_control(chain-&gt;processing, v4l2_id, mapping, &amp;ctrl,
</I>&gt;<i> next);
</I>&gt;<i> &gt; if (ctrl &amp;&amp; !next) return ctrl;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     list_for_each_entry(entity, &amp;video-&gt;iterms, chain) {
</I>&gt;<i> &gt; +     list_for_each_entry(entity, &amp;chain-&gt;iterms, chain) {
</I>&gt;<i> &gt; __uvc_find_control(entity, v4l2_id, mapping, &amp;ctrl, next);
</I>&gt;<i> &gt; if (ctrl &amp;&amp; !next) return ctrl; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
</I>&gt;<i> &gt; +     list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
</I>&gt;<i> &gt; __uvc_find_control(entity, v4l2_id, mapping, &amp;ctrl, next);
</I>&gt;<i> &gt; if (ctrl &amp;&amp; !next) return ctrl; @@ -767,7 +767,7 @@
</I>&gt;<i> &gt; return ctrl; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
</I>&gt;<i> &gt; +int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct v4l2_queryctrl *v4l2_ctrl) {
</I>&gt;<i> &gt; struct uvc_control *ctrl; @@ -777,7 +777,7 @@
</I>&gt;<i> &gt; __u8 *data;
</I>&gt;<i> &gt; int ret;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     ctrl = uvc_find_control(video, v4l2_ctrl-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; +     ctrl = uvc_find_control(chain, v4l2_ctrl-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; if (ctrl == NULL) return -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @@ -795,9 +795,10 @@
</I>&gt;<i> &gt; v4l2_ctrl-&gt;flags |= V4L2_CTRL_FLAG_READ_ONLY;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_DEF) { -              if ((ret =
</I>&gt;<i> &gt; uvc_query_ctrl(video-&gt;dev, GET_DEF, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> &gt; video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -
</I>&gt;<i>  data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> &gt; 0)
</I>&gt;<i> &gt; +             ret = uvc_query_ctrl(chain-&gt;dev, GET_DEF, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> &gt; +                                  chain-&gt;dev-&gt;intfnum,
</I>&gt;<i> ctrl-&gt;info-&gt;selector,
</I>&gt;<i> &gt; +                                  data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> &gt; +             if (ret &lt; 0)
</I>&gt;<i> &gt; goto out; v4l2_ctrl-&gt;default_value = mapping-&gt;get(mapping, GET_DEF,
</I>&gt;<i> data); }
</I>&gt;<i> &gt;  @@ -831,23 +832,26 @@
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_MIN) { -              if ((ret =
</I>&gt;<i> &gt; uvc_query_ctrl(video-&gt;dev, GET_MIN, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> &gt; video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -
</I>&gt;<i>  data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> &gt; 0)
</I>&gt;<i> &gt; +             ret = uvc_query_ctrl(chain-&gt;dev, GET_MIN, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> &gt; +                                  chain-&gt;dev-&gt;intfnum,
</I>&gt;<i> ctrl-&gt;info-&gt;selector,
</I>&gt;<i> &gt; +                                  data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> &gt; +             if (ret &lt; 0)
</I>&gt;<i> &gt; goto out; v4l2_ctrl-&gt;minimum = mapping-&gt;get(mapping, GET_MIN, data); }
</I>&gt;<i> &gt; if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_MAX) { -              if ((ret =
</I>&gt;<i> &gt; uvc_query_ctrl(video-&gt;dev, GET_MAX, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> &gt; video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -
</I>&gt;<i>  data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> &gt; 0)
</I>&gt;<i> &gt; +             ret = uvc_query_ctrl(chain-&gt;dev, GET_MAX, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> &gt; +                                  chain-&gt;dev-&gt;intfnum,
</I>&gt;<i> ctrl-&gt;info-&gt;selector,
</I>&gt;<i> &gt; +                                  data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> &gt; +             if (ret &lt; 0)
</I>&gt;<i> &gt; goto out; v4l2_ctrl-&gt;maximum = mapping-&gt;get(mapping, GET_MAX, data); }
</I>&gt;<i> &gt; if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_RES) { -              if ((ret =
</I>&gt;<i> &gt; uvc_query_ctrl(video-&gt;dev, GET_RES, ctrl-&gt;entity-&gt;id, -
</I>&gt;<i> &gt; video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector, -
</I>&gt;<i>  data, ctrl-&gt;info-&gt;size)) &lt;
</I>&gt;<i> &gt; 0)
</I>&gt;<i> &gt; +             ret = uvc_query_ctrl(chain-&gt;dev, GET_RES, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> &gt; +                                  chain-&gt;dev-&gt;intfnum,
</I>&gt;<i> ctrl-&gt;info-&gt;selector,
</I>&gt;<i> &gt; +                                  data, ctrl-&gt;info-&gt;size);
</I>&gt;<i> &gt; +             if (ret &lt; 0)
</I>&gt;<i> &gt; goto out; v4l2_ctrl-&gt;step = mapping-&gt;get(mapping, GET_RES, data); }
</I>&gt;<i> &gt; @@ -883,9 +887,9 @@
</I>&gt;<i> &gt; * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release
</I>&gt;<i> &gt; the * control lock.
</I>&gt;<i> &gt; */
</I>&gt;<i> &gt; -int uvc_ctrl_begin(struct uvc_video_device *video)
</I>&gt;<i> &gt; +int uvc_ctrl_begin(struct uvc_video_chain *chain)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; -     return mutex_lock_interruptible(&amp;video-&gt;ctrl_mutex) ? -ERESTARTSYS
</I>&gt;<i> : 0;
</I>&gt;<i> &gt; +     return mutex_lock_interruptible(&amp;chain-&gt;ctrl_mutex) ? -ERESTARTSYS
</I>&gt;<i> : 0;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; static int uvc_ctrl_commit_entity(struct uvc_device *dev, @@ -935,34
</I>&gt;<i> &gt; +939,34 @@
</I>&gt;<i> &gt; return 0; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
</I>&gt;<i> &gt; +int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; struct uvc_entity *entity; int ret = 0;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Find the control. */
</I>&gt;<i> &gt; -     ret = uvc_ctrl_commit_entity(video-&gt;dev, video-&gt;processing,
</I>&gt;<i> rollback);
</I>&gt;<i> &gt; +     ret = uvc_ctrl_commit_entity(chain-&gt;dev, chain-&gt;processing,
</I>&gt;<i> rollback);
</I>&gt;<i> &gt; if (ret &lt; 0) goto done;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     list_for_each_entry(entity, &amp;video-&gt;iterms, chain) {
</I>&gt;<i> &gt; -             ret = uvc_ctrl_commit_entity(video-&gt;dev, entity, rollback);
</I>&gt;<i> &gt; +     list_for_each_entry(entity, &amp;chain-&gt;iterms, chain) {
</I>&gt;<i> &gt; +             ret = uvc_ctrl_commit_entity(chain-&gt;dev, entity, rollback);
</I>&gt;<i> &gt; if (ret &lt; 0) goto done; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
</I>&gt;<i> &gt; -             ret = uvc_ctrl_commit_entity(video-&gt;dev, entity, rollback);
</I>&gt;<i> &gt; +     list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
</I>&gt;<i> &gt; +             ret = uvc_ctrl_commit_entity(chain-&gt;dev, entity, rollback);
</I>&gt;<i> &gt; if (ret &lt; 0) goto done; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; done:
</I>&gt;<i> &gt; -     mutex_unlock(&amp;video-&gt;ctrl_mutex);
</I>&gt;<i> &gt; +     mutex_unlock(&amp;chain-&gt;ctrl_mutex);
</I>&gt;<i> &gt; return ret; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -int uvc_ctrl_get(struct uvc_video_device *video,
</I>&gt;<i> &gt; +int uvc_ctrl_get(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct v4l2_ext_control *xctrl) {
</I>&gt;<i> &gt; struct uvc_control *ctrl; @@ -971,13 +975,13 @@
</I>&gt;<i> &gt; unsigned int i; int ret;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     ctrl = uvc_find_control(video, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; +     ctrl = uvc_find_control(chain, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; if (ctrl == NULL || (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_CUR) == 0)
</I>&gt;<i> return
</I>&gt;<i> &gt; -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if (!ctrl-&gt;loaded) { -                ret = uvc_query_ctrl(video-&gt;dev,
</I>&gt;<i> GET_CUR,
</I>&gt;<i> &gt; ctrl-&gt;entity-&gt;id, -                           video-&gt;dev-&gt;intfnum,
</I>&gt;<i> ctrl-&gt;info-&gt;selector,
</I>&gt;<i> &gt; +             ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR, ctrl-&gt;entity-&gt;id,
</I>&gt;<i> &gt; +                             chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
</I>&gt;<i> &gt; uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), ctrl-&gt;info-&gt;size); if (ret &lt;
</I>&gt;<i> 0)
</I>&gt;<i> &gt; @@ -1002,7 +1006,7 @@
</I>&gt;<i> &gt; return 0; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -int uvc_ctrl_set(struct uvc_video_device *video,
</I>&gt;<i> &gt; +int uvc_ctrl_set(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct v4l2_ext_control *xctrl) {
</I>&gt;<i> &gt; struct uvc_control *ctrl; @@ -1010,7 +1014,7 @@
</I>&gt;<i> &gt; s32 value = xctrl-&gt;value; int ret;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     ctrl = uvc_find_control(video, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; +     ctrl = uvc_find_control(chain, xctrl-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; if (ctrl == NULL || (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_SET_CUR) == 0)
</I>&gt;<i> return
</I>&gt;<i> &gt; -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @@ -1025,8 +1029,8 @@
</I>&gt;<i> &gt; memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT), 0, ctrl-&gt;info-&gt;size);
</I>&gt;<i> &gt; } else {
</I>&gt;<i> &gt; -                     ret = uvc_query_ctrl(video-&gt;dev, GET_CUR,
</I>&gt;<i> &gt; -                             ctrl-&gt;entity-&gt;id, video-&gt;dev-&gt;intfnum,
</I>&gt;<i> &gt; +                     ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR,
</I>&gt;<i> &gt; +                             ctrl-&gt;entity-&gt;id, chain-&gt;dev-&gt;intfnum,
</I>&gt;<i> &gt; ctrl-&gt;info-&gt;selector, uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
</I>&gt;<i> &gt; ctrl-&gt;info-&gt;size); @@ -1055,7 +1059,7 @@
</I>&gt;<i> &gt; * Dynamic controls
</I>&gt;<i> &gt; */
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -int uvc_xu_ctrl_query(struct uvc_video_device *video,
</I>&gt;<i> &gt; +int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct uvc_xu_control *xctrl, int set) {
</I>&gt;<i> &gt; struct uvc_entity *entity; @@ -1065,7 +1069,7 @@
</I>&gt;<i> &gt; int ret;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Find the extension unit. */
</I>&gt;<i> &gt; -     list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
</I>&gt;<i> &gt; +     list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
</I>&gt;<i> &gt; if (entity-&gt;id == xctrl-&gt;unit) break; }
</I>&gt;<i> &gt; @@ -1104,7 +1108,7 @@
</I>&gt;<i> &gt; (!set &amp;&amp; !(ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_CUR)))
</I>&gt;<i> &gt; return -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     if (mutex_lock_interruptible(&amp;video-&gt;ctrl_mutex))
</I>&gt;<i> &gt; +     if (mutex_lock_interruptible(&amp;chain-&gt;ctrl_mutex))
</I>&gt;<i> &gt; return -ERESTARTSYS;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), @@ -1117,8 +1121,8 @@
</I>&gt;<i> &gt; goto out; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     ret = uvc_query_ctrl(video-&gt;dev, set ? SET_CUR : GET_CUR,
</I>&gt;<i> xctrl-&gt;unit,
</I>&gt;<i> &gt; -                          video-&gt;dev-&gt;intfnum, xctrl-&gt;selector, data,
</I>&gt;<i> &gt; +     ret = uvc_query_ctrl(chain-&gt;dev, set ? SET_CUR : GET_CUR,
</I>&gt;<i> xctrl-&gt;unit,
</I>&gt;<i> &gt; +                          chain-&gt;dev-&gt;intfnum, xctrl-&gt;selector, data,
</I>&gt;<i> &gt; xctrl-&gt;size); if (ret &lt; 0) goto out; @@ -1134,7 +1138,7 @@
</I>&gt;<i> &gt; uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP), xctrl-&gt;size);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     mutex_unlock(&amp;video-&gt;ctrl_mutex);
</I>&gt;<i> &gt; +     mutex_unlock(&amp;chain-&gt;ctrl_mutex);
</I>&gt;<i> &gt; return ret; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; diff -r 88ef3b9f5071 -r 012e480c8e6a
</I>&gt;<i> &gt; linux/drivers/media/video/uvc/uvc_driver.c ---
</I>&gt;<i> &gt; a/linux/drivers/media/video/uvc/uvc_driver.c  Sun Jun 28 13:37:50 2009
</I>&gt;<i> &gt; +0200
</I>&gt;<i> &gt; +++ b/linux/drivers/media/video/uvc/uvc_driver.c      Thu Jul 02 01:24:47
</I>&gt;<i> 2009
</I>&gt;<i> &gt; +0200
</I>&gt;<i> &gt; @@ -276,8 +276,20 @@
</I>&gt;<i> &gt; return NULL; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev,
</I>&gt;<i> &gt; int id) +{
</I>&gt;<i> &gt; +     struct uvc_streaming *stream;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
</I>&gt;<i> &gt; +             if (stream-&gt;header.bTerminalLink == id)
</I>&gt;<i> &gt; +                     return stream;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     return NULL;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; /*
</I>&gt;<i> &gt; ------------------------------------------------------------------------
</I>&gt;<i> &gt; - * Descriptors handling
</I>&gt;<i> &gt; + * Descriptors parsing
</I>&gt;<i> &gt; */
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; static int uvc_parse_format(struct uvc_device *dev, @@ -1159,101 +1171,36
</I>&gt;<i> &gt; @@
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /*
</I>&gt;<i> &gt; ------------------------------------------------------------------------
</I>&gt;<i> &gt; - * USB probe and disconnect
</I>&gt;<i> &gt; + * UVC device scan
</I>&gt;<i> &gt; */
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /*
</I>&gt;<i> &gt; - * Unregister the video devices.
</I>&gt;<i> &gt; - */
</I>&gt;<i> &gt; -static void uvc_unregister_video(struct uvc_device *dev)
</I>&gt;<i> &gt; -{
</I>&gt;<i> &gt; -     struct uvc_streaming *streaming;
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     list_for_each_entry(streaming, &amp;dev-&gt;streams, list) {
</I>&gt;<i> &gt; -             if (streaming-&gt;vdev == NULL)
</I>&gt;<i> &gt; -                     continue;
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -             if (streaming-&gt;vdev-&gt;minor == -1)
</I>&gt;<i> &gt; -                     video_device_release(streaming-&gt;vdev);
</I>&gt;<i> &gt; -             else
</I>&gt;<i> &gt; -                     video_unregister_device(streaming-&gt;vdev);
</I>&gt;<i> &gt; -             streaming-&gt;vdev = NULL;
</I>&gt;<i> &gt; -     }
</I>&gt;<i> &gt; -}
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -static int uvc_register_video(struct uvc_device *dev,
</I>&gt;<i> &gt; -             struct uvc_streaming *stream)
</I>&gt;<i> &gt; -{
</I>&gt;<i> &gt; -     struct video_device *vdev;
</I>&gt;<i> &gt; -     struct uvc_entity *term;
</I>&gt;<i> &gt; -     int ret;
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> &gt; -             uvc_printk(KERN_INFO, &quot;Found a valid video chain (&quot;);
</I>&gt;<i> &gt; -             list_for_each_entry(term, &amp;dev-&gt;video.iterms, chain) {
</I>&gt;<i> &gt; -                     printk(&quot;%d&quot;, term-&gt;id);
</I>&gt;<i> &gt; -                     if (term-&gt;chain.next != &amp;dev-&gt;video.iterms)
</I>&gt;<i> &gt; -                             printk(&quot;,&quot;);
</I>&gt;<i> &gt; -             }
</I>&gt;<i> &gt; -             printk(&quot; -&gt; %d).\n&quot;, dev-&gt;video.oterm-&gt;id);
</I>&gt;<i> &gt; -     }
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     /* Initialize the streaming interface with default streaming
</I>&gt;<i> &gt; -      * parameters.
</I>&gt;<i> &gt; -      */
</I>&gt;<i> &gt; -     ret = uvc_video_init(stream);
</I>&gt;<i> &gt; -     if (ret &lt; 0) {
</I>&gt;<i> &gt; -             uvc_printk(KERN_ERR, &quot;Failed to initialize the device &quot;
</I>&gt;<i> &gt; -                     &quot;(%d).\n&quot;, ret);
</I>&gt;<i> &gt; -             return ret;
</I>&gt;<i> &gt; -     }
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     /* Register the device with V4L. */
</I>&gt;<i> &gt; -     vdev = video_device_alloc();
</I>&gt;<i> &gt; -     if (vdev == NULL)
</I>&gt;<i> &gt; -             return -1;
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     /* We already hold a reference to dev-&gt;udev. The video device will
</I>&gt;<i> be
</I>&gt;<i> &gt; -      * unregistered before the reference is released, so we don't need
</I>&gt;<i> to
</I>&gt;<i> &gt; -      * get another one.
</I>&gt;<i> &gt; -      */
</I>&gt;<i> &gt; -     vdev-&gt;parent = &amp;dev-&gt;intf-&gt;dev;
</I>&gt;<i> &gt; -     vdev-&gt;minor = -1;
</I>&gt;<i> &gt; -     vdev-&gt;fops = &amp;uvc_fops;
</I>&gt;<i> &gt; -     vdev-&gt;release = video_device_release;
</I>&gt;<i> &gt; -     strlcpy(vdev-&gt;name, dev-&gt;name, sizeof vdev-&gt;name);
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     /* Set the driver data before calling video_register_device,
</I>&gt;<i> otherwise
</I>&gt;<i> &gt; -      * uvc_v4l2_open might race us.
</I>&gt;<i> &gt; -      */
</I>&gt;<i> &gt; -     stream-&gt;vdev = vdev;
</I>&gt;<i> &gt; -     video_set_drvdata(vdev, stream);
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) &lt; 0) {
</I>&gt;<i> &gt; -             stream-&gt;vdev = NULL;
</I>&gt;<i> &gt; -             video_device_release(vdev);
</I>&gt;<i> &gt; -             return -1;
</I>&gt;<i> &gt; -     }
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     return 0;
</I>&gt;<i> &gt; -}
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -/*
</I>&gt;<i> &gt; * Scan the UVC descriptors to locate a chain starting at an Output
</I>&gt;<i> &gt; Terminal
</I>&gt;<i> &gt; * and containing the following units:
</I>&gt;<i> &gt; *
</I>&gt;<i> &gt; - * - one Output Terminal (USB Streaming or Display)
</I>&gt;<i> &gt; + * - one or more Output Terminals (USB Streaming or Display)
</I>&gt;<i> &gt; * - zero or one Processing Unit
</I>&gt;<i> &gt; - * - zero, one or mode single-input Selector Units
</I>&gt;<i> &gt; + * - zero, one or more single-input Selector Units
</I>&gt;<i> &gt; * - zero or one multiple-input Selector Units, provided all inputs are
</I>&gt;<i> &gt; *   connected to input terminals
</I>&gt;<i> &gt; * - zero, one or mode single-input Extension Units
</I>&gt;<i> &gt; * - one or more Input Terminals (Camera, External or USB Streaming)
</I>&gt;<i> &gt; *
</I>&gt;<i> &gt; - * A side forward scan is made on each detected entity to check for
</I>&gt;<i> &gt; additional - * extension units.
</I>&gt;<i> &gt; + * The terminal and units must match on of the following structures:
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * ITT_*(0) -&gt; +---------+    +---------+    +---------+ -&gt;
</I>&gt;<i> &gt; TT_STREAMING(0)
</I>&gt;<i> &gt; + * ...         | SU{0,1} | -&gt; | PU{0,1} | -&gt; | XU{0,n} |    ...
</I>&gt;<i> &gt; + * ITT_*(n) -&gt; +---------+    +---------+    +---------+ -&gt;
</I>&gt;<i> &gt; TT_STREAMING(n)
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + *                 +---------+    +---------+ -&gt; OTT_*(0)
</I>&gt;<i> &gt; + * TT_STREAMING -&gt; | PU{0,1} | -&gt; | XU{0,n} |    ...
</I>&gt;<i> &gt; + *                 +---------+    +---------+ -&gt; OTT_*(n)
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * The Processing Unit and Extension Units can be in any order.
</I>&gt;<i> &gt; Additional
</I>&gt;<i> &gt; + * Extension Units connected to the main chain as single-unit branches
</I>&gt;<i> &gt; are + * also supported. Single-input Selector Units are ignored.
</I>&gt;<i> &gt; */
</I>&gt;<i> &gt; -static int uvc_scan_chain_entity(struct uvc_video_device *video,
</I>&gt;<i> &gt; +static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct uvc_entity *entity) {
</I>&gt;<i> &gt; switch (UVC_ENTITY_TYPE(entity)) { @@ -1267,20 +1214,20 @@
</I>&gt;<i> &gt; return -1; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;extensions);
</I>&gt;<i> &gt; +             list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;extensions);
</I>&gt;<i> &gt; break;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case VC_PROCESSING_UNIT: if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot;
</I>&gt;<i> &lt;-
</I>&gt;<i> &gt; PU %d&quot;, entity-&gt;id);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             if (video-&gt;processing != NULL) {
</I>&gt;<i> &gt; +             if (chain-&gt;processing != NULL) {
</I>&gt;<i> &gt; uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple &quot; &quot;Processing Units in
</I>&gt;<i> &gt; chain.\n&quot;); return -1; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             video-&gt;processing = entity;
</I>&gt;<i> &gt; +             chain-&gt;processing = entity;
</I>&gt;<i> &gt; break;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case VC_SELECTOR_UNIT: @@ -1291,13 +1238,13 @@
</I>&gt;<i> &gt; if (entity-&gt;selector.bNrInPins == 1) break;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             if (video-&gt;selector != NULL) {
</I>&gt;<i> &gt; +             if (chain-&gt;selector != NULL) {
</I>&gt;<i> &gt; uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple Selector &quot; &quot;Units in
</I>&gt;<i> chain.\n&quot;);
</I>&gt;<i> &gt;  return -1; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             video-&gt;selector = entity;
</I>&gt;<i> &gt; +             chain-&gt;selector = entity;
</I>&gt;<i> &gt; break;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case ITT_VENDOR_SPECIFIC: @@ -1306,7 +1253,7 @@
</I>&gt;<i> &gt; if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot; &lt;- IT %d\n&quot;, entity-&gt;id);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;iterms);
</I>&gt;<i> &gt; +             list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;iterms);
</I>&gt;<i> &gt; break;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case TT_STREAMING: @@ -1319,14 +1266,7 @@
</I>&gt;<i> &gt; return -1; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             if (video-&gt;sterm != NULL) {
</I>&gt;<i> &gt; -                     uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple
</I>&gt;<i> streaming &quot;
</I>&gt;<i> &gt; -                             &quot;entities in chain.\n&quot;);
</I>&gt;<i> &gt; -                     return -1;
</I>&gt;<i> &gt; -             }
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -             list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;iterms);
</I>&gt;<i> &gt; -             video-&gt;sterm = entity;
</I>&gt;<i> &gt; +             list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;iterms);
</I>&gt;<i> &gt; break;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; default:
</I>&gt;<i> &gt; @@ -1338,7 +1278,7 @@
</I>&gt;<i> &gt; return 0; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -static int uvc_scan_chain_forward(struct uvc_video_device *video,
</I>&gt;<i> &gt; +static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct uvc_entity *entity, struct uvc_entity *prev) {
</I>&gt;<i> &gt; struct uvc_entity *forward; @@ -1349,28 +1289,51 @@
</I>&gt;<i> &gt; found = 0;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; while (1) { -         forward = uvc_entity_by_reference(video-&gt;dev,
</I>&gt;<i> entity-&gt;id,
</I>&gt;<i> &gt; +             forward = uvc_entity_by_reference(chain-&gt;dev, entity-&gt;id,
</I>&gt;<i> &gt; forward); if (forward == NULL) break; -
</I>&gt;<i> &gt; -             if (UVC_ENTITY_TYPE(forward) != VC_EXTENSION_UNIT ||
</I>&gt;<i> &gt; -                 forward == prev)
</I>&gt;<i> &gt; +             if (forward == prev)
</I>&gt;<i> &gt; continue;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             if (forward-&gt;extension.bNrInPins != 1) {
</I>&gt;<i> &gt; -                     uvc_trace(UVC_TRACE_DESCR, &quot;Extension unit %d has &quot;
</I>&gt;<i> &gt; -                             &quot;more than 1 input pin.\n&quot;, entity-&gt;id);
</I>&gt;<i> &gt; -                     return -1;
</I>&gt;<i> &gt; -             }
</I>&gt;<i> &gt; +             switch (UVC_ENTITY_TYPE(forward)) {
</I>&gt;<i> &gt; +             case VC_EXTENSION_UNIT:
</I>&gt;<i> &gt; +                     if (forward-&gt;extension.bNrInPins != 1) {
</I>&gt;<i> &gt; +                             uvc_trace(UVC_TRACE_DESCR, &quot;Extension unit
</I>&gt;<i> %d &quot;
</I>&gt;<i> &gt; +                                       &quot;has more than 1 input pin.\n&quot;,
</I>&gt;<i> &gt; +                                       entity-&gt;id);
</I>&gt;<i> &gt; +                             return -EINVAL;
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             list_add_tail(&amp;forward-&gt;chain, &amp;video-&gt;extensions);
</I>&gt;<i> &gt; -             if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> &gt; -                     if (!found)
</I>&gt;<i> &gt; -                             printk(&quot; (-&gt; XU&quot;);
</I>&gt;<i> &gt; +                     list_add_tail(&amp;forward-&gt;chain, &amp;chain-&gt;extensions);
</I>&gt;<i> &gt; +                     if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> &gt; +                             if (!found)
</I>&gt;<i> &gt; +                                     printk(&quot; (-&gt;&quot;);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -                     printk(&quot; %d&quot;, forward-&gt;id);
</I>&gt;<i> &gt; -                     found = 1;
</I>&gt;<i> &gt; +                             printk(&quot; XU %d&quot;, forward-&gt;id);
</I>&gt;<i> &gt; +                             found = 1;
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt; +                     break;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             case OTT_VENDOR_SPECIFIC:
</I>&gt;<i> &gt; +             case OTT_DISPLAY:
</I>&gt;<i> &gt; +             case OTT_MEDIA_TRANSPORT_OUTPUT:
</I>&gt;<i> &gt; +             case TT_STREAMING:
</I>&gt;<i> &gt; +                     if (UVC_ENTITY_IS_ITERM(forward)) {
</I>&gt;<i> &gt; +                             uvc_trace(UVC_TRACE_DESCR, &quot;Unsupported
</I>&gt;<i> input &quot;
</I>&gt;<i> &gt; +                                     &quot;terminal %u.\n&quot;, forward-&gt;id);
</I>&gt;<i> &gt; +                             return -EINVAL;
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                     list_add_tail(&amp;forward-&gt;chain, &amp;chain-&gt;oterms);
</I>&gt;<i> &gt; +                     if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
</I>&gt;<i> &gt; +                             if (!found)
</I>&gt;<i> &gt; +                                     printk(&quot; (-&gt;&quot;);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +                             printk(&quot; OT %d&quot;, forward-&gt;id);
</I>&gt;<i> &gt; +                             found = 1;
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt; +                     break;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; if (found) @@ -1379,7 +1342,7 @@
</I>&gt;<i> &gt; return 0; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -static int uvc_scan_chain_backward(struct uvc_video_device *video,
</I>&gt;<i> &gt; +static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct uvc_entity *entity) {
</I>&gt;<i> &gt; struct uvc_entity *term; @@ -1404,10 +1367,10 @@
</I>&gt;<i> &gt; if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot; &lt;- IT&quot;);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             video-&gt;selector = entity;
</I>&gt;<i> &gt; +             chain-&gt;selector = entity;
</I>&gt;<i> &gt; for (i = 0; i &lt; entity-&gt;selector.bNrInPins; ++i) { id =
</I>&gt;<i> &gt; entity-&gt;selector.baSourceID[i]; -                     term =
</I>&gt;<i> uvc_entity_by_id(video-&gt;dev,
</I>&gt;<i> &gt; id); +                        term = uvc_entity_by_id(chain-&gt;dev, id);
</I>&gt;<i> &gt; if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
</I>&gt;<i> &gt; uvc_trace(UVC_TRACE_DESCR, &quot;Selector unit %d &quot; &quot;input %d isn't connected
</I>&gt;<i> &gt; to an &quot; @@ -1418,8 +1381,8 @@
</I>&gt;<i> &gt; if (uvc_trace_param &amp; UVC_TRACE_PROBE) printk(&quot; %d&quot;, term-&gt;id);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -                     list_add_tail(&amp;term-&gt;chain, &amp;video-&gt;iterms);
</I>&gt;<i> &gt; -                     uvc_scan_chain_forward(video, term, entity);
</I>&gt;<i> &gt; +                     list_add_tail(&amp;term-&gt;chain, &amp;chain-&gt;iterms);
</I>&gt;<i> &gt; +                     uvc_scan_chain_forward(chain, term, entity);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if (uvc_trace_param &amp; UVC_TRACE_PROBE) @@ -1432,108 +1395,264 @@
</I>&gt;<i> &gt; return id; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -static int uvc_scan_chain(struct uvc_video_device *video)
</I>&gt;<i> &gt; +static int uvc_scan_chain(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; +                       struct uvc_entity *oterm)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; struct uvc_entity *entity, *prev; int id;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     entity = video-&gt;oterm;
</I>&gt;<i> &gt; +     entity = oterm;
</I>&gt;<i> &gt; +     list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;oterms);
</I>&gt;<i> &gt; uvc_trace(UVC_TRACE_PROBE, &quot;Scanning UVC chain: OT %d&quot;, entity-&gt;id);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     if (UVC_ENTITY_TYPE(entity) == TT_STREAMING)
</I>&gt;<i> &gt; -             video-&gt;sterm = entity;
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; id = entity-&gt;output.bSourceID; while (id != 0) { prev = entity; -
</I>&gt;<i>     entity =
</I>&gt;<i> &gt; uvc_entity_by_id(video-&gt;dev, id); +           entity =
</I>&gt;<i> uvc_entity_by_id(chain-&gt;dev,
</I>&gt;<i> &gt; id); if (entity == NULL) { uvc_trace(UVC_TRACE_DESCR, &quot;Found reference to
</I>&gt;<i> &quot;
</I>&gt;<i> &gt;  &quot;unknown entity %d.\n&quot;, id);
</I>&gt;<i> &gt; -                     return -1;
</I>&gt;<i> &gt; +                     return -EINVAL;
</I>&gt;<i> &gt; +             }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             if (entity-&gt;chain.next || entity-&gt;chain.prev) {
</I>&gt;<i> &gt; +                     uvc_trace(UVC_TRACE_DESCR, &quot;Found reference to &quot;
</I>&gt;<i> &gt; +                             &quot;entity %d already in chain.\n&quot;, id);
</I>&gt;<i> &gt; +                     return -EINVAL;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Process entity */
</I>&gt;<i> &gt; -             if (uvc_scan_chain_entity(video, entity) &lt; 0)
</I>&gt;<i> &gt; -                     return -1;
</I>&gt;<i> &gt; +             if (uvc_scan_chain_entity(chain, entity) &lt; 0)
</I>&gt;<i> &gt; +                     return -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Forward scan */
</I>&gt;<i> &gt; -             if (uvc_scan_chain_forward(video, entity, prev) &lt; 0)
</I>&gt;<i> &gt; -                     return -1;
</I>&gt;<i> &gt; +             if (uvc_scan_chain_forward(chain, entity, prev) &lt; 0)
</I>&gt;<i> &gt; +                     return -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Stop when a terminal is found. */
</I>&gt;<i> &gt; -             if (!UVC_ENTITY_IS_UNIT(entity))
</I>&gt;<i> &gt; +             if (UVC_ENTITY_IS_TERM(entity))
</I>&gt;<i> &gt; break;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Backward scan */
</I>&gt;<i> &gt; -             id = uvc_scan_chain_backward(video, entity);
</I>&gt;<i> &gt; +             id = uvc_scan_chain_backward(chain, entity);
</I>&gt;<i> &gt; if (id &lt; 0) return id; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     if (video-&gt;sterm == NULL) {
</I>&gt;<i> &gt; -             uvc_trace(UVC_TRACE_DESCR, &quot;No streaming entity found in &quot;
</I>&gt;<i> &gt; -                     &quot;chain.\n&quot;);
</I>&gt;<i> &gt; +     return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static unsigned int uvc_print_terms(struct list_head *terms, char
</I>&gt;<i> &gt; *buffer)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     struct uvc_entity *term;
</I>&gt;<i> &gt; +     unsigned int nterms = 0;
</I>&gt;<i> &gt; +     char *p = buffer;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     list_for_each_entry(term, terms, chain) {
</I>&gt;<i> &gt; +             p += sprintf(p, &quot;%u&quot;, term-&gt;id);
</I>&gt;<i> &gt; +             if (term-&gt;chain.next != terms) {
</I>&gt;<i> &gt; +                     p += sprintf(p, &quot;,&quot;);
</I>&gt;<i> &gt; +                     if (++nterms &gt;= 4) {
</I>&gt;<i> &gt; +                             p += sprintf(p, &quot;...&quot;);
</I>&gt;<i> &gt; +                             break;
</I>&gt;<i> &gt; +                     }
</I>&gt;<i> &gt; +             }
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     return p - buffer;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static const char *uvc_print_chain(struct uvc_video_chain *chain)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     static char buffer[43];
</I>&gt;<i> &gt; +     char *p = buffer;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     p += uvc_print_terms(&amp;chain-&gt;iterms, p);
</I>&gt;<i> &gt; +     p += sprintf(p, &quot; -&gt; &quot;);
</I>&gt;<i> &gt; +     uvc_print_terms(&amp;chain-&gt;oterms, p);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     return buffer;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; + * Scan the device for video chains and register video devices.
</I>&gt;<i> &gt; + *
</I>&gt;<i> &gt; + * Chains are scanned starting at their output terminals and walked
</I>&gt;<i> &gt; backwards. + */
</I>&gt;<i> &gt; +static int uvc_scan_device(struct uvc_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     struct uvc_video_chain *chain;
</I>&gt;<i> &gt; +     struct uvc_entity *term;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     list_for_each_entry(term, &amp;dev-&gt;entities, list) {
</I>&gt;<i> &gt; +             if (!UVC_ENTITY_IS_OTERM(term))
</I>&gt;<i> &gt; +                     continue;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             /* If the terminal is already included in a chain, skip it.
</I>&gt;<i> &gt; +              * This can happen for chains that have multiple output
</I>&gt;<i> &gt; +              * terminals, where all output terminals beside the first
</I>&gt;<i> one
</I>&gt;<i> &gt; +              * will be inserted in the chain in forward scans.
</I>&gt;<i> &gt; +              */
</I>&gt;<i> &gt; +             if (term-&gt;chain.next || term-&gt;chain.prev)
</I>&gt;<i> &gt; +                     continue;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             chain = kzalloc(sizeof(*chain), GFP_KERNEL);
</I>&gt;<i> &gt; +             if (chain == NULL)
</I>&gt;<i> &gt; +                     return -ENOMEM;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             INIT_LIST_HEAD(&amp;chain-&gt;iterms);
</I>&gt;<i> &gt; +             INIT_LIST_HEAD(&amp;chain-&gt;oterms);
</I>&gt;<i> &gt; +             INIT_LIST_HEAD(&amp;chain-&gt;extensions);
</I>&gt;<i> &gt; +             mutex_init(&amp;chain-&gt;ctrl_mutex);
</I>&gt;<i> &gt; +             chain-&gt;dev = dev;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             if (uvc_scan_chain(chain, term) &lt; 0) {
</I>&gt;<i> &gt; +                     kfree(chain);
</I>&gt;<i> &gt; +                     continue;
</I>&gt;<i> &gt; +             }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             uvc_trace(UVC_TRACE_PROBE, &quot;Found a valid video chain
</I>&gt;<i> (%s).\n&quot;,
</I>&gt;<i> &gt; +                       uvc_print_chain(chain));
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             list_add_tail(&amp;chain-&gt;list, &amp;dev-&gt;chains);
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     if (list_empty(&amp;dev-&gt;chains)) {
</I>&gt;<i> &gt; +             uvc_printk(KERN_INFO, &quot;No valid video chain found.\n&quot;);
</I>&gt;<i> &gt; return -1; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; return 0; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; ------------------------------------------------------------------------
</I>&gt;<i> &gt; + * Video device registration and unregistration
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; /*
</I>&gt;<i> &gt; - * Scan the device for video chains and register video devices.
</I>&gt;<i> &gt; - *
</I>&gt;<i> &gt; - * The driver currently supports a single video device per control
</I>&gt;<i> &gt; interface - * only. The terminal and units must match the following
</I>&gt;<i> &gt; structure:
</I>&gt;<i> &gt; - *
</I>&gt;<i> &gt; - * ITT_* -&gt; VC_PROCESSING_UNIT -&gt; VC_EXTENSION_UNIT{0,n} -&gt; TT_STREAMING
</I>&gt;<i> &gt; - * TT_STREAMING -&gt; VC_PROCESSING_UNIT -&gt; VC_EXTENSION_UNIT{0,n} -&gt; OTT_*
</I>&gt;<i> &gt; - *
</I>&gt;<i> &gt; - * The Extension Units, if present, must have a single input pin. The
</I>&gt;<i> &gt; - * Processing Unit and Extension Units can be in any order. Additional
</I>&gt;<i> &gt; - * Extension Units connected to the main chain as single-unit branches
</I>&gt;<i> &gt; are - * also supported.
</I>&gt;<i> &gt; + * Unregister the video devices.
</I>&gt;<i> &gt; */
</I>&gt;<i> &gt; -static int uvc_scan_device(struct uvc_device *dev)
</I>&gt;<i> &gt; +static void uvc_unregister_video(struct uvc_device *dev)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; -     struct uvc_entity *term;
</I>&gt;<i> &gt; -     int found = 0;
</I>&gt;<i> &gt; +     struct uvc_streaming *stream;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     /* Check if the control interface matches the structure we expect.
</I>&gt;<i> */
</I>&gt;<i> &gt; -     list_for_each_entry(term, &amp;dev-&gt;entities, list) {
</I>&gt;<i> &gt; -             struct uvc_streaming *stream;
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -             if (!UVC_ENTITY_IS_TERM(term) ||
</I>&gt;<i> !UVC_ENTITY_IS_OTERM(term))
</I>&gt;<i> &gt; +     list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
</I>&gt;<i> &gt; +             if (stream-&gt;vdev == NULL)
</I>&gt;<i> &gt; continue;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             memset(&amp;dev-&gt;video, 0, sizeof dev-&gt;video);
</I>&gt;<i> &gt; -             mutex_init(&amp;dev-&gt;video.ctrl_mutex);
</I>&gt;<i> &gt; -             INIT_LIST_HEAD(&amp;dev-&gt;video.iterms);
</I>&gt;<i> &gt; -             INIT_LIST_HEAD(&amp;dev-&gt;video.extensions);
</I>&gt;<i> &gt; -             dev-&gt;video.oterm = term;
</I>&gt;<i> &gt; -             dev-&gt;video.dev = dev;
</I>&gt;<i> &gt; -             if (uvc_scan_chain(&amp;dev-&gt;video) &lt; 0)
</I>&gt;<i> &gt; -                     continue;
</I>&gt;<i> &gt; +             if (stream-&gt;vdev-&gt;minor == -1)
</I>&gt;<i> &gt; +                     video_device_release(stream-&gt;vdev);
</I>&gt;<i> &gt; +             else
</I>&gt;<i> &gt; +                     video_unregister_device(stream-&gt;vdev);
</I>&gt;<i> &gt; +             stream-&gt;vdev = NULL;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
</I>&gt;<i> &gt; -                     if (stream-&gt;header.bTerminalLink ==
</I>&gt;<i> &gt; -                         dev-&gt;video.sterm-&gt;id) {
</I>&gt;<i> &gt; -                             uvc_register_video(dev, stream);
</I>&gt;<i> &gt; -                             found = 1;
</I>&gt;<i> &gt; -                             break;
</I>&gt;<i> &gt; -                     }
</I>&gt;<i> &gt; -             }
</I>&gt;<i> &gt; +static int uvc_register_video(struct uvc_device *dev,
</I>&gt;<i> &gt; +             struct uvc_streaming *stream)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     struct video_device *vdev;
</I>&gt;<i> &gt; +     int ret;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     /* Initialize the streaming interface with default streaming
</I>&gt;<i> &gt; +      * parameters.
</I>&gt;<i> &gt; +      */
</I>&gt;<i> &gt; +     ret = uvc_video_init(stream);
</I>&gt;<i> &gt; +     if (ret &lt; 0) {
</I>&gt;<i> &gt; +             uvc_printk(KERN_ERR, &quot;Failed to initialize the device &quot;
</I>&gt;<i> &gt; +                     &quot;(%d).\n&quot;, ret);
</I>&gt;<i> &gt; +             return ret;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     if (!found) {
</I>&gt;<i> &gt; -             uvc_printk(KERN_INFO, &quot;No valid video chain found.\n&quot;);
</I>&gt;<i> &gt; -             return -1;
</I>&gt;<i> &gt; +     /* Register the device with V4L. */
</I>&gt;<i> &gt; +     vdev = video_device_alloc();
</I>&gt;<i> &gt; +     if (vdev == NULL) {
</I>&gt;<i> &gt; +             uvc_printk(KERN_ERR, &quot;Failed to allocate video device
</I>&gt;<i> (%d).\n&quot;,
</I>&gt;<i> &gt; +                        ret);
</I>&gt;<i> &gt; +             return -ENOMEM;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     /* We already hold a reference to dev-&gt;udev. The video device will
</I>&gt;<i> be
</I>&gt;<i> &gt; +      * unregistered before the reference is released, so we don't need
</I>&gt;<i> to
</I>&gt;<i> &gt; +      * get another one.
</I>&gt;<i> &gt; +      */
</I>&gt;<i> &gt; +     vdev-&gt;parent = &amp;dev-&gt;intf-&gt;dev;
</I>&gt;<i> &gt; +     vdev-&gt;minor = -1;
</I>&gt;<i> &gt; +     vdev-&gt;fops = &amp;uvc_fops;
</I>&gt;<i> &gt; +     vdev-&gt;release = video_device_release;
</I>&gt;<i> &gt; +     strlcpy(vdev-&gt;name, dev-&gt;name, sizeof vdev-&gt;name);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     /* Set the driver data before calling video_register_device,
</I>&gt;<i> otherwise
</I>&gt;<i> &gt; +      * uvc_v4l2_open might race us.
</I>&gt;<i> &gt; +      */
</I>&gt;<i> &gt; +     stream-&gt;vdev = vdev;
</I>&gt;<i> &gt; +     video_set_drvdata(vdev, stream);
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
</I>&gt;<i> &gt; +     if (ret &lt; 0) {
</I>&gt;<i> &gt; +             uvc_printk(KERN_ERR, &quot;Failed to register video device
</I>&gt;<i> (%d).\n&quot;,
</I>&gt;<i> &gt; +                        ret);
</I>&gt;<i> &gt; +             stream-&gt;vdev = NULL;
</I>&gt;<i> &gt; +             video_device_release(vdev);
</I>&gt;<i> &gt; +             return ret;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; return 0; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /*
</I>&gt;<i> &gt; + * Register all video devices in all chains.
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +static int uvc_register_terms(struct uvc_device *dev,
</I>&gt;<i> &gt; +     struct uvc_video_chain *chain, struct list_head *terms)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     struct uvc_streaming *stream;
</I>&gt;<i> &gt; +     struct uvc_entity *term;
</I>&gt;<i> &gt; +     int ret;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     list_for_each_entry(term, terms, chain) {
</I>&gt;<i> &gt; +             if (UVC_ENTITY_TYPE(term) != TT_STREAMING)
</I>&gt;<i> &gt; +                     continue;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             stream = uvc_stream_by_id(dev, term-&gt;id);
</I>&gt;<i> &gt; +             if (stream == NULL) {
</I>&gt;<i> &gt; +                     uvc_printk(KERN_INFO, &quot;No streaming interface found
</I>&gt;<i> &quot;
</I>&gt;<i> &gt; +                                &quot;for terminal %u.&quot;, term-&gt;id);
</I>&gt;<i> &gt; +                     continue;
</I>&gt;<i> &gt; +             }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             stream-&gt;chain = chain;
</I>&gt;<i> &gt; +             ret = uvc_register_video(dev, stream);
</I>&gt;<i> &gt; +             if (ret &lt; 0)
</I>&gt;<i> &gt; +                     return ret;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +static int uvc_register_chains(struct uvc_device *dev)
</I>&gt;<i> &gt; +{
</I>&gt;<i> &gt; +     struct uvc_video_chain *chain;
</I>&gt;<i> &gt; +     int ret;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     list_for_each_entry(chain, &amp;dev-&gt;chains, list) {
</I>&gt;<i> &gt; +             ret = uvc_register_terms(dev, chain, &amp;chain-&gt;iterms);
</I>&gt;<i> &gt; +             if (ret &lt; 0)
</I>&gt;<i> &gt; +                     return ret;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +             ret = uvc_register_terms(dev, chain, &amp;chain-&gt;oterms);
</I>&gt;<i> &gt; +             if (ret &lt; 0)
</I>&gt;<i> &gt; +                     return ret;
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     return 0;
</I>&gt;<i> &gt; +}
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; ------------------------------------------------------------------------
</I>&gt;<i> &gt; + * USB probe, disconnect, suspend and resume
</I>&gt;<i> &gt; + */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +/*
</I>&gt;<i> &gt; * Delete the UVC device.
</I>&gt;<i> &gt; *
</I>&gt;<i> &gt; * Called by the kernel when the last reference to the uvc_device
</I>&gt;<i> structure
</I>&gt;<i> &gt;  @@ -1554,7 +1673,7 @@
</I>&gt;<i> &gt; struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
</I>&gt;<i> &gt; struct list_head *p, *n;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     /* Unregister the video device. */
</I>&gt;<i> &gt; +     /* Unregister the video devices. */
</I>&gt;<i> &gt; uvc_unregister_video(dev); usb_put_intf(dev-&gt;intf);
</I>&gt;<i> usb_put_dev(dev-&gt;udev);
</I>&gt;<i> &gt; @@ -1562,6 +1681,12 @@
</I>&gt;<i> &gt; uvc_status_cleanup(dev); uvc_ctrl_cleanup_device(dev);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +     list_for_each_safe(p, n, &amp;dev-&gt;chains) {
</I>&gt;<i> &gt; +             struct uvc_video_chain *chain;
</I>&gt;<i> &gt; +             chain = list_entry(p, struct uvc_video_chain, list);
</I>&gt;<i> &gt; +             kfree(chain);
</I>&gt;<i> &gt; +     }
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; list_for_each_safe(p, n, &amp;dev-&gt;entities) { struct uvc_entity *entity;
</I>&gt;<i> entity
</I>&gt;<i> &gt; = list_entry(p, struct uvc_entity, list);
</I>&gt;<i> &gt; @@ -1602,6 +1727,7 @@
</I>&gt;<i> &gt; return -ENOMEM;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; INIT_LIST_HEAD(&amp;dev-&gt;entities);
</I>&gt;<i> &gt; +     INIT_LIST_HEAD(&amp;dev-&gt;chains);
</I>&gt;<i> &gt; INIT_LIST_HEAD(&amp;dev-&gt;streams);
</I>&gt;<i> &gt; kref_init(&amp;dev-&gt;kref); atomic_set(&amp;dev-&gt;users, 0); @@ -1643,10 +1769,14
</I>&gt;<i> @@
</I>&gt;<i> &gt; if (uvc_ctrl_init_device(dev) &lt; 0) goto error;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     /* Scan the device for video chains and register video devices. */
</I>&gt;<i> &gt; +     /* Scan the device for video chains. */
</I>&gt;<i> &gt; if (uvc_scan_device(dev) &lt; 0) goto error;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +     /* Register video devices. */
</I>&gt;<i> &gt; +     if (uvc_register_chains(dev) &lt; 0)
</I>&gt;<i> &gt; +             goto error;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; /* Save our data pointer in the interface data. */
</I>&gt;<i> &gt; usb_set_intfdata(intf, dev);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; diff -r 88ef3b9f5071 -r 012e480c8e6a
</I>&gt;<i> &gt; linux/drivers/media/video/uvc/uvc_v4l2.c ---
</I>&gt;<i> &gt; a/linux/drivers/media/video/uvc/uvc_v4l2.c    Sun Jun 28 13:37:50 2009
</I>&gt;<i> +0200
</I>&gt;<i> &gt;  +++ b/linux/drivers/media/video/uvc/uvc_v4l2.c       Thu Jul 02 01:24:47
</I>&gt;<i> 2009
</I>&gt;<i> &gt; +0200
</I>&gt;<i> &gt; @@ -40,7 +40,7 @@
</I>&gt;<i> &gt; * table for the controls that can be mapped directly, and handle the
</I>&gt;<i> &gt; others * manually.
</I>&gt;<i> &gt; */
</I>&gt;<i> &gt; -static int uvc_v4l2_query_menu(struct uvc_video_device *video,
</I>&gt;<i> &gt; +static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct v4l2_querymenu *query_menu) {
</I>&gt;<i> &gt; struct uvc_menu_info *menu_info; @@ -49,7 +49,7 @@
</I>&gt;<i> &gt; u32 index = query_menu-&gt;index; u32 id = query_menu-&gt;id;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     ctrl = uvc_find_control(video, query_menu-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; +     ctrl = uvc_find_control(chain, query_menu-&gt;id, &amp;mapping);
</I>&gt;<i> &gt; if (ctrl == NULL || mapping-&gt;v4l2_type != V4L2_CTRL_TYPE_MENU) return
</I>&gt;<i> &gt; -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @@ -493,7 +493,7 @@
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -     handle-&gt;video = &amp;stream-&gt;dev-&gt;video;
</I>&gt;<i> &gt; +     handle-&gt;chain = stream-&gt;chain;
</I>&gt;<i> &gt; handle-&gt;stream = stream; handle-&gt;state = UVC_HANDLE_PASSIVE;
</I>&gt;<i> &gt; file-&gt;private_data = handle; @@ -542,7 +542,7 @@
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; struct video_device *vdev = video_devdata(file); struct uvc_fh *handle =
</I>&gt;<i> &gt; (struct uvc_fh *)file-&gt;private_data;
</I>&gt;<i> &gt; -     struct uvc_video_device *video = handle-&gt;video;
</I>&gt;<i> &gt; +     struct uvc_video_chain *chain = handle-&gt;chain;
</I>&gt;<i> &gt; struct uvc_streaming *stream = handle-&gt;stream; long ret = 0;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @@ -569,7 +569,7 @@
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Get, Set &amp; Query control */
</I>&gt;<i> &gt; case VIDIOC_QUERYCTRL: -              return uvc_query_v4l2_ctrl(video,
</I>&gt;<i> arg);
</I>&gt;<i> &gt; +             return uvc_query_v4l2_ctrl(chain, arg);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case VIDIOC_G_CTRL: {
</I>&gt;<i> &gt; @@ -579,9 +579,9 @@
</I>&gt;<i> &gt; memset(&amp;xctrl, 0, sizeof xctrl); xctrl.id = ctrl-&gt;id;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             uvc_ctrl_begin(video);
</I>&gt;<i> &gt; -             ret = uvc_ctrl_get(video, &amp;xctrl);
</I>&gt;<i> &gt; -             uvc_ctrl_rollback(video);
</I>&gt;<i> &gt; +             uvc_ctrl_begin(chain);
</I>&gt;<i> &gt; +             ret = uvc_ctrl_get(chain, &amp;xctrl);
</I>&gt;<i> &gt; +             uvc_ctrl_rollback(chain);
</I>&gt;<i> &gt; if (ret &gt;= 0) ctrl-&gt;value = xctrl.value; break; @@ -596,18 +596,18 @@
</I>&gt;<i> &gt; xctrl.id = ctrl-&gt;id; xctrl.value = ctrl-&gt;value;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             uvc_ctrl_begin(video);
</I>&gt;<i> &gt; -             ret = uvc_ctrl_set(video, &amp;xctrl);
</I>&gt;<i> &gt; +             uvc_ctrl_begin(chain);
</I>&gt;<i> &gt; +             ret = uvc_ctrl_set(chain, &amp;xctrl);
</I>&gt;<i> &gt; if (ret &lt; 0) { -                      uvc_ctrl_rollback(video);
</I>&gt;<i> &gt; +                     uvc_ctrl_rollback(chain);
</I>&gt;<i> &gt; return ret; }
</I>&gt;<i> &gt; -             ret = uvc_ctrl_commit(video);
</I>&gt;<i> &gt; +             ret = uvc_ctrl_commit(chain);
</I>&gt;<i> &gt; break; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case VIDIOC_QUERYMENU: -              return uvc_v4l2_query_menu(video,
</I>&gt;<i> arg);
</I>&gt;<i> &gt; +             return uvc_v4l2_query_menu(chain, arg);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case VIDIOC_G_EXT_CTRLS: {
</I>&gt;<i> &gt; @@ -615,17 +615,17 @@
</I>&gt;<i> &gt; struct v4l2_ext_control *ctrl = ctrls-&gt;controls; unsigned int i;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             uvc_ctrl_begin(video);
</I>&gt;<i> &gt; +             uvc_ctrl_begin(chain);
</I>&gt;<i> &gt; for (i = 0; i &lt; ctrls-&gt;count; ++ctrl, ++i) { -                        ret
</I>&gt;<i> = uvc_ctrl_get(video,
</I>&gt;<i> &gt; ctrl); +                      ret = uvc_ctrl_get(chain, ctrl);
</I>&gt;<i> &gt; if (ret &lt; 0) { -                              uvc_ctrl_rollback(video);
</I>&gt;<i> &gt; +                             uvc_ctrl_rollback(chain);
</I>&gt;<i> &gt; ctrls-&gt;error_idx = i; return ret; }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; ctrls-&gt;error_idx = 0; -               ret = uvc_ctrl_rollback(video);
</I>&gt;<i> &gt; +             ret = uvc_ctrl_rollback(chain);
</I>&gt;<i> &gt; break; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @@ -636,14 +636,14 @@
</I>&gt;<i> &gt; struct v4l2_ext_control *ctrl = ctrls-&gt;controls; unsigned int i;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             ret = uvc_ctrl_begin(video);
</I>&gt;<i> &gt; +             ret = uvc_ctrl_begin(chain);
</I>&gt;<i> &gt; if (ret &lt; 0) return ret;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; for (i = 0; i &lt; ctrls-&gt;count; ++ctrl, ++i) { -                        ret
</I>&gt;<i> = uvc_ctrl_set(video,
</I>&gt;<i> &gt; ctrl); +                      ret = uvc_ctrl_set(chain, ctrl);
</I>&gt;<i> &gt; if (ret &lt; 0) { -                              uvc_ctrl_rollback(video);
</I>&gt;<i> &gt; +                             uvc_ctrl_rollback(chain);
</I>&gt;<i> &gt; ctrls-&gt;error_idx = i; return ret; }
</I>&gt;<i> &gt; @@ -652,31 +652,31 @@
</I>&gt;<i> &gt; ctrls-&gt;error_idx = 0;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if (cmd == VIDIOC_S_EXT_CTRLS) -                      ret =
</I>&gt;<i> uvc_ctrl_commit(video);
</I>&gt;<i> &gt; +                     ret = uvc_ctrl_commit(chain);
</I>&gt;<i> &gt; else -                        ret = uvc_ctrl_rollback(video);
</I>&gt;<i> &gt; +                     ret = uvc_ctrl_rollback(chain);
</I>&gt;<i> &gt; break; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Get, Set &amp; Enum input */
</I>&gt;<i> &gt; case VIDIOC_ENUMINPUT: {
</I>&gt;<i> &gt; -             const struct uvc_entity *selector = video-&gt;selector;
</I>&gt;<i> &gt; +             const struct uvc_entity *selector = chain-&gt;selector;
</I>&gt;<i> &gt; struct v4l2_input *input = arg; struct uvc_entity *iterm = NULL; u32
</I>&gt;<i> index =
</I>&gt;<i> &gt; input-&gt;index; int pin = 0;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; if (selector == NULL || -                 (video-&gt;dev-&gt;quirks &amp;
</I>&gt;<i> &gt; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
</I>&gt;<i> &gt; +                 (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT))
</I>&gt;<i> {
</I>&gt;<i> &gt; if (index != 0) return -EINVAL; -                     iterm =
</I>&gt;<i> list_first_entry(&amp;video-&gt;iterms,
</I>&gt;<i> &gt;  +                    iterm = list_first_entry(&amp;chain-&gt;iterms,
</I>&gt;<i> &gt; struct uvc_entity, chain); pin = iterm-&gt;id; } else if (pin &lt;
</I>&gt;<i> &gt; selector-&gt;selector.bNrInPins) { pin =
</I>&gt;<i> &gt; selector-&gt;selector.baSourceID[index]; -
</I>&gt;<i> list_for_each_entry(iterm,
</I>&gt;<i> &gt; video-&gt;iterms.next, chain) { +
</I>&gt;<i>  list_for_each_entry(iterm,
</I>&gt;<i> &gt; chain-&gt;iterms.next, chain) { if (iterm-&gt;id == pin) break; }
</I>&gt;<i> &gt; @@ -697,14 +697,14 @@
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; u8 input;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             if (video-&gt;selector == NULL ||
</I>&gt;<i> &gt; -                 (video-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT))
</I>&gt;<i> {
</I>&gt;<i> &gt; +             if (chain-&gt;selector == NULL ||
</I>&gt;<i> &gt; +                 (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT))
</I>&gt;<i> {
</I>&gt;<i> &gt; *(int *)arg = 0;
</I>&gt;<i> &gt; break; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             ret = uvc_query_ctrl(video-&gt;dev, GET_CUR,
</I>&gt;<i> video-&gt;selector-&gt;id,
</I>&gt;<i> &gt; -                     video-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> &gt; +             ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR,
</I>&gt;<i> chain-&gt;selector-&gt;id,
</I>&gt;<i> &gt; +                     chain-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> &gt; &amp;input, 1);
</I>&gt;<i> &gt; if (ret &lt; 0) return ret; @@ -720,18 +720,18 @@
</I>&gt;<i> &gt; if ((ret = uvc_acquire_privileges(handle)) &lt; 0) return ret;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             if (video-&gt;selector == NULL ||
</I>&gt;<i> &gt; -                 (video-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT))
</I>&gt;<i> {
</I>&gt;<i> &gt; +             if (chain-&gt;selector == NULL ||
</I>&gt;<i> &gt; +                 (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT))
</I>&gt;<i> {
</I>&gt;<i> &gt; if (input != 1) return -EINVAL; break; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             if (input == 0 || input &gt;
</I>&gt;<i> video-&gt;selector-&gt;selector.bNrInPins)
</I>&gt;<i> &gt; +             if (input == 0 || input &gt;
</I>&gt;<i> chain-&gt;selector-&gt;selector.bNrInPins)
</I>&gt;<i> &gt; return -EINVAL;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -             return uvc_query_ctrl(video-&gt;dev, SET_CUR,
</I>&gt;<i> video-&gt;selector-&gt;id,
</I>&gt;<i> &gt; -                     video-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> &gt; +             return uvc_query_ctrl(chain-&gt;dev, SET_CUR,
</I>&gt;<i> chain-&gt;selector-&gt;id,
</I>&gt;<i> &gt; +                     chain-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
</I>&gt;<i> &gt; &amp;input, 1);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; @@ -1064,10 +1064,10 @@
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case UVCIOC_CTRL_GET: -               return uvc_xu_ctrl_query(video,
</I>&gt;<i> arg, 0);
</I>&gt;<i> &gt; +             return uvc_xu_ctrl_query(chain, arg, 0);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; case UVCIOC_CTRL_SET: -               return uvc_xu_ctrl_query(video,
</I>&gt;<i> arg, 1);
</I>&gt;<i> &gt; +             return uvc_xu_ctrl_query(chain, arg, 1);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; default:
</I>&gt;<i> &gt; if ((ret = v4l_compat_translate_ioctl(file, cmd, arg, diff -r
</I>&gt;<i> 88ef3b9f5071
</I>&gt;<i> &gt; -r 012e480c8e6a linux/drivers/media/video/uvc/uvcvideo.h
</I>&gt;<i> &gt; --- a/linux/drivers/media/video/uvc/uvcvideo.h        Sun Jun 28 13:37:50
</I>&gt;<i> 2009
</I>&gt;<i> &gt; +0200
</I>&gt;<i> &gt; +++ b/linux/drivers/media/video/uvc/uvcvideo.h        Thu Jul 02 01:24:47
</I>&gt;<i> 2009
</I>&gt;<i> &gt; +0200
</I>&gt;<i> &gt; @@ -224,9 +224,11 @@
</I>&gt;<i> &gt; #define UVC_ENTITY_IS_UNIT(entity)    (((entity)-&gt;type &amp; 0xff00) == 0)
</I>&gt;<i> &gt; #define UVC_ENTITY_IS_TERM(entity)    (((entity)-&gt;type &amp; 0xff00) != 0)
</I>&gt;<i> &gt; #define UVC_ENTITY_IS_ITERM(entity) \
</I>&gt;<i> &gt; -     (((entity)-&gt;type &amp; 0x8000) == UVC_TERM_INPUT)
</I>&gt;<i> &gt; +     (UVC_ENTITY_IS_TERM(entity) &amp;&amp; \
</I>&gt;<i> &gt; +     ((entity)-&gt;type &amp; 0x8000) == UVC_TERM_INPUT)
</I>&gt;<i> &gt; #define UVC_ENTITY_IS_OTERM(entity) \
</I>&gt;<i> &gt; -     (((entity)-&gt;type &amp; 0x8000) == UVC_TERM_OUTPUT)
</I>&gt;<i> &gt; +     (UVC_ENTITY_IS_TERM(entity) &amp;&amp; \
</I>&gt;<i> &gt; +     ((entity)-&gt;type &amp; 0x8000) == UVC_TERM_OUTPUT)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; #define UVC_STATUS_TYPE_CONTROL               1
</I>&gt;<i> &gt; #define UVC_STATUS_TYPE_STREAMING     2
</I>&gt;<i> &gt; @@ -560,10 +562,24 @@
</I>&gt;<i> &gt; struct list_head irqqueue; };
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; +struct uvc_video_chain {
</I>&gt;<i> &gt; +     struct uvc_device *dev;
</I>&gt;<i> &gt; +     struct list_head list;
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     struct list_head iterms;                /* Input terminals */
</I>&gt;<i> &gt; +     struct list_head oterms;                /* Output terminals */
</I>&gt;<i> &gt; +     struct uvc_entity *processing;          /* Processing unit */
</I>&gt;<i> &gt; +     struct uvc_entity *selector;            /* Selector unit */
</I>&gt;<i> &gt; +     struct list_head extensions;            /* Extension units */
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; +     struct mutex ctrl_mutex;
</I>&gt;<i> &gt; +};
</I>&gt;<i> &gt; +
</I>&gt;<i> &gt; struct uvc_streaming { struct list_head list; struct uvc_device *dev;
</I>&gt;<i> struct
</I>&gt;<i> &gt; video_device *vdev; + struct uvc_video_chain *chain;
</I>&gt;<i> &gt; atomic_t active;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; struct usb_interface *intf; @@ -604,18 +620,6 @@
</I>&gt;<i> &gt; __u8 last_fid;
</I>&gt;<i> &gt; };
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -struct uvc_video_device {
</I>&gt;<i> &gt; -     struct uvc_device *dev;
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; -     struct list_head iterms;                /* Input terminals */
</I>&gt;<i> &gt; -     struct uvc_entity *oterm;               /* Output terminal */
</I>&gt;<i> &gt; -     struct uvc_entity *sterm;               /* USB streaming terminal
</I>&gt;<i> */
</I>&gt;<i> &gt; -     struct uvc_entity *processing;
</I>&gt;<i> &gt; -     struct uvc_entity *selector;
</I>&gt;<i> &gt; -     struct list_head extensions;
</I>&gt;<i> &gt; -     struct mutex ctrl_mutex;
</I>&gt;<i> &gt; -};
</I>&gt;<i> &gt; -
</I>&gt;<i> &gt; enum uvc_device_state { UVC_DEV_DISCONNECTED = 1,
</I>&gt;<i> &gt; };
</I>&gt;<i> &gt; @@ -638,8 +642,7 @@
</I>&gt;<i> &gt; __u32 clock_frequency;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; struct list_head entities; -
</I>&gt;<i> &gt; -     struct uvc_video_device video;
</I>&gt;<i> &gt; +     struct list_head chains;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Video Streaming interfaces */
</I>&gt;<i> &gt; struct list_head streams; @@ -658,7 +661,7 @@
</I>&gt;<i> &gt; };
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; struct uvc_fh { -     struct uvc_video_device *video;
</I>&gt;<i> &gt; +     struct uvc_video_chain *chain;
</I>&gt;<i> &gt; struct uvc_streaming *stream; enum uvc_handle_state state; };
</I>&gt;<i> &gt; @@ -776,9 +779,9 @@
</I>&gt;<i> &gt; extern int uvc_status_resume(struct uvc_device *dev);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Controls */
</I>&gt;<i> &gt; -extern struct uvc_control *uvc_find_control(struct uvc_video_device
</I>&gt;<i> &gt; *video,
</I>&gt;<i> &gt; +extern struct uvc_control *uvc_find_control(struct uvc_video_chain
</I>&gt;<i> &gt; *chain,
</I>&gt;<i> &gt; __u32 v4l2_id, struct uvc_control_mapping **mapping);
</I>&gt;<i> &gt; -extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
</I>&gt;<i> &gt; +extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct v4l2_queryctrl *v4l2_ctrl);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; extern int uvc_ctrl_add_info(struct uvc_control_info *info); @@ -788,23
</I>&gt;<i> &gt; +791,23 @@
</I>&gt;<i> &gt; extern int uvc_ctrl_resume_device(struct uvc_device *dev); extern void
</I>&gt;<i> &gt; uvc_ctrl_init(void);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -extern int uvc_ctrl_begin(struct uvc_video_device *video);
</I>&gt;<i> &gt; -extern int __uvc_ctrl_commit(struct uvc_video_device *video, int
</I>&gt;<i> &gt; rollback); -static inline int uvc_ctrl_commit(struct uvc_video_device
</I>&gt;<i> &gt; *video)
</I>&gt;<i> &gt; +extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
</I>&gt;<i> &gt; +extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int
</I>&gt;<i> &gt; rollback); +static inline int uvc_ctrl_commit(struct uvc_video_chain
</I>&gt;<i> &gt; *chain)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; -     return __uvc_ctrl_commit(video, 0);
</I>&gt;<i> &gt; +     return __uvc_ctrl_commit(chain, 0);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; -static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
</I>&gt;<i> &gt; +static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; -     return __uvc_ctrl_commit(video, 1);
</I>&gt;<i> &gt; +     return __uvc_ctrl_commit(chain, 1);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -extern int uvc_ctrl_get(struct uvc_video_device *video,
</I>&gt;<i> &gt; +extern int uvc_ctrl_get(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct v4l2_ext_control *xctrl); -extern int uvc_ctrl_set(struct
</I>&gt;<i> &gt; uvc_video_device *video, +extern int uvc_ctrl_set(struct uvc_video_chain
</I>&gt;<i> &gt; *chain,
</I>&gt;<i> &gt; struct v4l2_ext_control *xctrl);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; -extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
</I>&gt;<i> &gt; +extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
</I>&gt;<i> &gt; struct uvc_xu_control *ctrl, int set);
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; /* Utility functions */
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Linux-uvc-devel mailing list
</I>&gt;<i> &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">Linux-uvc-devel at lists.berlios.de</A>
</I>&gt;<i> &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">https://lists.berlios.de/mailman/listinfo/linux-uvc-devel</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Linux-uvc-devel mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">Linux-uvc-devel at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">https://lists.berlios.de/mailman/listinfo/linux-uvc-devel</A>
</I>&gt;<i>
</I>


-- 
Best Regards
Brian
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090702/786421ea/attachment.html">https://lists.berlios.de/pipermail/linux-uvc-devel/attachments/20090702/786421ea/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004959.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support
</A></li>
	<LI>Next message: <A HREF="004957.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4955">[ date ]</a>
              <a href="thread.html#4955">[ thread ]</a>
              <a href="subject.html#4955">[ subject ]</a>
              <a href="author.html#4955">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">More information about the Linux-uvc-devel
mailing list</a><br>
</body></html>
