<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/linux-uvc-devel/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BPATCH%202/2%5D%20uvcvideo%3A%20Multiple%20streaming%0A%09interfaces%20support&In-Reply-To=%3C200907020131.34726.laurent.pinchart%40skynet.be%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004945.html">
   <LINK REL="Next"  HREF="004951.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support</H1>
    <B>Laurent Pinchart</B> 
    <A HREF="mailto:linux-uvc-devel%40lists.berlios.de?Subject=Re%3A%20%5BLinux-uvc-devel%5D%20%5BPATCH%202/2%5D%20uvcvideo%3A%20Multiple%20streaming%0A%09interfaces%20support&In-Reply-To=%3C200907020131.34726.laurent.pinchart%40skynet.be%3E"
       TITLE="[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming	interfaces support">laurent.pinchart at skynet.be
       </A><BR>
    <I>Thu Jul  2 01:31:34 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="004945.html">[Linux-uvc-devel] [PATCH 1/2] uvcvideo: Restructure the driver to	support multiple simultaneous streams.
</A></li>
        <LI>Next message: <A HREF="004951.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4943">[ date ]</a>
              <a href="thread.html#4943">[ thread ]</a>
              <a href="subject.html#4943">[ subject ]</a>
              <a href="author.html#4943">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Restructure the UVC descriptors parsing code to handle multiple streaming
interfaces. The driver now creates a uvc_video_chain instance for each chain
detected in the UVC control interface descriptors, and tries to register one
video device per streaming endpoint.

Priority: normal

Signed-off-by: Laurent Pinchart &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">laurent.pinchart at skynet.be</A>&gt;

diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_ctrl.c
--- a/linux/drivers/media/video/uvc/uvc_ctrl.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_ctrl.c	Thu Jul 02 01:24:47 2009 +0200
@@ -731,7 +731,7 @@
 	}
 }
 
-struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 	__u32 v4l2_id, struct uvc_control_mapping **mapping)
 {
 	struct uvc_control *ctrl = NULL;
@@ -744,17 +744,17 @@
 	v4l2_id &amp;= V4L2_CTRL_ID_MASK;
 
 	/* Find the control. */
-	__uvc_find_control(video-&gt;processing, v4l2_id, mapping, &amp;ctrl, next);
+	__uvc_find_control(chain-&gt;processing, v4l2_id, mapping, &amp;ctrl, next);
 	if (ctrl &amp;&amp; !next)
 		return ctrl;
 
-	list_for_each_entry(entity, &amp;video-&gt;iterms, chain) {
+	list_for_each_entry(entity, &amp;chain-&gt;iterms, chain) {
 		__uvc_find_control(entity, v4l2_id, mapping, &amp;ctrl, next);
 		if (ctrl &amp;&amp; !next)
 			return ctrl;
 	}
 
-	list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
+	list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
 		__uvc_find_control(entity, v4l2_id, mapping, &amp;ctrl, next);
 		if (ctrl &amp;&amp; !next)
 			return ctrl;
@@ -767,7 +767,7 @@
 	return ctrl;
 }
 
-int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 	struct v4l2_queryctrl *v4l2_ctrl)
 {
 	struct uvc_control *ctrl;
@@ -777,7 +777,7 @@
 	__u8 *data;
 	int ret;
 
-	ctrl = uvc_find_control(video, v4l2_ctrl-&gt;id, &amp;mapping);
+	ctrl = uvc_find_control(chain, v4l2_ctrl-&gt;id, &amp;mapping);
 	if (ctrl == NULL)
 		return -EINVAL;
 
@@ -795,9 +795,10 @@
 		v4l2_ctrl-&gt;flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
 	if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_DEF) {
-		if ((ret = uvc_query_ctrl(video-&gt;dev, GET_DEF, ctrl-&gt;entity-&gt;id,
-				video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
-				data, ctrl-&gt;info-&gt;size)) &lt; 0)
+		ret = uvc_query_ctrl(chain-&gt;dev, GET_DEF, ctrl-&gt;entity-&gt;id,
+				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
+				     data, ctrl-&gt;info-&gt;size);
+		if (ret &lt; 0)
 			goto out;
 		v4l2_ctrl-&gt;default_value = mapping-&gt;get(mapping, GET_DEF, data);
 	}
@@ -831,23 +832,26 @@
 	}
 
 	if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_MIN) {
-		if ((ret = uvc_query_ctrl(video-&gt;dev, GET_MIN, ctrl-&gt;entity-&gt;id,
-				video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
-				data, ctrl-&gt;info-&gt;size)) &lt; 0)
+		ret = uvc_query_ctrl(chain-&gt;dev, GET_MIN, ctrl-&gt;entity-&gt;id,
+				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
+				     data, ctrl-&gt;info-&gt;size);
+		if (ret &lt; 0)
 			goto out;
 		v4l2_ctrl-&gt;minimum = mapping-&gt;get(mapping, GET_MIN, data);
 	}
 	if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_MAX) {
-		if ((ret = uvc_query_ctrl(video-&gt;dev, GET_MAX, ctrl-&gt;entity-&gt;id,
-				video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
-				data, ctrl-&gt;info-&gt;size)) &lt; 0)
+		ret = uvc_query_ctrl(chain-&gt;dev, GET_MAX, ctrl-&gt;entity-&gt;id,
+				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
+				     data, ctrl-&gt;info-&gt;size);
+		if (ret &lt; 0)
 			goto out;
 		v4l2_ctrl-&gt;maximum = mapping-&gt;get(mapping, GET_MAX, data);
 	}
 	if (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_RES) {
-		if ((ret = uvc_query_ctrl(video-&gt;dev, GET_RES, ctrl-&gt;entity-&gt;id,
-				video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
-				data, ctrl-&gt;info-&gt;size)) &lt; 0)
+		ret = uvc_query_ctrl(chain-&gt;dev, GET_RES, ctrl-&gt;entity-&gt;id,
+				     chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
+				     data, ctrl-&gt;info-&gt;size);
+		if (ret &lt; 0)
 			goto out;
 		v4l2_ctrl-&gt;step = mapping-&gt;get(mapping, GET_RES, data);
 	}
@@ -883,9 +887,9 @@
  * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release the
  * control lock.
  */
-int uvc_ctrl_begin(struct uvc_video_device *video)
+int uvc_ctrl_begin(struct uvc_video_chain *chain)
 {
-	return mutex_lock_interruptible(&amp;video-&gt;ctrl_mutex) ? -ERESTARTSYS : 0;
+	return mutex_lock_interruptible(&amp;chain-&gt;ctrl_mutex) ? -ERESTARTSYS : 0;
 }
 
 static int uvc_ctrl_commit_entity(struct uvc_device *dev,
@@ -935,34 +939,34 @@
 	return 0;
 }
 
-int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
+int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
 {
 	struct uvc_entity *entity;
 	int ret = 0;
 
 	/* Find the control. */
-	ret = uvc_ctrl_commit_entity(video-&gt;dev, video-&gt;processing, rollback);
+	ret = uvc_ctrl_commit_entity(chain-&gt;dev, chain-&gt;processing, rollback);
 	if (ret &lt; 0)
 		goto done;
 
-	list_for_each_entry(entity, &amp;video-&gt;iterms, chain) {
-		ret = uvc_ctrl_commit_entity(video-&gt;dev, entity, rollback);
+	list_for_each_entry(entity, &amp;chain-&gt;iterms, chain) {
+		ret = uvc_ctrl_commit_entity(chain-&gt;dev, entity, rollback);
 		if (ret &lt; 0)
 			goto done;
 	}
 
-	list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
-		ret = uvc_ctrl_commit_entity(video-&gt;dev, entity, rollback);
+	list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
+		ret = uvc_ctrl_commit_entity(chain-&gt;dev, entity, rollback);
 		if (ret &lt; 0)
 			goto done;
 	}
 
 done:
-	mutex_unlock(&amp;video-&gt;ctrl_mutex);
+	mutex_unlock(&amp;chain-&gt;ctrl_mutex);
 	return ret;
 }
 
-int uvc_ctrl_get(struct uvc_video_device *video,
+int uvc_ctrl_get(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
@@ -971,13 +975,13 @@
 	unsigned int i;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl-&gt;id, &amp;mapping);
+	ctrl = uvc_find_control(chain, xctrl-&gt;id, &amp;mapping);
 	if (ctrl == NULL || (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_CUR) == 0)
 		return -EINVAL;
 
 	if (!ctrl-&gt;loaded) {
-		ret = uvc_query_ctrl(video-&gt;dev, GET_CUR, ctrl-&gt;entity-&gt;id,
-				video-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
+		ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR, ctrl-&gt;entity-&gt;id,
+				chain-&gt;dev-&gt;intfnum, ctrl-&gt;info-&gt;selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl-&gt;info-&gt;size);
 		if (ret &lt; 0)
@@ -1002,7 +1006,7 @@
 	return 0;
 }
 
-int uvc_ctrl_set(struct uvc_video_device *video,
+int uvc_ctrl_set(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
@@ -1010,7 +1014,7 @@
 	s32 value = xctrl-&gt;value;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl-&gt;id, &amp;mapping);
+	ctrl = uvc_find_control(chain, xctrl-&gt;id, &amp;mapping);
 	if (ctrl == NULL || (ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_SET_CUR) == 0)
 		return -EINVAL;
 
@@ -1025,8 +1029,8 @@
 			memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				0, ctrl-&gt;info-&gt;size);
 		} else {
-			ret = uvc_query_ctrl(video-&gt;dev, GET_CUR,
-				ctrl-&gt;entity-&gt;id, video-&gt;dev-&gt;intfnum,
+			ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR,
+				ctrl-&gt;entity-&gt;id, chain-&gt;dev-&gt;intfnum,
 				ctrl-&gt;info-&gt;selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl-&gt;info-&gt;size);
@@ -1055,7 +1059,7 @@
  * Dynamic controls
  */
 
-int uvc_xu_ctrl_query(struct uvc_video_device *video,
+int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 	struct uvc_xu_control *xctrl, int set)
 {
 	struct uvc_entity *entity;
@@ -1065,7 +1069,7 @@
 	int ret;
 
 	/* Find the extension unit. */
-	list_for_each_entry(entity, &amp;video-&gt;extensions, chain) {
+	list_for_each_entry(entity, &amp;chain-&gt;extensions, chain) {
 		if (entity-&gt;id == xctrl-&gt;unit)
 			break;
 	}
@@ -1104,7 +1108,7 @@
 	    (!set &amp;&amp; !(ctrl-&gt;info-&gt;flags &amp; UVC_CONTROL_GET_CUR)))
 		return -EINVAL;
 
-	if (mutex_lock_interruptible(&amp;video-&gt;ctrl_mutex))
+	if (mutex_lock_interruptible(&amp;chain-&gt;ctrl_mutex))
 		return -ERESTARTSYS;
 
 	memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
@@ -1117,8 +1121,8 @@
 		goto out;
 	}
 
-	ret = uvc_query_ctrl(video-&gt;dev, set ? SET_CUR : GET_CUR, xctrl-&gt;unit,
-			     video-&gt;dev-&gt;intfnum, xctrl-&gt;selector, data,
+	ret = uvc_query_ctrl(chain-&gt;dev, set ? SET_CUR : GET_CUR, xctrl-&gt;unit,
+			     chain-&gt;dev-&gt;intfnum, xctrl-&gt;selector, data,
 			     xctrl-&gt;size);
 	if (ret &lt; 0)
 		goto out;
@@ -1134,7 +1138,7 @@
 		       uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
 		       xctrl-&gt;size);
 
-	mutex_unlock(&amp;video-&gt;ctrl_mutex);
+	mutex_unlock(&amp;chain-&gt;ctrl_mutex);
 	return ret;
 }
 
diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_driver.c
--- a/linux/drivers/media/video/uvc/uvc_driver.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_driver.c	Thu Jul 02 01:24:47 2009 +0200
@@ -276,8 +276,20 @@
 	return NULL;
 }
 
+static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev, int id)
+{
+	struct uvc_streaming *stream;
+
+	list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
+		if (stream-&gt;header.bTerminalLink == id)
+			return stream;
+	}
+
+	return NULL;
+}
+
 /* ------------------------------------------------------------------------
- * Descriptors handling
+ * Descriptors parsing
  */
 
 static int uvc_parse_format(struct uvc_device *dev,
@@ -1159,101 +1171,36 @@
 }
 
 /* ------------------------------------------------------------------------
- * USB probe and disconnect
+ * UVC device scan
  */
 
 /*
- * Unregister the video devices.
- */
-static void uvc_unregister_video(struct uvc_device *dev)
-{
-	struct uvc_streaming *streaming;
-
-	list_for_each_entry(streaming, &amp;dev-&gt;streams, list) {
-		if (streaming-&gt;vdev == NULL)
-			continue;
-
-		if (streaming-&gt;vdev-&gt;minor == -1)
-			video_device_release(streaming-&gt;vdev);
-		else
-			video_unregister_device(streaming-&gt;vdev);
-		streaming-&gt;vdev = NULL;
-	}
-}
-
-static int uvc_register_video(struct uvc_device *dev,
-		struct uvc_streaming *stream)
-{
-	struct video_device *vdev;
-	struct uvc_entity *term;
-	int ret;
-
-	if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
-		uvc_printk(KERN_INFO, &quot;Found a valid video chain (&quot;);
-		list_for_each_entry(term, &amp;dev-&gt;video.iterms, chain) {
-			printk(&quot;%d&quot;, term-&gt;id);
-			if (term-&gt;chain.next != &amp;dev-&gt;video.iterms)
-				printk(&quot;,&quot;);
-		}
-		printk(&quot; -&gt; %d).\n&quot;, dev-&gt;video.oterm-&gt;id);
-	}
-
-	/* Initialize the streaming interface with default streaming
-	 * parameters.
-	 */
-	ret = uvc_video_init(stream);
-	if (ret &lt; 0) {
-		uvc_printk(KERN_ERR, &quot;Failed to initialize the device &quot;
-			&quot;(%d).\n&quot;, ret);
-		return ret;
-	}
-
-	/* Register the device with V4L. */
-	vdev = video_device_alloc();
-	if (vdev == NULL)
-		return -1;
-
-	/* We already hold a reference to dev-&gt;udev. The video device will be
-	 * unregistered before the reference is released, so we don't need to
-	 * get another one.
-	 */
-	vdev-&gt;parent = &amp;dev-&gt;intf-&gt;dev;
-	vdev-&gt;minor = -1;
-	vdev-&gt;fops = &amp;uvc_fops;
-	vdev-&gt;release = video_device_release;
-	strlcpy(vdev-&gt;name, dev-&gt;name, sizeof vdev-&gt;name);
-
-	/* Set the driver data before calling video_register_device, otherwise
-	 * uvc_v4l2_open might race us.
-	 */
-	stream-&gt;vdev = vdev;
-	video_set_drvdata(vdev, stream);
-
-	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) &lt; 0) {
-		stream-&gt;vdev = NULL;
-		video_device_release(vdev);
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
  * Scan the UVC descriptors to locate a chain starting at an Output Terminal
  * and containing the following units:
  *
- * - one Output Terminal (USB Streaming or Display)
+ * - one or more Output Terminals (USB Streaming or Display)
  * - zero or one Processing Unit
- * - zero, one or mode single-input Selector Units
+ * - zero, one or more single-input Selector Units
  * - zero or one multiple-input Selector Units, provided all inputs are
  *   connected to input terminals
  * - zero, one or mode single-input Extension Units
  * - one or more Input Terminals (Camera, External or USB Streaming)
  *
- * A side forward scan is made on each detected entity to check for additional
- * extension units.
+ * The terminal and units must match on of the following structures:
+ *
+ * ITT_*(0) -&gt; +---------+    +---------+    +---------+ -&gt; TT_STREAMING(0)
+ * ...         | SU{0,1} | -&gt; | PU{0,1} | -&gt; | XU{0,n} |    ...
+ * ITT_*(n) -&gt; +---------+    +---------+    +---------+ -&gt; TT_STREAMING(n)
+ *
+ *                 +---------+    +---------+ -&gt; OTT_*(0)
+ * TT_STREAMING -&gt; | PU{0,1} | -&gt; | XU{0,n} |    ...
+ *                 +---------+    +---------+ -&gt; OTT_*(n)
+ *
+ * The Processing Unit and Extension Units can be in any order. Additional
+ * Extension Units connected to the main chain as single-unit branches are
+ * also supported. Single-input Selector Units are ignored.
  */
-static int uvc_scan_chain_entity(struct uvc_video_device *video,
+static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
 {
 	switch (UVC_ENTITY_TYPE(entity)) {
@@ -1267,20 +1214,20 @@
 			return -1;
 		}
 
-		list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;extensions);
+		list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;extensions);
 		break;
 
 	case VC_PROCESSING_UNIT:
 		if (uvc_trace_param &amp; UVC_TRACE_PROBE)
 			printk(&quot; &lt;- PU %d&quot;, entity-&gt;id);
 
-		if (video-&gt;processing != NULL) {
+		if (chain-&gt;processing != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple &quot;
 				&quot;Processing Units in chain.\n&quot;);
 			return -1;
 		}
 
-		video-&gt;processing = entity;
+		chain-&gt;processing = entity;
 		break;
 
 	case VC_SELECTOR_UNIT:
@@ -1291,13 +1238,13 @@
 		if (entity-&gt;selector.bNrInPins == 1)
 			break;
 
-		if (video-&gt;selector != NULL) {
+		if (chain-&gt;selector != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple Selector &quot;
 				&quot;Units in chain.\n&quot;);
 			return -1;
 		}
 
-		video-&gt;selector = entity;
+		chain-&gt;selector = entity;
 		break;
 
 	case ITT_VENDOR_SPECIFIC:
@@ -1306,7 +1253,7 @@
 		if (uvc_trace_param &amp; UVC_TRACE_PROBE)
 			printk(&quot; &lt;- IT %d\n&quot;, entity-&gt;id);
 
-		list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;iterms);
+		list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;iterms);
 		break;
 
 	case TT_STREAMING:
@@ -1319,14 +1266,7 @@
 			return -1;
 		}
 
-		if (video-&gt;sterm != NULL) {
-			uvc_trace(UVC_TRACE_DESCR, &quot;Found multiple streaming &quot;
-				&quot;entities in chain.\n&quot;);
-			return -1;
-		}
-
-		list_add_tail(&amp;entity-&gt;chain, &amp;video-&gt;iterms);
-		video-&gt;sterm = entity;
+		list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;iterms);
 		break;
 
 	default:
@@ -1338,7 +1278,7 @@
 	return 0;
 }
 
-static int uvc_scan_chain_forward(struct uvc_video_device *video,
+static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
 	struct uvc_entity *entity, struct uvc_entity *prev)
 {
 	struct uvc_entity *forward;
@@ -1349,28 +1289,51 @@
 	found = 0;
 
 	while (1) {
-		forward = uvc_entity_by_reference(video-&gt;dev, entity-&gt;id,
+		forward = uvc_entity_by_reference(chain-&gt;dev, entity-&gt;id,
 			forward);
 		if (forward == NULL)
 			break;
-
-		if (UVC_ENTITY_TYPE(forward) != VC_EXTENSION_UNIT ||
-		    forward == prev)
+		if (forward == prev)
 			continue;
 
-		if (forward-&gt;extension.bNrInPins != 1) {
-			uvc_trace(UVC_TRACE_DESCR, &quot;Extension unit %d has &quot;
-				&quot;more than 1 input pin.\n&quot;, entity-&gt;id);
-			return -1;
-		}
+		switch (UVC_ENTITY_TYPE(forward)) {
+		case VC_EXTENSION_UNIT:
+			if (forward-&gt;extension.bNrInPins != 1) {
+				uvc_trace(UVC_TRACE_DESCR, &quot;Extension unit %d &quot;
+					  &quot;has more than 1 input pin.\n&quot;,
+					  entity-&gt;id);
+				return -EINVAL;
+			}
 
-		list_add_tail(&amp;forward-&gt;chain, &amp;video-&gt;extensions);
-		if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
-			if (!found)
-				printk(&quot; (-&gt; XU&quot;);
+			list_add_tail(&amp;forward-&gt;chain, &amp;chain-&gt;extensions);
+			if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
+				if (!found)
+					printk(&quot; (-&gt;&quot;);
 
-			printk(&quot; %d&quot;, forward-&gt;id);
-			found = 1;
+				printk(&quot; XU %d&quot;, forward-&gt;id);
+				found = 1;
+			}
+			break;
+
+		case OTT_VENDOR_SPECIFIC:
+		case OTT_DISPLAY:
+		case OTT_MEDIA_TRANSPORT_OUTPUT:
+		case TT_STREAMING:
+			if (UVC_ENTITY_IS_ITERM(forward)) {
+				uvc_trace(UVC_TRACE_DESCR, &quot;Unsupported input &quot;
+					&quot;terminal %u.\n&quot;, forward-&gt;id);
+				return -EINVAL;
+			}
+
+			list_add_tail(&amp;forward-&gt;chain, &amp;chain-&gt;oterms);
+			if (uvc_trace_param &amp; UVC_TRACE_PROBE) {
+				if (!found)
+					printk(&quot; (-&gt;&quot;);
+
+				printk(&quot; OT %d&quot;, forward-&gt;id);
+				found = 1;
+			}
+			break;
 		}
 	}
 	if (found)
@@ -1379,7 +1342,7 @@
 	return 0;
 }
 
-static int uvc_scan_chain_backward(struct uvc_video_device *video,
+static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
 {
 	struct uvc_entity *term;
@@ -1404,10 +1367,10 @@
 		if (uvc_trace_param &amp; UVC_TRACE_PROBE)
 			printk(&quot; &lt;- IT&quot;);
 
-		video-&gt;selector = entity;
+		chain-&gt;selector = entity;
 		for (i = 0; i &lt; entity-&gt;selector.bNrInPins; ++i) {
 			id = entity-&gt;selector.baSourceID[i];
-			term = uvc_entity_by_id(video-&gt;dev, id);
+			term = uvc_entity_by_id(chain-&gt;dev, id);
 			if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
 				uvc_trace(UVC_TRACE_DESCR, &quot;Selector unit %d &quot;
 					&quot;input %d isn't connected to an &quot;
@@ -1418,8 +1381,8 @@
 			if (uvc_trace_param &amp; UVC_TRACE_PROBE)
 				printk(&quot; %d&quot;, term-&gt;id);
 
-			list_add_tail(&amp;term-&gt;chain, &amp;video-&gt;iterms);
-			uvc_scan_chain_forward(video, term, entity);
+			list_add_tail(&amp;term-&gt;chain, &amp;chain-&gt;iterms);
+			uvc_scan_chain_forward(chain, term, entity);
 		}
 
 		if (uvc_trace_param &amp; UVC_TRACE_PROBE)
@@ -1432,108 +1395,264 @@
 	return id;
 }
 
-static int uvc_scan_chain(struct uvc_video_device *video)
+static int uvc_scan_chain(struct uvc_video_chain *chain,
+			  struct uvc_entity *oterm)
 {
 	struct uvc_entity *entity, *prev;
 	int id;
 
-	entity = video-&gt;oterm;
+	entity = oterm;
+	list_add_tail(&amp;entity-&gt;chain, &amp;chain-&gt;oterms);
 	uvc_trace(UVC_TRACE_PROBE, &quot;Scanning UVC chain: OT %d&quot;, entity-&gt;id);
 
-	if (UVC_ENTITY_TYPE(entity) == TT_STREAMING)
-		video-&gt;sterm = entity;
-
 	id = entity-&gt;output.bSourceID;
 	while (id != 0) {
 		prev = entity;
-		entity = uvc_entity_by_id(video-&gt;dev, id);
+		entity = uvc_entity_by_id(chain-&gt;dev, id);
 		if (entity == NULL) {
 			uvc_trace(UVC_TRACE_DESCR, &quot;Found reference to &quot;
 				&quot;unknown entity %d.\n&quot;, id);
-			return -1;
+			return -EINVAL;
+		}
+
+		if (entity-&gt;chain.next || entity-&gt;chain.prev) {
+			uvc_trace(UVC_TRACE_DESCR, &quot;Found reference to &quot;
+				&quot;entity %d already in chain.\n&quot;, id);
+			return -EINVAL;
 		}
 
 		/* Process entity */
-		if (uvc_scan_chain_entity(video, entity) &lt; 0)
-			return -1;
+		if (uvc_scan_chain_entity(chain, entity) &lt; 0)
+			return -EINVAL;
 
 		/* Forward scan */
-		if (uvc_scan_chain_forward(video, entity, prev) &lt; 0)
-			return -1;
+		if (uvc_scan_chain_forward(chain, entity, prev) &lt; 0)
+			return -EINVAL;
 
 		/* Stop when a terminal is found. */
-		if (!UVC_ENTITY_IS_UNIT(entity))
+		if (UVC_ENTITY_IS_TERM(entity))
 			break;
 
 		/* Backward scan */
-		id = uvc_scan_chain_backward(video, entity);
+		id = uvc_scan_chain_backward(chain, entity);
 		if (id &lt; 0)
 			return id;
 	}
 
-	if (video-&gt;sterm == NULL) {
-		uvc_trace(UVC_TRACE_DESCR, &quot;No streaming entity found in &quot;
-			&quot;chain.\n&quot;);
+	return 0;
+}
+
+static unsigned int uvc_print_terms(struct list_head *terms, char *buffer)
+{
+	struct uvc_entity *term;
+	unsigned int nterms = 0;
+	char *p = buffer;
+
+	list_for_each_entry(term, terms, chain) {
+		p += sprintf(p, &quot;%u&quot;, term-&gt;id);
+		if (term-&gt;chain.next != terms) {
+			p += sprintf(p, &quot;,&quot;);
+			if (++nterms &gt;= 4) {
+				p += sprintf(p, &quot;...&quot;);
+				break;
+			}
+		}
+	}
+
+	return p - buffer;
+}
+
+static const char *uvc_print_chain(struct uvc_video_chain *chain)
+{
+	static char buffer[43];
+	char *p = buffer;
+
+	p += uvc_print_terms(&amp;chain-&gt;iterms, p);
+	p += sprintf(p, &quot; -&gt; &quot;);
+	uvc_print_terms(&amp;chain-&gt;oterms, p);
+
+	return buffer;
+}
+
+/*
+ * Scan the device for video chains and register video devices.
+ *
+ * Chains are scanned starting at their output terminals and walked backwards.
+ */
+static int uvc_scan_device(struct uvc_device *dev)
+{
+	struct uvc_video_chain *chain;
+	struct uvc_entity *term;
+
+	list_for_each_entry(term, &amp;dev-&gt;entities, list) {
+		if (!UVC_ENTITY_IS_OTERM(term))
+			continue;
+
+		/* If the terminal is already included in a chain, skip it.
+		 * This can happen for chains that have multiple output
+		 * terminals, where all output terminals beside the first one
+		 * will be inserted in the chain in forward scans.
+		 */
+		if (term-&gt;chain.next || term-&gt;chain.prev)
+			continue;
+
+		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
+		if (chain == NULL)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&amp;chain-&gt;iterms);
+		INIT_LIST_HEAD(&amp;chain-&gt;oterms);
+		INIT_LIST_HEAD(&amp;chain-&gt;extensions);
+		mutex_init(&amp;chain-&gt;ctrl_mutex);
+		chain-&gt;dev = dev;
+
+		if (uvc_scan_chain(chain, term) &lt; 0) {
+			kfree(chain);
+			continue;
+		}
+
+		uvc_trace(UVC_TRACE_PROBE, &quot;Found a valid video chain (%s).\n&quot;,
+			  uvc_print_chain(chain));
+
+		list_add_tail(&amp;chain-&gt;list, &amp;dev-&gt;chains);
+	}
+
+	if (list_empty(&amp;dev-&gt;chains)) {
+		uvc_printk(KERN_INFO, &quot;No valid video chain found.\n&quot;);
 		return -1;
 	}
 
 	return 0;
 }
 
+/* ------------------------------------------------------------------------
+ * Video device registration and unregistration
+ */
+
 /*
- * Scan the device for video chains and register video devices.
- *
- * The driver currently supports a single video device per control interface
- * only. The terminal and units must match the following structure:
- *
- * ITT_* -&gt; VC_PROCESSING_UNIT -&gt; VC_EXTENSION_UNIT{0,n} -&gt; TT_STREAMING
- * TT_STREAMING -&gt; VC_PROCESSING_UNIT -&gt; VC_EXTENSION_UNIT{0,n} -&gt; OTT_*
- *
- * The Extension Units, if present, must have a single input pin. The
- * Processing Unit and Extension Units can be in any order. Additional
- * Extension Units connected to the main chain as single-unit branches are
- * also supported.
+ * Unregister the video devices.
  */
-static int uvc_scan_device(struct uvc_device *dev)
+static void uvc_unregister_video(struct uvc_device *dev)
 {
-	struct uvc_entity *term;
-	int found = 0;
+	struct uvc_streaming *stream;
 
-	/* Check if the control interface matches the structure we expect. */
-	list_for_each_entry(term, &amp;dev-&gt;entities, list) {
-		struct uvc_streaming *stream;
-
-		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
+	list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
+		if (stream-&gt;vdev == NULL)
 			continue;
 
-		memset(&amp;dev-&gt;video, 0, sizeof dev-&gt;video);
-		mutex_init(&amp;dev-&gt;video.ctrl_mutex);
-		INIT_LIST_HEAD(&amp;dev-&gt;video.iterms);
-		INIT_LIST_HEAD(&amp;dev-&gt;video.extensions);
-		dev-&gt;video.oterm = term;
-		dev-&gt;video.dev = dev;
-		if (uvc_scan_chain(&amp;dev-&gt;video) &lt; 0)
-			continue;
+		if (stream-&gt;vdev-&gt;minor == -1)
+			video_device_release(stream-&gt;vdev);
+		else
+			video_unregister_device(stream-&gt;vdev);
+		stream-&gt;vdev = NULL;
+	}
+}
 
-		list_for_each_entry(stream, &amp;dev-&gt;streams, list) {
-			if (stream-&gt;header.bTerminalLink ==
-			    dev-&gt;video.sterm-&gt;id) {
-				uvc_register_video(dev, stream);
-				found = 1;
-				break;
-			}
-		}
+static int uvc_register_video(struct uvc_device *dev,
+		struct uvc_streaming *stream)
+{
+	struct video_device *vdev;
+	int ret;
+
+	/* Initialize the streaming interface with default streaming
+	 * parameters.
+	 */
+	ret = uvc_video_init(stream);
+	if (ret &lt; 0) {
+		uvc_printk(KERN_ERR, &quot;Failed to initialize the device &quot;
+			&quot;(%d).\n&quot;, ret);
+		return ret;
 	}
 
-	if (!found) {
-		uvc_printk(KERN_INFO, &quot;No valid video chain found.\n&quot;);
-		return -1;
+	/* Register the device with V4L. */
+	vdev = video_device_alloc();
+	if (vdev == NULL) {
+		uvc_printk(KERN_ERR, &quot;Failed to allocate video device (%d).\n&quot;,
+			   ret);
+		return -ENOMEM;
+	}
+
+	/* We already hold a reference to dev-&gt;udev. The video device will be
+	 * unregistered before the reference is released, so we don't need to
+	 * get another one.
+	 */
+	vdev-&gt;parent = &amp;dev-&gt;intf-&gt;dev;
+	vdev-&gt;minor = -1;
+	vdev-&gt;fops = &amp;uvc_fops;
+	vdev-&gt;release = video_device_release;
+	strlcpy(vdev-&gt;name, dev-&gt;name, sizeof vdev-&gt;name);
+
+	/* Set the driver data before calling video_register_device, otherwise
+	 * uvc_v4l2_open might race us.
+	 */
+	stream-&gt;vdev = vdev;
+	video_set_drvdata(vdev, stream);
+
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret &lt; 0) {
+		uvc_printk(KERN_ERR, &quot;Failed to register video device (%d).\n&quot;,
+			   ret);
+		stream-&gt;vdev = NULL;
+		video_device_release(vdev);
+		return ret;
 	}
 
 	return 0;
 }
 
 /*
+ * Register all video devices in all chains.
+ */
+static int uvc_register_terms(struct uvc_device *dev,
+	struct uvc_video_chain *chain, struct list_head *terms)
+{
+	struct uvc_streaming *stream;
+	struct uvc_entity *term;
+	int ret;
+
+	list_for_each_entry(term, terms, chain) {
+		if (UVC_ENTITY_TYPE(term) != TT_STREAMING)
+			continue;
+
+		stream = uvc_stream_by_id(dev, term-&gt;id);
+		if (stream == NULL) {
+			uvc_printk(KERN_INFO, &quot;No streaming interface found &quot;
+				   &quot;for terminal %u.&quot;, term-&gt;id);
+			continue;
+		}
+
+		stream-&gt;chain = chain;
+		ret = uvc_register_video(dev, stream);
+		if (ret &lt; 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int uvc_register_chains(struct uvc_device *dev)
+{
+	struct uvc_video_chain *chain;
+	int ret;
+
+	list_for_each_entry(chain, &amp;dev-&gt;chains, list) {
+		ret = uvc_register_terms(dev, chain, &amp;chain-&gt;iterms);
+		if (ret &lt; 0)
+			return ret;
+
+		ret = uvc_register_terms(dev, chain, &amp;chain-&gt;oterms);
+		if (ret &lt; 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------
+ * USB probe, disconnect, suspend and resume
+ */
+
+/*
  * Delete the UVC device.
  *
  * Called by the kernel when the last reference to the uvc_device structure
@@ -1554,7 +1673,7 @@
 	struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
 	struct list_head *p, *n;
 
-	/* Unregister the video device. */
+	/* Unregister the video devices. */
 	uvc_unregister_video(dev);
 	usb_put_intf(dev-&gt;intf);
 	usb_put_dev(dev-&gt;udev);
@@ -1562,6 +1681,12 @@
 	uvc_status_cleanup(dev);
 	uvc_ctrl_cleanup_device(dev);
 
+	list_for_each_safe(p, n, &amp;dev-&gt;chains) {
+		struct uvc_video_chain *chain;
+		chain = list_entry(p, struct uvc_video_chain, list);
+		kfree(chain);
+	}
+
 	list_for_each_safe(p, n, &amp;dev-&gt;entities) {
 		struct uvc_entity *entity;
 		entity = list_entry(p, struct uvc_entity, list);
@@ -1602,6 +1727,7 @@
 		return -ENOMEM;
 
 	INIT_LIST_HEAD(&amp;dev-&gt;entities);
+	INIT_LIST_HEAD(&amp;dev-&gt;chains);
 	INIT_LIST_HEAD(&amp;dev-&gt;streams);
 	kref_init(&amp;dev-&gt;kref);
 	atomic_set(&amp;dev-&gt;users, 0);
@@ -1643,10 +1769,14 @@
 	if (uvc_ctrl_init_device(dev) &lt; 0)
 		goto error;
 
-	/* Scan the device for video chains and register video devices. */
+	/* Scan the device for video chains. */
 	if (uvc_scan_device(dev) &lt; 0)
 		goto error;
 
+	/* Register video devices. */
+	if (uvc_register_chains(dev) &lt; 0)
+		goto error;
+
 	/* Save our data pointer in the interface data. */
 	usb_set_intfdata(intf, dev);
 
diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvc_v4l2.c
--- a/linux/drivers/media/video/uvc/uvc_v4l2.c	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvc_v4l2.c	Thu Jul 02 01:24:47 2009 +0200
@@ -40,7 +40,7 @@
  * table for the controls that can be mapped directly, and handle the others
  * manually.
  */
-static int uvc_v4l2_query_menu(struct uvc_video_device *video,
+static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
 	struct v4l2_querymenu *query_menu)
 {
 	struct uvc_menu_info *menu_info;
@@ -49,7 +49,7 @@
 	u32 index = query_menu-&gt;index;
 	u32 id = query_menu-&gt;id;
 
-	ctrl = uvc_find_control(video, query_menu-&gt;id, &amp;mapping);
+	ctrl = uvc_find_control(chain, query_menu-&gt;id, &amp;mapping);
 	if (ctrl == NULL || mapping-&gt;v4l2_type != V4L2_CTRL_TYPE_MENU)
 		return -EINVAL;
 
@@ -493,7 +493,7 @@
 		}
 	}
 
-	handle-&gt;video = &amp;stream-&gt;dev-&gt;video;
+	handle-&gt;chain = stream-&gt;chain;
 	handle-&gt;stream = stream;
 	handle-&gt;state = UVC_HANDLE_PASSIVE;
 	file-&gt;private_data = handle;
@@ -542,7 +542,7 @@
 {
 	struct video_device *vdev = video_devdata(file);
 	struct uvc_fh *handle = (struct uvc_fh *)file-&gt;private_data;
-	struct uvc_video_device *video = handle-&gt;video;
+	struct uvc_video_chain *chain = handle-&gt;chain;
 	struct uvc_streaming *stream = handle-&gt;stream;
 	long ret = 0;
 
@@ -569,7 +569,7 @@
 
 	/* Get, Set &amp; Query control */
 	case VIDIOC_QUERYCTRL:
-		return uvc_query_v4l2_ctrl(video, arg);
+		return uvc_query_v4l2_ctrl(chain, arg);
 
 	case VIDIOC_G_CTRL:
 	{
@@ -579,9 +579,9 @@
 		memset(&amp;xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl-&gt;id;
 
-		uvc_ctrl_begin(video);
-		ret = uvc_ctrl_get(video, &amp;xctrl);
-		uvc_ctrl_rollback(video);
+		uvc_ctrl_begin(chain);
+		ret = uvc_ctrl_get(chain, &amp;xctrl);
+		uvc_ctrl_rollback(chain);
 		if (ret &gt;= 0)
 			ctrl-&gt;value = xctrl.value;
 		break;
@@ -596,18 +596,18 @@
 		xctrl.id = ctrl-&gt;id;
 		xctrl.value = ctrl-&gt;value;
 
-		uvc_ctrl_begin(video);
-		ret = uvc_ctrl_set(video, &amp;xctrl);
+		uvc_ctrl_begin(chain);
+		ret = uvc_ctrl_set(chain, &amp;xctrl);
 		if (ret &lt; 0) {
-			uvc_ctrl_rollback(video);
+			uvc_ctrl_rollback(chain);
 			return ret;
 		}
-		ret = uvc_ctrl_commit(video);
+		ret = uvc_ctrl_commit(chain);
 		break;
 	}
 
 	case VIDIOC_QUERYMENU:
-		return uvc_v4l2_query_menu(video, arg);
+		return uvc_v4l2_query_menu(chain, arg);
 
 	case VIDIOC_G_EXT_CTRLS:
 	{
@@ -615,17 +615,17 @@
 		struct v4l2_ext_control *ctrl = ctrls-&gt;controls;
 		unsigned int i;
 
-		uvc_ctrl_begin(video);
+		uvc_ctrl_begin(chain);
 		for (i = 0; i &lt; ctrls-&gt;count; ++ctrl, ++i) {
-			ret = uvc_ctrl_get(video, ctrl);
+			ret = uvc_ctrl_get(chain, ctrl);
 			if (ret &lt; 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls-&gt;error_idx = i;
 				return ret;
 			}
 		}
 		ctrls-&gt;error_idx = 0;
-		ret = uvc_ctrl_rollback(video);
+		ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
@@ -636,14 +636,14 @@
 		struct v4l2_ext_control *ctrl = ctrls-&gt;controls;
 		unsigned int i;
 
-		ret = uvc_ctrl_begin(video);
+		ret = uvc_ctrl_begin(chain);
 		if (ret &lt; 0)
 			return ret;
 
 		for (i = 0; i &lt; ctrls-&gt;count; ++ctrl, ++i) {
-			ret = uvc_ctrl_set(video, ctrl);
+			ret = uvc_ctrl_set(chain, ctrl);
 			if (ret &lt; 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls-&gt;error_idx = i;
 				return ret;
 			}
@@ -652,31 +652,31 @@
 		ctrls-&gt;error_idx = 0;
 
 		if (cmd == VIDIOC_S_EXT_CTRLS)
-			ret = uvc_ctrl_commit(video);
+			ret = uvc_ctrl_commit(chain);
 		else
-			ret = uvc_ctrl_rollback(video);
+			ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
 	/* Get, Set &amp; Enum input */
 	case VIDIOC_ENUMINPUT:
 	{
-		const struct uvc_entity *selector = video-&gt;selector;
+		const struct uvc_entity *selector = chain-&gt;selector;
 		struct v4l2_input *input = arg;
 		struct uvc_entity *iterm = NULL;
 		u32 index = input-&gt;index;
 		int pin = 0;
 
 		if (selector == NULL ||
-		    (video-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		    (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (index != 0)
 				return -EINVAL;
-			iterm = list_first_entry(&amp;video-&gt;iterms,
+			iterm = list_first_entry(&amp;chain-&gt;iterms,
 					struct uvc_entity, chain);
 			pin = iterm-&gt;id;
 		} else if (pin &lt; selector-&gt;selector.bNrInPins) {
 			pin = selector-&gt;selector.baSourceID[index];
-			list_for_each_entry(iterm, video-&gt;iterms.next, chain) {
+			list_for_each_entry(iterm, chain-&gt;iterms.next, chain) {
 				if (iterm-&gt;id == pin)
 					break;
 			}
@@ -697,14 +697,14 @@
 	{
 		u8 input;
 
-		if (video-&gt;selector == NULL ||
-		    (video-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain-&gt;selector == NULL ||
+		    (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			*(int *)arg = 0;
 			break;
 		}
 
-		ret = uvc_query_ctrl(video-&gt;dev, GET_CUR, video-&gt;selector-&gt;id,
-			video-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
+		ret = uvc_query_ctrl(chain-&gt;dev, GET_CUR, chain-&gt;selector-&gt;id,
+			chain-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
 			&amp;input, 1);
 		if (ret &lt; 0)
 			return ret;
@@ -720,18 +720,18 @@
 		if ((ret = uvc_acquire_privileges(handle)) &lt; 0)
 			return ret;
 
-		if (video-&gt;selector == NULL ||
-		    (video-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain-&gt;selector == NULL ||
+		    (chain-&gt;dev-&gt;quirks &amp; UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (input != 1)
 				return -EINVAL;
 			break;
 		}
 
-		if (input == 0 || input &gt; video-&gt;selector-&gt;selector.bNrInPins)
+		if (input == 0 || input &gt; chain-&gt;selector-&gt;selector.bNrInPins)
 			return -EINVAL;
 
-		return uvc_query_ctrl(video-&gt;dev, SET_CUR, video-&gt;selector-&gt;id,
-			video-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
+		return uvc_query_ctrl(chain-&gt;dev, SET_CUR, chain-&gt;selector-&gt;id,
+			chain-&gt;dev-&gt;intfnum, SU_INPUT_SELECT_CONTROL,
 			&amp;input, 1);
 	}
 
@@ -1064,10 +1064,10 @@
 	}
 
 	case UVCIOC_CTRL_GET:
-		return uvc_xu_ctrl_query(video, arg, 0);
+		return uvc_xu_ctrl_query(chain, arg, 0);
 
 	case UVCIOC_CTRL_SET:
-		return uvc_xu_ctrl_query(video, arg, 1);
+		return uvc_xu_ctrl_query(chain, arg, 1);
 
 	default:
 		if ((ret = v4l_compat_translate_ioctl(file, cmd, arg,
diff -r 88ef3b9f5071 -r 012e480c8e6a linux/drivers/media/video/uvc/uvcvideo.h
--- a/linux/drivers/media/video/uvc/uvcvideo.h	Sun Jun 28 13:37:50 2009 +0200
+++ b/linux/drivers/media/video/uvc/uvcvideo.h	Thu Jul 02 01:24:47 2009 +0200
@@ -224,9 +224,11 @@
 #define UVC_ENTITY_IS_UNIT(entity)	(((entity)-&gt;type &amp; 0xff00) == 0)
 #define UVC_ENTITY_IS_TERM(entity)	(((entity)-&gt;type &amp; 0xff00) != 0)
 #define UVC_ENTITY_IS_ITERM(entity) \
-	(((entity)-&gt;type &amp; 0x8000) == UVC_TERM_INPUT)
+	(UVC_ENTITY_IS_TERM(entity) &amp;&amp; \
+	((entity)-&gt;type &amp; 0x8000) == UVC_TERM_INPUT)
 #define UVC_ENTITY_IS_OTERM(entity) \
-	(((entity)-&gt;type &amp; 0x8000) == UVC_TERM_OUTPUT)
+	(UVC_ENTITY_IS_TERM(entity) &amp;&amp; \
+	((entity)-&gt;type &amp; 0x8000) == UVC_TERM_OUTPUT)
 
 #define UVC_STATUS_TYPE_CONTROL		1
 #define UVC_STATUS_TYPE_STREAMING	2
@@ -560,10 +562,24 @@
 	struct list_head irqqueue;
 };
 
+struct uvc_video_chain {
+	struct uvc_device *dev;
+	struct list_head list;
+
+	struct list_head iterms;		/* Input terminals */
+	struct list_head oterms;		/* Output terminals */
+	struct uvc_entity *processing;		/* Processing unit */
+	struct uvc_entity *selector;		/* Selector unit */
+	struct list_head extensions;		/* Extension units */
+
+	struct mutex ctrl_mutex;
+};
+
 struct uvc_streaming {
 	struct list_head list;
 	struct uvc_device *dev;
 	struct video_device *vdev;
+	struct uvc_video_chain *chain;
 	atomic_t active;
 
 	struct usb_interface *intf;
@@ -604,18 +620,6 @@
 	__u8 last_fid;
 };
 
-struct uvc_video_device {
-	struct uvc_device *dev;
-
-	struct list_head iterms;		/* Input terminals */
-	struct uvc_entity *oterm;		/* Output terminal */
-	struct uvc_entity *sterm;		/* USB streaming terminal */
-	struct uvc_entity *processing;
-	struct uvc_entity *selector;
-	struct list_head extensions;
-	struct mutex ctrl_mutex;
-};
-
 enum uvc_device_state {
 	UVC_DEV_DISCONNECTED = 1,
 };
@@ -638,8 +642,7 @@
 	__u32 clock_frequency;
 
 	struct list_head entities;
-
-	struct uvc_video_device video;
+	struct list_head chains;
 
 	/* Video Streaming interfaces */
 	struct list_head streams;
@@ -658,7 +661,7 @@
 };
 
 struct uvc_fh {
-	struct uvc_video_device *video;
+	struct uvc_video_chain *chain;
 	struct uvc_streaming *stream;
 	enum uvc_handle_state state;
 };
@@ -776,9 +779,9 @@
 extern int uvc_status_resume(struct uvc_device *dev);
 
 /* Controls */
-extern struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+extern struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 		__u32 v4l2_id, struct uvc_control_mapping **mapping);
-extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 		struct v4l2_queryctrl *v4l2_ctrl);
 
 extern int uvc_ctrl_add_info(struct uvc_control_info *info);
@@ -788,23 +791,23 @@
 extern int uvc_ctrl_resume_device(struct uvc_device *dev);
 extern void uvc_ctrl_init(void);
 
-extern int uvc_ctrl_begin(struct uvc_video_device *video);
-extern int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback);
-static inline int uvc_ctrl_commit(struct uvc_video_device *video)
+extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
+extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback);
+static inline int uvc_ctrl_commit(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 0);
+	return __uvc_ctrl_commit(chain, 0);
 }
-static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
+static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 1);
+	return __uvc_ctrl_commit(chain, 1);
 }
 
-extern int uvc_ctrl_get(struct uvc_video_device *video,
+extern int uvc_ctrl_get(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
-extern int uvc_ctrl_set(struct uvc_video_device *video,
+extern int uvc_ctrl_set(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
 
-extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
+extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 		struct uvc_xu_control *ctrl, int set);
 
 /* Utility functions */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004945.html">[Linux-uvc-devel] [PATCH 1/2] uvcvideo: Restructure the driver to	support multiple simultaneous streams.
</A></li>
	<LI>Next message: <A HREF="004951.html">[Linux-uvc-devel] [PATCH 2/2] uvcvideo: Multiple streaming interfaces support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4943">[ date ]</a>
              <a href="thread.html#4943">[ thread ]</a>
              <a href="subject.html#4943">[ subject ]</a>
              <a href="author.html#4943">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/linux-uvc-devel">More information about the Linux-uvc-devel
mailing list</a><br>
</body></html>
